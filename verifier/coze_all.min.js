var e={UnknownAlg:"UnknownAlg",ES224:"ES224",ES256:"ES256",ES384:"ES384",ES512:"ES512",Ed25519:"Ed25519",Ed25519ph:"Ed25519ph",Ed448:"Ed448",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512",SHA3224:"SHA3-224",SHA3256:"SHA3-256",SHA3384:"SHA3-384",SHA3512:"SHA3-512",SHAKE128:"SHAKE128",SHAKE256:"SHAKE256"},g={EC:"EC",SHA:"SHA",RSA:"RSA"},o={ECDSA:"ECDSA",EdDSA:"EdDSA",SHA2:"SHA2",SHA3:"SHA3"},f={P224:"P-224",P256:"P-256",P384:"P-384",P521:"P-521",Curve25519:"Curve25519",Curve448:"Curve448"},E={Sig:"sig",Enc:"enc",Hsh:"hsh"};function x(r){let t={};t.Name=r,t.Genus=y(r),t.Family=R(r),t.Use=I(r),t.Hash=l(r),t.HashSize=M(r),t.HashSizeB64=Math.ceil(4*t.HashSize/3);try{t.XSize=v(r),t.XSizeB64=Math.ceil(4*t.XSize/3),t.DSize=O(r),t.DSizeB64=Math.ceil(4*t.DSize/3),t.Curve=w(r),t.SigSize=j(r),t.SigSizeB64=Math.ceil(4*t.SigSize/3)}catch{}return t}function y(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:return o.ECDSA;case e.Ed25519:case e.Ed25519ph:case e.Ed448:return o.EdDSA;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:return o.SHA2;case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return o.SHA3;default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function R(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:case e.Ed25519:case e.Ed25519ph:case e.Ed448:return g.EC;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return g.SHA;default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function l(r){switch(r){case e.ES224:case e.SHA224:return e.SHA224;case e.SHA256:case e.ES256:return e.SHA256;case e.SHA384:case e.ES384:return e.SHA384;case e.SHA512:case e.ES512:case e.Ed25519:case e.Ed25519ph:return e.SHA512;case e.SHAKE128:return e.SHAKE128;case e.SHAKE256:case e.Ed448:return e.SHAKE256;case e.SHA3224:return e.SHA3224;case e.SHA3256:return e.SHA3256;case e.SHA3384:return e.SHA3384;case e.SHA3512:return e.SHA3512;default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function M(r){switch(l(r)){case e.SHA224:case e.SHA3224:return 28;case e.SHA256:case e.SHA3256:case e.SHAKE128:return 32;case e.SHA384:case e.SHA3384:return 48;case e.SHA512:case e.SHA3512:case e.SHAKE256:return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function j(r){switch(r){case e.ES224:return 56;case e.ES256:case e.Ed25519:case e.Ed25519ph:return 64;case e.ES384:return 96;case e.Ed448:return 114;case e.ES512:return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function v(r){switch(r){case e.Ed25519:case e.Ed25519ph:return 32;case e.ES224:return 56;case e.Ed448:return 57;case e.ES256:return 64;case e.ES384:return 96;case e.ES512:return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function O(r){switch(r){case e.ES224:return 28;case e.ES256:case e.Ed25519:case e.Ed25519ph:return 32;case e.ES384:return 48;case e.Ed448:return 57;case e.ES512:return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function w(r){switch(r){case e.ES224:return f.P224;case e.ES256:return f.P256;case e.ES384:return f.P384;case e.ES512:return f.P521;case e.Ed25519:case e.Ed25519ph:return f.Curve25519;case e.Ed448:return f.Curve448;default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function I(r){switch(y(r)){case o.EdDSA:case o.ECDSA:return E.Sig;case o.SHA2:case o.SHA3:return E.Hsh;default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var i={New:async function(r){switch(n(r)&&(r=e.ES256),r){case e.ES256:case e.ES384:case e.ES512:return await window.crypto.subtle.generateKey({name:o.ECDSA,namedCurve:w(r)},!0,["sign","verify"]);default:throw new Error("CryptoKey.New: Unsupported key algorithm:"+r)}},FromCozeKey:async function(r,t){if(y(r.alg)!=o.ECDSA)throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var a={};a.use=E.Sig,a.crv=w(r.alg),a.kty=g.EC;let s=v(r.alg)/2,c=await m(r.x);if(a.x=await A(c.slice(0,s)),a.y=await A(c.slice(s)),n(r.d)||t)var u="verify";else u="sign",a.d=r.d;return await crypto.subtle.importKey("jwk",a,{name:o.ECDSA,namedCurve:a.crv},!0,[u])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let t=await window.crypto.subtle.exportKey("jwk",r);var a={};a.alg=await i.algFromCrv(t.crv);let s=m(t.x),c=m(t.y);var u=new Uint8Array([...s,...c]);return a.x=A(u.buffer),t.hasOwnProperty("d")&&(a.d=t.d),a.tmb=await C(a),a},SignBuffer:async function(r,t){return await window.crypto.subtle.sign({name:o.ECDSA,hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,t)},SignBufferB64:async function(r,t){return await A(await i.SignBuffer(r,t))},SignString:async function(r,t){return await i.SignBufferB64(r,await S(t))},VerifyArrayBuffer:async function(r,t,a){return await i.ToPublic(r),await window.crypto.subtle.verify({name:o.ECDSA,hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,a,t)},VerifyMsg:async function(r,t,a){return i.VerifyArrayBuffer(r,await S(t),await D(a))},GetSignHashAlgoFromCryptoKey:async function(r){return l(await i.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case f.P224:var t=e.ES224;break;case f.P256:t=e.ES256;break;case f.P384:t=e.ES384;break;case f.P521:t=e.ES512;break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return t}};var X=["alg","x"];async function q(r){if(n(r)&&(r=e.ES256),y(r)==o.ECDSA)var t=await i.New(r);else throw new Error("Coze.NewKey: only ECDSA algs are currently supported.");let a=await i.ToCozeKey(t.privateKey);return a.iat=Math.floor(Date.now()/1e3),a.tmb=await C(a),a.kid="My Cyphr.me Key.",a}async function C(r){if(n(r.alg)||n(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return p(r,await l(r.alg),X)}async function L(r){if(n(r.d))return console.error("Coze key missing `d`"),!1;try{let t="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",a=await d(t,r);return K(t,r,a)}catch{return!1}}async function $(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(n(r.alg))return console.error("Correct: Alg must be set"),!1;let t=x(r.alg),a=n(r.tmb),s=n(r.x),c=n(r.d);if(a&&s&&c)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(s&&c)return a||r.tmb.length!==t.HashSizeB64?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!s&&r.x.length!==t.XSizeB64)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!a&&!s){let u=await C(r);if(r.tmb!==u)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!c&&!s){let u=await i.FromCozeKey(r),H=await S("Test Signing"),U=await i.SignBuffer(u,H),N=await i.FromCozeKey(r,!0);if(!await i.VerifyArrayBuffer(N,H,U))return console.error("Correct: private key invalid."),!1}return!0}async function rr(r,t){if(n(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var a={};a.pay={},n(t)||(a.pay.msg=t),a.pay.rvk=Math.round(Date.now()/1e3);let s=r.rvk;return delete r.rvk,a=await P(a,r),s!==void 0?r.rvk=s:r.rvk=a.pay.rvk,a}function T(r){return!(n(r.rvk)||!(parseInt(r.rvk)>0))}var er=["alg","iat","tmb","typ"];async function d(r,t){return i.SignBufferB64(await i.FromCozeKey(t),await S(r))}async function P(r,t,a){if(T(t))throw new Error("SignCoze: Cannot sign with revoked key.");return r.pay.alg=t.alg,r.pay.tmb=await C(t),r.pay.iat=Math.round(Date.now()/1e3),n(a)||(r.pay=await h(r.pay,a)),r.sig=await d(JSON.stringify(r.pay),t),r}async function tr(r,t,a){if(T(t))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return n(a)||(r.pay=await h(r.pay,a)),r.sig=await d(JSON.stringify(r.pay),t),r}async function K(r,t,a){return i.VerifyMsg(await i.FromCozeKey(t,!0),r,a)}async function B(r,t){if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("VerifyCoze: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.");return K(JSON.stringify(r.pay),t,r.sig)}async function ar(r,t){if(n(r.pay.alg))a=l(t);else var a=l(r.pay.alg);return r.can=await G(r.pay),r.cad=await p(r.pay,a),n(r.sig)||(r.czd=await p({cad:r.cad,sig:r.sig},a)),r}async function S(r){return new TextEncoder().encode(r).buffer}function D(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0)).buffer}function m(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0))}function A(r){return btoa(String.fromCharCode.apply(null,new Uint8Array(r))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function n(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!Z(r)}function Z(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function G(r){return Object.keys(r)}async function h(r,t){if(n(t))return r;let a={};for(let s of t)a[s]=r[s];return a}async function _(r,t){return JSON.stringify(await h(r,t))}async function J(r,t,a){if(n(t))throw new Error("Hash is not given");return await crypto.subtle.digest(t,await S(await _(r,a)))}async function p(r,t,a){return await A(await J(r,t,a))}async function sr(r,t){if(!Array.isArray(r))return B(r,t);var a={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCozies:[],FailedPosition:[]};let s=0,c=[...r];for(let u of c)n(u.coze)||(u=u.coze),await B(u,t)?a.VerifiedCount++:(a.FailedCount++,a.FailedCozies.push(u),a.FailedPosition.push(s)),s++;return a.FailedCount==0&&a.VerifiedCount>1&&(a.VerifiedAll=!0),a}export{e as Algs,A as ArrayBufferTo64ut,D as B64uToArrayBuffer,m as B64utToUint8Array,G as Canon,h as Canonical,J as CanonicalHash,p as CanonicalHash64,_ as CanonicalS,$ as Correct,i as CryptoKey,w as Curve,f as Curves,O as DSize,g as FamAlgs,R as Family,o as GenAlgs,y as Genus,l as HashAlg,M as HashSize,T as IsRevoked,ar as Meta,q as NewKey,x as Params,er as PayCanon,rr as Revoke,S as SToArrayBuffer,j as SigSize,d as Sign,P as SignCoze,tr as SignCozeRaw,C as Thumbprint,X as TmbCanon,I as Use,E as Uses,L as Valid,K as Verify,B as VerifyCoze,sr as VerifyCozeArray,v as XSize,n as isEmpty};
//# sourceMappingURL=coze_all.min.js.map
