{
  "version": 3,
  "sources": ["../alg.js", "../cryptokey.js", "../key.js", "../coze.js", "../canon.js", "../standard/coze_array.js"],
  "sourcesContent": ["\"use strict\";\n\n// For more documentation and notes, see the main Coze README.\n\nexport {\n\tAlgs,\n\tFamAlgs,\n\tGenAlgs,\n\tCurves,\n\tUses,\n\n\tParams,\n\tCurve,\n\tFamily,\n\tGenus,\n\tHashAlg,\n\tHashSize,\n\tSigSize,\n\tXSize,\n\tDSize,\n\tUse,\n\tCurveOrder,\n\tCurveHalfOrder,\n}\n\n/**\n* @typedef {import('./typedefs.js').Params}  Params\n* @typedef {import('./typedefs.js').Alg}     Alg\n* @typedef {import('./typedefs.js').Gen}     Gen\n* @typedef {import('./typedefs.js').Fam}     Fam\n* @typedef {import('./typedefs.js').Hsh}     Hsh\n* @typedef {import('./typedefs.js').Crv}     Crv\n* @typedef {import('./typedefs.js').Use}     Use\n*/\n\n/**\n* Algs holds all of the supported Coze algorithms.\n*/\nconst Algs = {\n\tUnknownAlg: \"UnknownAlg\",\n\tES224: \"ES224\",\n\tES256: \"ES256\",\n\tES384: \"ES384\",\n\tES512: \"ES512\",\n\tEd25519: \"Ed25519\",\n\tEd25519ph: \"Ed25519ph\",\n\tEd448: \"Ed448\",\n\tSHA224: \"SHA-224\",\n\tSHA256: \"SHA-256\",\n\tSHA384: \"SHA-384\",\n\tSHA512: \"SHA-512\",\n\tSHA3224: \"SHA3-224\",\n\tSHA3256: \"SHA3-256\",\n\tSHA3384: \"SHA3-384\",\n\tSHA3512: \"SHA3-512\",\n\tSHAKE128: \"SHAKE128\",\n\tSHAKE256: \"SHAKE256\",\n};\n\n/**\n* FamAlgs holds all of the supported Coze Family algorithms.\n*/\nconst FamAlgs = {\n\tEC: \"EC\",\n\tSHA: \"SHA\",\n\tRSA: \"RSA\",\n};\n\n/**\n* GenAlgs holds all of the supported Coze Genus algorithms.\n*/\nconst GenAlgs = {\n\tECDSA: \"ECDSA\",\n\tEdDSA: \"EdDSA\",\n\tSHA2: \"SHA2\",\n\tSHA3: \"SHA3\",\n};\n\n/**\n* Curves holds all of the supported Coze curve algorithms.\n*/\nconst Curves = {\n\tP224: \"P-224\",\n\tP256: \"P-256\",\n\tP384: \"P-384\",\n\tP521: \"P-521\",\n\tCurve25519: \"Curve25519\",\n\tCurve448: \"Curve448\",\n};\n\n/**\n* Uses holds all of the supported Coze uses.\n*/\nconst Uses = {\n\tSig: \"sig\",\n\tEnc: \"enc\",\n\tHsh: \"hsh\",\n};\n\n/**\n* Param reports all relevant values for a given `alg`.\n* Returns Params object with populated values for relevant fields.\n* All functions defined in this file will throw an error when given an\n* unsupported algorithm.\n* \n* @param   {Alg}      alg\n* @returns {Params}\n* @throws  {Error}\n*/\nfunction Params(alg) {\n\t/** @type {Params} */\n\tlet p = {};\n\tp.Name = alg;\n\tp.Genus = Genus(alg);\n\tp.Family = Family(alg);\n\tp.Use = Use(alg);\n\tp.Hash = HashAlg(alg);\n\tp.HashSize = HashSize(alg);\n\tp.HashSizeB64 = Math.ceil(4 * p.HashSize / 3);\n\n\t// SigAlg parameters\n\ttry {\n\t\tp.XSize = XSize(alg);\n\t\tp.XSizeB64 = Math.ceil(4 * p.XSize / 3);\n\t\tp.DSize = DSize(alg);\n\t\tp.DSizeB64 = Math.ceil(4 * p.DSize / 3);\n\t\tp.Curve = Curve(alg);\n\t\tp.SigSize = SigSize(alg);\n\t\tp.SigSizeB64 = Math.ceil(4 * p.SigSize / 3);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\n\treturn p;\n}\n\n/**\n* Genus returns the genus for an alg (ECDSA, EdDSA, SHA-2, SHA-3).\n* See notes on the Go implementation of Coze for more on genus.\n*\n* @param   {Alg}   alg\n* @returns {Gen}\n* @throws  {Error}\n*/\nfunction Genus(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.ES256:\n\t\tcase Algs.ES384:\n\t\tcase Algs.ES512:\n\t\t\treturn GenAlgs.ECDSA;\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\tcase Algs.Ed448:\n\t\t\treturn GenAlgs.EdDSA;\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA512:\n\t\t\treturn GenAlgs.SHA2;\n\t\tcase Algs.SHA3224:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHA3384:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE128:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn GenAlgs.SHA3;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Genus: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* Family returns the family for an alg (EC and SHA).\n* See notes on the Go implementation of Coze for more on family.\n*\n* @param   {Alg}     alg\n* @returns {Fam}\n* @throws  {Error}\n*/\nfunction Family(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.ES256:\n\t\tcase Algs.ES384:\n\t\tcase Algs.ES512:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\tcase Algs.Ed448:\n\t\t\treturn FamAlgs.EC;\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA512:\n\t\tcase Algs.SHA3224:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHA3384:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE128:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn FamAlgs.SHA\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Family:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* Hash returns the hashing algorithm for the given algorithm.  A hash alg can\n* return itself.\n* See notes on the Go implementation of Coze for more.\n*\n* @param   {Alg}   alg \n* @returns {Hsh}\n* @throws  {Error}\n*/\nfunction HashAlg(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.SHA224:\n\t\t\treturn Algs.SHA224;\n\t\tcase Algs.SHA256:\n\t\tcase Algs.ES256:\n\t\t\treturn Algs.SHA256;\n\t\tcase Algs.SHA384:\n\t\tcase Algs.ES384:\n\t\t\treturn Algs.SHA384;\n\t\tcase Algs.SHA512:\n\t\tcase Algs.ES512: // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn Algs.SHA512;\n\t\tcase Algs.SHAKE128:\n\t\t\treturn Algs.SHAKE128\n\t\tcase Algs.SHAKE256:\n\t\tcase Algs.Ed448:\n\t\t\treturn Algs.SHAKE256\n\t\tcase Algs.SHA3224:\n\t\t\treturn Algs.SHA3224\n\t\tcase Algs.SHA3256:\n\t\t\treturn Algs.SHA3256\n\t\tcase Algs.SHA3384:\n\t\t\treturn Algs.SHA3384\n\t\tcase Algs.SHA3512:\n\t\t\treturn Algs.SHA3512\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashAlg:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* HashSize returns the hashing algorithm size for the given algorithm in bytes\n* E.g. 32.\n* \n* SHAKE128 has 128 bits of pre-collision resistance and a capacity of 256,\n* although it has arbitrary output size. SHAKE256 has 256 bits of pre-collision\n* resistance and a capacity of 512, although it has arbitrary output size.\n* \n* See notes on the Go implementation of Coze for more.\n* \n* @param   {Alg}     alg\n* @returns {Number}\n* @throws  {Error}\n*/\nfunction HashSize(alg) {\n\tswitch (HashAlg(alg)) {\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA3224:\n\t\t\treturn 28;\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHAKE128:\n\t\t\treturn 32;\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA3384:\n\t\t\treturn 48;\n\t\tcase Algs.SHA512:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn 64;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* SigSize returns the signature size for the given algorithm in bytes.\n* \n* Curve P-521 uses 521 bits.  This is then padded up the the nearest byte (528)\n* for R and S. 132 = (528*2)/8\n* \n* See notes on the Go implementation of Coze for more.\n* \n* @param   {Alg}      alg\n* @returns {Number}\n* @throws  {Error}\n*/\nfunction SigSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn 56\n\t\tcase Algs.ES256:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 64\n\t\tcase Algs.ES384:\n\t\t\treturn 96\n\t\tcase Algs.Ed448:\n\t\t\treturn 114\n\t\tcase Algs.ES512:\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.SigSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* XSize returns the signature size for the given signature algorithm in bytes.\n* E.g. 64.\n* \n* ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n* (528) for R and S. (528*2)/8 = 132.\n*\n* See notes on the Go implementation of Coze for more.\n* \n* @param   {Alg}     alg\n* @returns {Number}\n* @throws  {Error}\n*/\nfunction XSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 32\n\t\tcase Algs.ES224:\n\t\t\treturn 56\n\t\tcase Algs.Ed448:\n\t\t\treturn 57\n\t\tcase Algs.ES256:\n\t\t\treturn 64\n\t\tcase Algs.ES384:\n\t\t\treturn 96\n\t\tcase Algs.ES512:\n\t\t\treturn 132 // X and Y are 66 bytes (Rounded up for P521)\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.XSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* DSize returns the signature size for the given signature algorithm in bytes.\n* E.g. 64.\n* \n* ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n* (528). (528)/8 = 66.\n*\n* See notes on the Go implementation of Coze for more.\n* \n* @param   {Alg}     alg\n* @returns {Number}\n* @throws  {Error}\n*/\nfunction DSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn 28\n\t\tcase Algs.ES256:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 32\n\t\tcase Algs.ES384:\n\t\t\treturn 48\n\t\tcase Algs.Ed448:\n\t\t\treturn 57\n\t\tcase Algs.ES512:\n\t\t\treturn 66\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.DSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n* Curve returns the curve algorithm for the given signature algorithm.\n* E.g. \"P-256\".\n* \n* See notes on the Go implementation of Coze for more.\n*\n* @param   {Alg}    alg \n* @returns {Crv}\n* @throws  {Error}\n*/\nfunction Curve(alg) {\n\tswitch (alg) {\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Curve: unsupported algorithm: \" + alg);\n\t\tcase Algs.ES224:\n\t\t\treturn Curves.P224;\n\t\tcase Algs.ES256:\n\t\t\treturn Curves.P256;\n\t\tcase Algs.ES384:\n\t\t\treturn Curves.P384;\n\t\tcase Algs.ES512: // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\t\treturn Curves.P521;\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn Curves.Curve25519;\n\t\tcase Algs.Ed448:\n\t\t\treturn Curves.Curve448;\n\t}\n}\n\n/**\n* Use returns the use for the given algorithm.  Only \"sig\", \"enc\", and \"dig\"\n* are currently valid.\n* Encryption (\"enc\") is currently not supported in Coze.\n* \n* See notes on the Go implementation of Coze for more.\n* \n* @param   {Alg}     alg \n* @returns {Use}\n* @throws  {Error}\n*/\nfunction Use(alg) {\n\tswitch (Genus(alg)) {\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Use: unsupported algorithm: \" + alg);\n\t\tcase GenAlgs.EdDSA:\n\t\tcase GenAlgs.ECDSA:\n\t\t\treturn Uses.Sig;\n\t\tcase GenAlgs.SHA2:\n\t\tcase GenAlgs.SHA3:\n\t\t\treturn Uses.Hsh;\n\t}\n}\n\n\nconst order = { \n\t\"ES224\" : BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\"),\n\t\"ES256\" : BigInt(\"0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\"),\n\t\"ES384\" : BigInt(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\"),\n\t\"ES512\" : BigInt(\"0x1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\"),\n}\n\nconst halfOrder = { \n\t\"ES224\" : order[\"ES224\"] >> BigInt(1),\n\t\"ES256\" : order[\"ES256\"] >> BigInt(1),\n\t\"ES384\" : order[\"ES384\"] >> BigInt(1),\n\t\"ES512\" : order[\"ES512\"] >> BigInt(1),\n}\n\n/* Curve Order returns the Curve's order.  \n* \n* @param   {Alg}     Alg \n* @returns {BigInt}\n* @throws  {Error}\n*/\nfunction CurveOrder(alg) {\n\tswitch (alg) {\n\t\tdefault:\n\t\t\tthrow new Error(\"CurveOrder: unsupported curve: \" + alg);\n\t\tcase  \"ES224\": case \"ES256\": case \"ES384\": case \"ES512\":\n\t\t\treturn order[alg];\n\t}\n}\n\n/* Curve Order returns the Curve's order halved.  \n* \n* @param   {Alg}     Alg \n* @returns {BigInt}\n* @throws  {Error}\n*/\nfunction CurveHalfOrder(alg) {\n\tswitch (alg) {\n\t\tdefault:\n\t\t\tthrow new Error(\"CurveHalfOrder: unsupported curve: \" + alg);\n\t case  \"ES224\": case \"ES256\": case \"ES384\": case \"ES512\":\n\t\t\treturn halfOrder[alg];\n\t}\n}\n", "\"use strict\";\n\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport * as CZK from './key.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\n\nexport {\n\tCryptoKey,\n\tSigToLowS,\n\tIsSigLowS,\n};\n\n/**\n * @typedef {import('./typedefs.js').B64}      B64\n * @typedef {import('./typedefs.js').Alg}      Alg\n * @typedef {import('./typedefs.js').Sig}      Sig\n * @typedef {import('./typedefs.js').Hsh}      Hsh\n * @typedef {import('./typedefs.js').Key}      Key\n * @typedef {import('./typedefs.js').Crv}      Crv\n * @typedef {import('./typedefs.js').Msg}      Msg\n */\n\n\nvar CryptoKey = {\n\t/**\n\t * New returns a ECDSA CryptoKeyPair. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKeyPair\n\t * \n\t * @param  {Alg}           [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n\t * @return {CryptoKeyPair}\n\t * @throws {Error}         Error, SyntaxError, DOMException, TypeError\n\t */\n\tNew: async function(alg) {\n\t\tif (isEmpty(alg)) {\n\t\t\talg = Alg.Algs.ES256;\n\t\t}\n\t\t// Javascript only supports ECDSA, and doesn't support ES192 or ES224.  See\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams\n\t\tswitch (alg) {\n\t\t\tcase Alg.Algs.ES256:\n\t\t\tcase Alg.Algs.ES384:\n\t\t\tcase Alg.Algs.ES512:\n\t\t\t\treturn await window.crypto.subtle.generateKey({\n\t\t\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\t\t\tnamedCurve: Alg.Curve(alg)\n\t\t\t\t\t},\n\t\t\t\t\ttrue,\n\t\t\t\t\t[\"sign\", \"verify\"]\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.New: Unsupported key algorithm:\" + alg);\n\t\t}\n\t},\n\n\t/**\n\t * FromCozeKey takes a Coze Key and returns a Javascript CryptoKey.  Only\n\t * supports ECDSA since Crypto.subtle only supports ECDSA. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * \n\t * Throws error on invalid keys.\n\t * \n\t * @param   {Key}        cozeKey          Coze key.\n\t * @param   {Boolean}    [public=false]   Return only a public key.\n\t * @returns {CryptoKey}\n\t * @throws  {Error}                Error, SyntaxError, DOMException, TypeError\n\t */\n\tFromCozeKey: async function(cozeKey, onlyPublic) {\n\t\tif (Alg.Genus(cozeKey.alg) != Alg.GenAlgs.ECDSA) {\n\t\t\tthrow new Error(\"CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: \" + cozeKey.alg);\n\t\t}\n\n\t\t// Create a new JWK that can be used to create and \"import\" a CryptoKey\n\t\tvar jwk = {};\n\t\tjwk.use = Alg.Uses.Sig;\n\t\tjwk.crv = Alg.Curve(cozeKey.alg);\n\t\tjwk.kty = Alg.FamAlgs.EC;\n\n\t\tlet half = Alg.XSize(cozeKey.alg) / 2;\n\t\tlet xyab = await Coze.B64ToUint8Array(cozeKey.x);\n\t\tjwk.x = await Coze.ArrayBufferTo64ut(xyab.slice(0, half));\n\t\tjwk.y = await Coze.ArrayBufferTo64ut(xyab.slice(half));\n\n\t\t// Public CryptoKey \"crypto.subtle.importKey\" needs key use to be \"verify\"\n\t\t// even though this doesn't exist in JWK RFC or IANA registry. (2021/05/12)\n\t\t// Gawd help us.  Private CryptoKey needs key `use` to be \"sign\".\n\t\tif (isEmpty(cozeKey.d) || onlyPublic) {\n\t\t\tvar signOrVerify = \"verify\";\n\t\t} else {\n\t\t\tsignOrVerify = \"sign\";\n\t\t\tjwk.d = cozeKey.d;\n\t\t}\n\n\t\treturn await crypto.subtle.importKey(\n\t\t\t\"jwk\",\n\t\t\tjwk, {\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\tnamedCurve: jwk.crv,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[signOrVerify]\n\t\t);\n\t},\n\n\t/**\n\t * ToPublic accepts a Javascript CryptoKey and modifies the key to remove\n\t * any private components.\n\t *\n\t * @param   {CryptoKey} cryptoKey\n\t * @returns {void}\n\t */\n\tToPublic: async function(cryptoKey) {\n\t\tdelete cryptoKey.d; // Remove private `d` from the key.\n\t\t// Only [\"verify\"] is a valid `key_ops` value for a public CryptoKey.\n\t\t// `key_ops` must be an array.\n\t\tcryptoKey.key_ops = [\"verify\"];\n\t},\n\n\t/**\n\t * CryptoKeyToCozeKey returns a Coze Key from Javascript's \"CryptoKey\" type.\n\t * (https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) Coze keys are\n\t * similiar to JOSE JWK's but has a few significant differences.\n\t * See the Coze docs for more on these differences.\n\t * \n\t * - Coze Byte-to-string values are always b64ut, \"RFC 4648 base64 URI Safe\n\t * Truncated\".\n\t * - Coze keys also use the field `alg` to denote everything about the key:\n\t * it's use, hashing algorithm, curve, family, signature size, private\n\t * component size, public component size, etc...\n\t * - A Coze key's Thumbprint's hashing algorithm must always be in alignment\n\t * with the alg.  This is unlike JOSE which appears to use SHA-256 even for\n\t * keys that don't use that algorithm.\n\t * \n\t * This function currently only supports ECDSA (ES256. ES384, ES512) as\n\t * crypto.subtle only supports these ECDSA algorithms. From Cryptokey,\n\t * `exported` key output should is in the following form:\n\t * \n\t * {\n\t * \"crv\": \"P-256\",\n\t * \"d\": \"GwJgQIcbB29IfWO46QZwansE5XVVOg_CfafcpGk3K9I\",\n\t * \"key_ops\": [\n\t * \"sign\",\n\t * \"verify\"\n\t * ],\n\t * \"kty\": \"EC\",\n\t * \"x\": \"bMgUwXPLFR5WPERFIdUR8f6J9znFlM4fL-TaYr7YNSo\",\n\t * \"y\": \"vuU0bE-JafF1zEW_MbL-oaO0eGltDeMHIfc_bxkdCHU\",\n\t * \"use\": \"sig\"\n\t * }\n\t * \n\t * Some aspects of the Javascript exported key are in conflict with JOSE. The\n\t * `delete`s below are for reference of how out of alignment the Javascript\n\t * representation is from JOSE.  If for some reason a JOSE representation is\n\t * required, the deletes are suggested.\n\t * \n\t * `delete exported.key_ops;`\n\t * \n\t * According to RFC 7517 Section 4.3, \"use\" is mutually exclusive with\n\t * key_ops.\n\t * \n\t * `delete exported[\"ext\"];`\n\t * \n\t * `ext` is define by the Web Cryptography API and does not appear in the\n\t * core JOSE RFC's.  It stands for \"extractable\".  Since the key is already\n\t * \"extracted\" we don't care, and we're not going to burden downstream with\n\t * it.  However, this may need to be added again later if the key is further\n\t * manipulated by SubtleCrypto. \n\t * \n\t * Coze does not use \"crv\", \"kty\", or \"use\" and instead relies solely on\n\t * \"alg\". Since alg is not given, it's assumed from `crv` while `kty`is\n\t * ignored.\n\t * \n\t * Why are we exporting to JWK?\n\t * 1. There's no access to the key fields without exporting. (The\n\t * browser hides the information from Javascript.)\n\t * 2. The exporting formats are limited.  \n\t * 3. Can't export to \"raw\" because \"raw\" appears to only work on public\n\t * keys.  This may be a private key.\n\t * \n\t * @param   {CryptoKey}   cryptoKey \n\t * @returns {Key}\n\t * @throws  {Error}\n\t */\n\tToCozeKey: async function(cryptoKey) {\n\t\tlet exported = await window.crypto.subtle.exportKey(\n\t\t\t\"jwk\",\n\t\t\tcryptoKey\n\t\t);\n\n\t\tvar czk = {};\n\t\tczk.alg = await CryptoKey.algFromCrv(exported.crv);\n\t\t// Concatenate x and y, but concatenation is done at the byte level, so:\n\t\t// unencode, concatenated, and encoded. \n\t\tlet xui8 = Coze.B64ToUint8Array(exported.x);\n\t\tlet yui8 = Coze.B64ToUint8Array(exported.y);\n\t\tvar xyui8 = new Uint8Array([\n\t\t\t...xui8,\n\t\t\t...yui8,\n\t\t]);\n\t\tczk.x = Coze.ArrayBufferTo64ut(xyui8.buffer);\n\n\t\t// Only private ECDSA keys have `d`.\n\t\tif (exported.hasOwnProperty('d')) {\n\t\t\tczk.d = exported.d;\n\t\t}\n\n\t\tczk.tmb = await CZK.Thumbprint(czk);\n\t\t// console.log(\"exported: \" + JSON.stringify(exported), \"Coze Key: \" + JSON.stringify(czk)); // Debugging\n\t\treturn czk;\n\t},\n\n\t/**\n\t * Uses a Javascript `CryptoKey` to sign a array buffer.  Returns array buffer\n\t * bytes of the signature. Returns empty buffer on error.\n\t *\n\t * The signing algorithm's hashing algorithm is used for the digest of the\n\t * payload.  \n\t * \n\t * Coze uses UTF-8.\n\t *\n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n\t * \n\t * @param   {CryptoKey}      cryptoKey\n\t * @param   {ArrayBuffer}    payloadBuffer\n\t * @returns {ArrayBuffer}\n\t * @throws  {Error}\n\t */\n\tSignBuffer: async function(cryptoKey, arrayBuffer) {\n\t\tlet alg = await CryptoKey.algFromCrv(cryptoKey.algorithm.namedCurve);\n\t\tlet sig = await window.crypto.subtle.sign({\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\thash: {\n\t\t\t\t\tname: Alg.HashAlg(alg)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tarrayBuffer\n\t\t);\n\n\t\tsig = sigToLowSArrayBuffer(alg, sig);\n\t\treturn sig;\n\t},\n\n\n\t/**\n\t * SignBufferB64 signs a buffer with a CryptoKey and returns the b64ut\n\t * signature. The input is hashed before it's signed.\n\t * Coze uses UTF-8.\n\t *\n\t * @param   {CryptoKey}   cryptoKey       Private CryptoKey\n\t * @param   {ArrayBuffer} arrayBuffer     ArrayBuffer to sign.\n\t * @returns {B64}\n\t */\n\tSignBufferB64: async function(cryptoKey, arrayBuffer) {\n\t\treturn await Coze.ArrayBufferTo64ut(await CryptoKey.SignBuffer(cryptoKey, arrayBuffer));\n\t},\n\n\t/**\n\t * SignString signs a string and returns the b64ut signature.\n\t * Coze uses UTF-8.\n\t * \n\t * @param   {CryptoKey} cryptoKey      Private key used for signing.\n\t * @param   {String}    utf8           String to sign.\n\t * @returns {B64}\n\t */\n\tSignString: async function(cryptoKey, utf8) {\n\t\treturn await CryptoKey.SignBufferB64(cryptoKey, await Coze.SToArrayBuffer(utf8));\n\t},\n\n\t/**\n\t * VerifyArrayBuffer verifies an ArrayBuffer msg with an ArrayBuffer sig and\n\t * Javascript CryptoKey.\n\t * Returns whether or not message is verified by the given key and signature.\n\t * \n\t * @param   {Alg}         alg\n\t * @param   {CryptoKey}   cryptoKey           Javascript CryptoKey.\n\t * @param   {ArrayBuffer} sig                 Signature.\n\t * @param   {ArrayBuffer} msg                 Message.\n\t * @returns {Boolean}\n\t */\n\tVerifyArrayBuffer: async function(alg, cryptoKey, msg, sig) {\n\t\t// Currently, Coze_js is only ECDSA.  For ECDSA, only accept low-S\n\t\t// signatures.  \n\t\tif (!(await IsSigLowS(alg, sig))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Guarantee key is not private to appease Javascript \uD83D\uDE14:\n\t\tawait CryptoKey.ToPublic(cryptoKey);\n\t\treturn await window.crypto.subtle.verify({\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tsig,\n\t\t\tmsg);\n\t},\n\n\t/**\n\t * VerifyMsg uses a public key to verify a string msg with a b64ut sig.\n\t * Returns whether or not the signature is valid.\n\t * \n\t * @param   {Alg}        alg\n\t * @param   {CryptoKey}  cryptoKey         Javascript CryptoKey.\n\t * @param   {Msg}        msg               String that was signed.\n\t * @param   {Sig}        sig               B64 signature.\n\t * @returns {Boolean}\n\t */\n\tVerifyMsg: async function(alg, cryptoKey, msg, sig) {\n\t\treturn CryptoKey.VerifyArrayBuffer(alg, cryptoKey, await Coze.SToArrayBuffer(msg), await Coze.B64uToArrayBuffer(sig));\n\t},\n\n\t/**\n\t * GetSignHashAlgoFromCryptoKey gets the signing hashing algorithm from the\n\t * CryptoKey.\n\t * Returns the name of the hashing algorithm. E.g. \"SHA-256\".\n\t *\n\t * Javascript's CryptoKey explicitly requires a signing hashing algorithm, but\n\t * the CryptoKey itself may not explicitly contain that information. For\n\t * example, a ES256 key will have the curve (P-256) and the general key type\n\t * (ECDSA), but the hashing algo is not explicitly stated (SHA-256), nor is\n\t * the algorithm explicitly stated (ES256).\n\t *\n\t * However, for some CryptoKeys, the hashing algorithm is explicitly stated.\n\t * For example, \"RsaHashedKeyGenParams\" has the field \"hash\" which explicitly\n\t * denotes what hashing algorithm was used.  As of 2021/05/26,\n\t * \"EcKeyGenParams\" has no such field, so it must be assumed that certain\n\t * hashing algorithms are paired with certain curves.\n\t *\n\t * The purpose of this function is to return the correct hashing digest for\n\t * all CryptoKeys regardless of their form.\n\t * \n\t * @param   {CryptoKey} CryptoKey  CryptoKey Javascript object.\n\t * @returns {Hsh}\n\t * @throws  {Error}                Fails if alg is not supported.\n\t */\n\tGetSignHashAlgoFromCryptoKey: async function(cryptoKey) {\n\t\treturn Alg.HashAlg(await CryptoKey.algFromCrv(cryptoKey.algorithm.namedCurve));\n\t},\n\n\t/**\n\t * algFromCrv returns a SEAlg from the given curve.\n\t * Fails if curve is not supported.\n\t * \n\t * @param   {Crv}     src    Curve type. E.g. \"P-256\".\n\t * @returns {Alg}\n\t * @throws  {Error}\n\t */\n\talgFromCrv: async function(crv) {\n\t\tswitch (crv) {\n\t\t\tcase Alg.Curves.P224:\n\t\t\t\tvar alg = Alg.Algs.ES224;\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P256:\n\t\t\t\talg = Alg.Algs.ES256\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P384:\n\t\t\t\talg = Alg.Algs.ES384;\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P521: // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\t\talg = Alg.Algs.ES512;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\t\treturn alg;\n\t}\n}; // End CryptoKey\n\n\n\n/** Checks if S is a \"low-S\".  See the Coze docs on \"Low-S\"\n *\n * @param   {Alg}        alg\n * @param   {BigInt}     s\n * @returns {BigInt}\n * @throws  {Error}\n */\nfunction IsLowS(alg, s) {\n\tif (typeof s !== \"bigint\") {\n\t\tthrow new Error(\"IsLowS: s is not of type bigint\");\n\t}\n\treturn Alg.CurveHalfOrder(alg) > s;\n}\n\n/** Makes sure that s is a \"low-S\".  See the Coze docs on \"Low-S\" and the Go\n * package's \"ToLowS\" function.  \n *\n * @param   {Alg}       alg\n * @param   {BigInt}    s\n * @returns {BigInt}\n * @throws  {Error}\n */\nfunction toLowS(alg, s) {\n\tif (typeof s !== \"bigint\") {\n\t\tthrow new Error(\"toLowS: s is not of type bigint\");\n\t}\n\tif (!IsLowS(alg, s)) {\n\t\treturn Alg.CurveOrder(alg) - s;\n\t}\n\treturn s\n}\n\n/** Makes sure that S in sig is a \"low-S\" and converts if needed.  See the Coze\n * docs on \"low-S\"\n * \n * @param   {Alg}      alg\n * @param   {Sig}      sig\n * @returns {Sig}\n * @throws  {Error}\n */\nasync function SigToLowS(alg, sig) {\n\tlet ab = await Coze.B64uToArrayBuffer(sig);\n\tlet lowSSigAB = await sigToLowSArrayBuffer(alg, ab);\n\t return Coze.ArrayBufferTo64ut(lowSSigAB);\n}\n\n/** SigIsLowS checks if S in sig is a \"low-S\".  See the Coze docs on \"low-S\"\n * \n * @param   {Alg}      alg\n * @param   {Sig}      sig\n * @returns {Boolean}\n * @throws  {Error}\n */\nasync function IsSigLowS(alg, sig) {\n\tlet bigIntS = await sigToS(alg, sig);\n\treturn IsLowS(alg, bigIntS);\n}\n\n/**\n * Returns S from sig.  \n * @param   {Alg}            alg    Return only a public key.\n * @param   {ArrayBuffer}    sig    Sig ArrayBuffer from subtle crypto\n * @returns {BigInt}\n * @throws  {Error}         Error, SyntaxError, DOMException, TypeError\n */\nfunction sigToS(alg, sig) {\n\tlet half = Alg.SigSize(alg) / 2;\n\tlet s = sig.slice(half);\n\treturn arrayBufferToBigInt(s);\n}\n\n\n/**\n * \n * @param   {Alg}            alg    Return only a public key.\n * @param   {ArrayBuffer}    sig    Sig ArrayBuffer from subtle crypto\n * @returns {ArrayBuffer}\n * @throws  {Error}         Error, SyntaxError, DOMException, TypeError\n */\nasync function sigToLowSArrayBuffer(alg, sig) {\n\tlet half = Alg.SigSize(alg) / 2;\n\tlet r = sig.slice(0, half);\n\tlet s = sig.slice(half);\n\tlet bigIntS = arrayBufferToBigInt(s);\n\tlet bigIntNormS = toLowS(alg, bigIntS);\n\t// console.log(\"sig in:\", sig);\n\t// console.log(\"r:\", r);\n\t// console.log(\"s:\", s);\n\t// console.log(\"s hex:\", bigIntS.toString(16).toUpperCase());\n\t// console.log(\"IsLowS: \", IsLowS(alg, bigIntS));\n\t// console.log(\"Before toLowS\", bigIntS)\n\t// console.log(\"After toLowS\", bigIntNormS)\n\tlet normS = bigIntToArrayBuffer(Alg.SigSize(alg) / 2, bigIntNormS);\n\n\n\t// Add two ArrayBuffers, but it's Javascript so it's hard.  \uD83D\uDE14 This is just\n\t// doing `sig = r + normS`;\n\tvar tmp = new Uint8Array(r.byteLength + normS.byteLength);\n\ttmp.set(new Uint8Array(r), 0);\n\ttmp.set(new Uint8Array(normS), r.byteLength);\n\tsig = tmp.buffer;\n\treturn sig\n}\n\n/** Converts a Big Endian ArrayBuffer to BigInt.  \n * \n * @param   {ArrayBuffer}         buffer\n * @returns {BigInt}         \n */\nfunction arrayBufferToBigInt(buffer) {\n\tlet result = 0n;\n\tlet a = new Uint8Array(buffer)\n\tfor (let i = 0; i < a.length; i++) {\n\t\tresult = (result << 8n) + BigInt(a[i]);\n\t}\n\treturn result;\n}\n\n/** Converts a BigInt to a Big Endian ArrayBuffer.  \n * \n * @param   {size}         int    // Number of bytes to pad the ArrayBuffer \n * @param   {Bigint}       bigInt \n * @returns {ArrayBuffer}  buffer\n */\nfunction bigIntToArrayBuffer(size, bigInt) {\n\tconst buffer = new ArrayBuffer(size);\n\tconst view = new DataView(buffer);\n\n\tdo {\n\t\tsize--;\n\t\tview.setUint8(size, Number(bigInt & BigInt(0xff)));\n\t\tbigInt >>= 8n;\n\t} while (size > 0);\n\treturn buffer;\n}", "\"use strict\";\n\nimport * as CTK from './cryptokey.js';\nimport * as Can from './canon.js';\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tNewKey,\n\tCorrect,\n\tValid,\n\tThumbprint,\n\tRevoke,\n\tIsRevoked,\n\n\t// RecalcX,\n\n\tTmbCanon,\n}\n\n/**\n * @typedef {import('./typedefs.js').B64}  B64\n * @typedef {import('./typedefs.js').Alg}  Alg\n * @typedef {import('./typedefs.js').Use}  Use\n * @typedef {import('./typedefs.js').Sig}  Sig\n * @typedef {import('./typedefs.js').Key}  Key\n * @typedef {import('./typedefs.js').Time} Time\n */\n\n// Coze key Thumbprint Canons.\nconst TmbCanon = [\"alg\", \"x\"];\n\n/**\n * NewKey returns a new Coze key.\n * If no alg is given, the returned key will be an 'ES256' key.\n * \n * @param   {Alg}     [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n * @returns {Key}\n */\nasync function NewKey(alg) {\n\tif (isEmpty(alg)) {\n\t\talg = Alg.Algs.ES256;\n\t}\n\tif (Alg.Genus(alg) == Alg.GenAlgs.ECDSA) {\n\t\tvar keyPair = await CTK.CryptoKey.New(alg);\n\t} else {\n\t\tthrow new Error(\"Coze.NewKey: only ECDSA algs are currently supported.\");\n\t}\n\n\tlet k = await CTK.CryptoKey.ToCozeKey(keyPair.privateKey);\n\tk.iat = Math.floor(Date.now() / 1000); // To get Unix from js, divide by 1000.\n\tk.tmb = await Thumbprint(k);\n\tk.kid = \"My Cyphr.me Key.\";\n\n\treturn k;\n}\n\n/**\n * Thumbprint generates and returns a B64 Coze key thumbprint.\n * Fails on empty 'alg' or 'x'.\n *\n * @param   {Key} cozeKey\n * @returns {B64}\n * @throws  {Error}\n */\nasync function Thumbprint(cozeKey) {\n\tif (isEmpty(cozeKey.alg) || isEmpty(cozeKey.x)) {\n\t\tthrow new Error(\"Coze.Thumbprint: alg or x is empty.\");\n\t}\n\treturn Can.CanonicalHash64(cozeKey, await Alg.HashAlg(cozeKey.alg), TmbCanon);\n};\n\n/**\n * Valid returns true only for a valid private Coze key.\n *\n * @param   {Key}      privateCozeKey  Private Coze key.\n * @returns {Boolean}\n */\nasync function Valid(privateCozeKey) {\n\tif (isEmpty(privateCozeKey.d)) {\n\t\tconsole.error(\"Coze key missing `d`\");\n\t\treturn false;\n\t}\n\ttry {\n\t\tlet msg = `7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q`;\n\t\tlet sig = await Coze.SignPay(msg, privateCozeKey);\n\t\treturn Coze.VerifyPay(msg, privateCozeKey, sig);\n\t} catch (e) {\n\t\t//console.debug(\"Valid error: \" + e);\n\t\treturn false;\n\t}\n}\n\n/**\n * Correct checks for the correct construction of a Coze key, but may return\n * true on cryptographically invalid public keys.  Key must have `alg` and at\n * least one of `tmb`, `x`, and `d`. Using input information, if it is possible\n * to definitively know the given key is incorrect, Correct returns false, but\n * if it's plausible it's correct, Correct returns true. Correct answers the\n * question: \"Is the given Coze key reasonable using the information provided?\".\n * Correct is useful for sanity checking public keys without signed messages,\n * sanity checking `tmb` only keys, and validating private keys. Use function\n * \"Verify\" instead for verifying public keys when a signed message is\n * available. Correct is considered an advanced function. Please understand it\n * thoroughly before use.\n * \n * Correct:\n * \n * 1. Checks the length of `x` and/or `tmb` against `alg`.\n * 2. If `x` and `tmb` are present, verifies correct `tmb`.\n * 3. If `d` is present, verifies correct `tmb` and `x` if present, and verifies\n * the key by verifying a generated signature.\n * \n * @param   {Key}     ck\n * @returns {Boolean}\n */\nasync function Correct(ck) {\n\tif (typeof ck !== \"object\") {\n\t\tconsole.error(\"Correct: CozeKey must be passed in as an object.\");\n\t\treturn false;\n\t}\n\n\tif (isEmpty(ck.alg)) {\n\t\tconsole.error(\"Correct: Alg must be set\");\n\t\treturn false;\n\t}\n\n\tlet p = Alg.Params(ck.alg);\n\n\tlet isTmbEmpty = isEmpty(ck.tmb);\n\tlet isXEmpty = isEmpty(ck.x);\n\tlet isDEmpty = isEmpty(ck.d);\n\n\tif (isTmbEmpty && isXEmpty && isDEmpty) {\n\t\tconsole.error(\"Correct: At least one of [x, tmb, d] must be set\");\n\t\treturn false;\n\t}\n\n\t// tmb only key\n\tif (isXEmpty && isDEmpty) {\n\t\tif (isTmbEmpty || ck.tmb.length !== p.HashSizeB64) {\n\t\t\tconsole.error(\"Correct: Incorrect `tmb` size: \", ck.tmb.length);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// d is not set\n\tif (!isXEmpty && ck.x.length !== p.XSizeB64) {\n\t\tconsole.error(\"Correct: Incorrect x size: \", ck.x.length);\n\t\treturn false;\n\t}\n\n\t// We currently do not support recalculating `x`, as subtle does not provide\n\t// the necessary API for computing the points from the private component.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle\n\t//\n\t// See RecalcX docs below\n\t//\n\t// If d and (x and/or tmb) is given, recompute from d and compare:\n\t// let x = RecalcX(ck);\n\n\t// If tmb is set, recompute and compare.\n\tif (!isTmbEmpty && !isXEmpty) {\n\t\tlet t = await Thumbprint(ck);\n\t\tif (ck.tmb !== t) {\n\t\t\tconsole.error(\"Correct: Incorrect given `tmb`: \", ck.tmb);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// // Sanity check - No keys from the future allowed.\n\t// if (ck.iat > Math.round((Date.now() / 1000))) {\n\t// \tconsole.error(\"Correct: cannot have iat greater than present time\");\n\t// }\n\n\n\t// If private key, validate by signing and verifying.\n\t// `x` must also be populated, for cryptokey, since we do not have RecalcX().\n\tif (!isDEmpty && !isXEmpty) {\n\t\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(ck);\n\t\tlet mldBuffer = await Coze.SToArrayBuffer(\"Test Signing\")\n\t\tlet sig = await CTK.CryptoKey.SignBuffer(cryptoKey, mldBuffer);\n\t\tlet pubKey = await CTK.CryptoKey.FromCozeKey(ck, true);\n\t\tlet result = await CTK.CryptoKey.VerifyArrayBuffer(ck.alg, pubKey, mldBuffer, sig);\n\n\t\tif (!result) {\n\t\t\tconsole.error(\"Correct: private key invalid.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n\n// TODO Support RecalcX if crypto.subtle provides necessary API for computing\n// https://stackoverflow.com/questions/72151096/how-to-derive-public-key-from-private-key-using-webcryptoapi/72153942#72153942\n//\n// scalar/jacobian/affinity from private component.\n// Alternatively, use noble.\n// function RecalcX(ck) {\n// \tlet x;\n// \tswitch (ck.alg) {\n// \t\tcase \"ES256\":\n// \t\tcase \"ES384\":\n// \t\tcase \"ES512\":\n// \t\t\tbreak;\n// \t\tdefault:\n// \t\t\tx = null;\n// \t}\n\n// \treturn x;\n// }\n\n\n/**\n * Revoke generates a self revoke message and sets the input key as revoked.\n * 'rvk' will be set on given cozeKey.\n * \n * @param   {Key}       cozeKey  Private Coze key.\n * @param   {String}    [msg]    Optional, human readable non programmatic reason for revoking the key.\n * @returns {Coze}               Signed revoke Coze.\n * @throws  {Error}              Fails if cryptoKeyPrivate is nil or invalid.\n */\nasync function Revoke(cozeKey, msg) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"CozeKey.Revoke: Private key not set.  Cannot sign message\");\n\t}\n\n\tvar coze = {};\n\tcoze.pay = {};\n\tif (!isEmpty(msg)) { // Optional revoke message. \n\t\tcoze.pay.msg = msg;\n\t}\n\tcoze.pay.rvk = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\t// SignCoze does not allow revoked keys to sign messages.  Temporarily remove\n\t// key.revoke and then set back afterward, otherwise set key with new revoke. \n\tlet prevRvk = cozeKey.rvk;\n\tdelete cozeKey.rvk;\n\tcoze = await Coze.Sign(coze, cozeKey);\n\tif (prevRvk !== undefined) {\n\t\tcozeKey.rvk = prevRvk;\n\t} else {\n\t\tcozeKey.rvk = coze.pay.rvk;\n\t}\n\n\treturn coze\n};\n\n/**\n * IsRevoked returns true if a key or a coze is marked as revoked. `rvk` should\n * be an integer Unix timestamp, however this function also checks for the\n * string \"true\" as well as the bool `true`.\n *\n * Messages self-revoking keys must have `rvk` with an integer value greater\n * than 0.  \n *\n * @param   {Key|Coze}       cozeKey  Coze key or coze object.\n * @param   {String}         [msg]    Optional reason for revoking the key.\n * @returns {Boolean}\n */\nfunction IsRevoked(cozeKey) {\n\tif (isEmpty(cozeKey.rvk) || !(parseInt(cozeKey.rvk) > 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as Can from './canon.js'; // import as \"Can\" since func \"Canon\" will conflict in `coze.join.js`.\nimport * as Enum from './alg.js';\nimport * as CZK from './key.js';\nimport * as CTK from './cryptokey.js';\n\nexport {\n\tSign,\n\tSignPay,\n\tSignCozeRaw,\n\tVerify,\n\tVerifyPay,\n\tMeta,\n\n\t// Base conversion\n\tSToArrayBuffer,\n\tB64uToArrayBuffer,\n\tB64ToUint8Array,\n\tArrayBufferTo64ut,\n\n\t// Helpers\n\tisEmpty,\n\n\tPayCanon,\n}\n\n/**\n * @typedef {import('./typedefs.js').Key}            Key\n * @typedef {import('./typedefs.js').Alg}            Alg\n * @typedef {import('./typedefs.js').Pay}            Pay\n * @typedef {import('./typedefs.js').Coze}           Coze\n * @typedef {import('./typedefs.js').Sig}            Sig\n * @typedef {import('./typedefs.js').Canon}          Canon\n * @typedef {import('./typedefs.js').Meta}           Meta\n * @typedef {import('./typedefs.js').VerifiedArray}  VerifiedArray\n */\n\n// PayCanon is the standard coze.pay fields.\nconst PayCanon = [\"alg\", \"iat\", \"tmb\", \"typ\"];\n\n\n/**\n * SignCoze signs in place coze.pay.  It populates/replaces alg and tmb using\n * the given private Coze key and populates/updates iat. Returns the same, but\n * updated, coze.  The optional canon is used to canonicalize pay before\n * signing.  If needing a coze without alg, tmb, or iat, use SignCozeRaw.  \n *\n * SignCoze, SignCozeRaw, and VerifyCoze assumes that object has no duplicate\n * fields since this is disallowed in Javascript.\n * \n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}                 Coze that may have been modified from given.\n * @throws  {Error}                Fails on invalid key, parse error, mismatch fields.\n */\nasync function Sign(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCoze: Cannot sign with revoked key.\");\n\t}\n\n\tcoze.pay.alg = cozeKey.alg;\n\tcoze.pay.tmb = await CZK.Thumbprint(cozeKey);\n\tcoze.pay.iat = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\n\tcoze.sig = await SignPay(JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n\n\n/**\n * SignPay signs message with private Coze key and returns b64ut sig.\n * \n * @param   {Pay}       pay      ay. e.g. `{\"alg\"...}` May also be any message.  \n * @param   {Key}       cozeKey\n * @returns {Sig}\n * @throws  {Error}     Error, SyntaxError, DOMException, TypeError\n */\nasync function SignPay(pay, cozeKey) {\n\treturn CTK.CryptoKey.SignBufferB64(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozeKey),\n\t\tawait SToArrayBuffer(pay)\n\t);\n}\n\n\n\n/**\n * SignCozeRaw signs in place coze.pay with a private Coze key, but unlike\n * SignCoze, does not set `alg`, `tmb` or `iat`. The optional canon is used to\n * canonicalize pay before signing. \n *\n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}                 Coze with new `sig` and canonicalized `pay`.\n * @throws  {Error}                Fails on rvk or mismatch `alg` or `tmb`.\n */\nasync function SignCozeRaw(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCozeRaw: Cannot sign with revoked key.\");\n\t}\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\tcoze.sig = await SignPay(JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n\n/**\n * VerifyCoze returns a whether or not the Coze is valid. coze.sig must be set.\n * If set, pay.alg and pay.tmb must match with cozeKey.\n * @param  {Coze}     coze         Coze with signed pay. e.g. `{\"pay\":..., \"sig\":...}`\n * @param  {Key}      [cozeKey]    Public Coze key for verification.\n * @param  {Sig}      [sig]        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function Verify(coze, cozeKey) {\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"VerifyCoze: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\treturn VerifyPay(JSON.stringify(coze.pay), cozeKey, coze.sig);\n}\n\n\n/**\n * VerifyPay verifies a `pay` with `sig` and returns whether or not the message is\n * verified. Verify does no Coze checks.  If checks are needed, use\n * Verify(); \n * @param  {Pay}       pay        pay. e.g. `{\"alg\"...}`  May also be any message.  \n * @param  {Key}       cozekey    Coze key for validation.\n * @param  {Sig}       sig        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function VerifyPay(pay, cozekey, sig) {\n\treturn CTK.CryptoKey.VerifyMsg(\n\t\tcozekey.alg,\n\t\tawait CTK.CryptoKey.FromCozeKey(cozekey, true),\n\t\tpay,\n\t\tsig,\n\t);\n};\n\n\n/**\n * Meta generates coze.can, coze.cad, and if possible coze.czd. Coze.Pay must be\n * set, and either Coze.Pay.Alg or parameter alg must be set. If Coze.Sig is\n * populated, czd is set. \n *\n * Meta does no cryptographic verification.\n *\n * @param  {Coze}      coze     coze.\n * @param  {Alg}       [alg]    coze.pay.alg takes precedence.\n * @return {Meta}               Meta Coze (sets fields [can, cad, czd]).\n * @throws {Error}              Fails on JSON parse exception.\n */\nasync function Meta(coze, alg) {\n\tif (!isEmpty(coze.pay.alg)) {\n\t\tvar hashAlg = Enum.HashAlg(coze.pay.alg);\n\t} else {\n\t\thashAlg = Enum.HashAlg(alg);\n\t}\n\tcoze.can = await Can.Canon(coze.pay);\n\tcoze.cad = await Can.CanonicalHash64(coze.pay, hashAlg);\n\tif (!isEmpty(coze.sig)) {\n\t\tcoze.czd = await Can.CanonicalHash64({\n\t\t\tcad: coze.cad,\n\t\t\tsig: coze.sig\n\t\t}, hashAlg);\n\t}\n\n\treturn coze;\n}\n\n\n///////////////////////////////////\n// Base Conversion\n///////////////////////////////////\n\n/**\n * Converts a string (UTF-8) to an ArrayBuffer.\n *\n * @param  {String}        string\n * @return {ArrayBuffer}\n */\nasync function SToArrayBuffer(string) {\n\treturn new TextEncoder().encode(string).buffer; // Suppose to be always in UTF-8\n}\n\n/**\n * B64uToArrayBuffer takes a b64 (truncated or not truncated, padded or not\n * padded) UTF-8 string and decodes it to an ArrayBuffer.\n * \n * @param   {B64}          string \n * @returns {ArrayBuffer}\n */\nfunction B64uToArrayBuffer(string) {\n\treturn B64ToUint8Array(string).buffer;\n};\n\n/**\n * B64ToUint8Array takes a b64 string (truncated or not truncated, padded or not\n * padded) and decodes it back into a string.\n * \n * @param   {B64}          string \n * @returns {Uint8Array}\n */\nfunction B64ToUint8Array(string) {\n\t// Make sure that the encoding is canonical.  See issue \"Enforce Canonical\n\t// Base64 encoding\" https://github.com/Cyphrme/Coze/issues/18. Alternatively\n\t// to this method, we could write our own encoder as Mozilla suggests.\n\t// https://developer.mozilla.org/en-US/docs/Glossary/Base64#solution_1_%E2%80%93_escaping_the_string_before_encoding_it\n\tstring = string.replace(/-/g, '+').replace(/_/g, '/')\n\n\tlet reencode = btoa(atob(string)).replace(/=/g, '')\n\tif (reencode !== string) {\n\t\tthrow new Error('Non-canonical base64 string');\n\t}\n\n\t// atob doesn't care about the padding character '=', but does not like URI\n\t// encoding.  \n\treturn Uint8Array.from(atob(string), c => c.charCodeAt(0));\n};\n\n/**\n * ArrayBufferTo64ut returns a b64 string from an Array buffer.\n * \n * @param   {ArrayBuffer} buffer  Arbitrary bytes. UTF-16 is Javascript native.\n * @returns {B64}\n */\nfunction ArrayBufferTo64ut(buffer) {\n\treturn btoa(String.fromCharCode.apply(null, new Uint8Array(buffer))).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\n\n///////////////////////////////////\n// Helpers - Taken from Cyphr.me\n///////////////////////////////////\n\n/**\n * isEmpty is a helper function to determine if thing is empty. \n * \n * Objects are empty if they have no keys. (Returns len === 0 of object keys.)\n *\n * Functions are considered always not empty. \n * \n * NaN returns true.  (NaN === NaN is always false, as NaN is never equal to\n * anything. NaN is the only JavaScript value unequal to itself.)\n *\n * Don't use on HTMl elements. For HTML elements, use the !== equality check\n * (element !== null).\n *\n * Cannot use CryptoKey with this function since (len === 0) always. \n *\n * @param   {any}     thing    Thing you wish was empty.\n * @returns {Boolean}\n */\nfunction isEmpty(thing) {\n\tif (typeof thing === 'function') {\n\t\treturn false;\n\t}\n\n\tif (thing === Object(thing)) {\n\t\tif (Object.keys(thing).length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!isBool(thing)) {\n\t\treturn true;\n\t}\n\treturn false\n};\n\n/**\n * Helper function to determine boolean.  \n *\n * Javascript, instead of considering everything false except a few key words,\n * decided everything is true instead of a few key words.  Why?  Because\n * Javascript.  This function inverts that assumption, so that everything can be\n * considered false unless true. \n *\n * @param   {any}      bool   Thing that you wish was a boolean.  \n * @returns {Boolean}\n */\nfunction isBool(bool) {\n\tif (\n\t\tbool === false ||\n\t\tbool === \"false\" ||\n\t\tbool === undefined ||\n\t\tbool === \"undefined\" ||\n\t\tbool === \"\" ||\n\t\tbool === 0 ||\n\t\tbool === \"0\" ||\n\t\tbool === null ||\n\t\tbool === \"null\" ||\n\t\tbool === \"NaN\" ||\n\t\tNumber.isNaN(bool) ||\n\t\tbool === Object(bool) // isObject\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport {\n\tisEmpty,\n\tSToArrayBuffer,\n\tArrayBufferTo64ut\n} from './coze.js';\n\nexport {\n\tCanon,\n\tCanonical,\n\tCanonicalS,\n\tCanonicalHash,\n\tCanonicalHash64,\n}\n\n/**\n * @typedef {import('./typedefs.js').Hsh}     Hsh\n * @typedef {import('./typedefs.js').Dig}     Dig\n * @typedef {import('./typedefs.js').Canon}   Canon\n */\n\n/**\n * Canon returns the canon from first level object keys.\n * \n * @param   {Object} obj      Object to create the canon from.\n * @returns {Canon}\n */\nfunction Canon(obj) {\n\treturn Object.keys(obj);\n}\n\n/**\n * Canon canonicalizes the first level of \"object\" into the form of \"can\".\n *\n * Arrays must be converted to objects in order to deduplicate fields.\n * \n * @param   {Object}  object    Object to be canonicalized.\n * @param   {Canon}   [can]     Array|Object canon.\n * @returns {Object}            Canonicalized object.\n * @throws  {Error}             Fails on invalid canon.\n */\nasync function Canonical(object, can) {\n\tif (isEmpty(can)) {\n\t\treturn object;\n\t}\n\tlet obj = {};\n\tfor (const e of can) {\n\t\tobj[e] = object[e];\n\t}\n\treturn obj;\n}\n\n/**\n * CanonicalS canonicalizes obj and returns a JSON string.\n *\n * @param   {Object}   obj\n * @param   {Canon}    [canon]\n * @returns {String}\n * @throws  {Error}\n */\nasync function CanonicalS(obj, can) {\n\treturn JSON.stringify(await Canonical(obj, can));\n}\n\n/**\n * CanonicalHash puts input into canonical form and returns the array buffer of\n * the digest.\n *\n * @param   {Object}        input     Object being canonicalized.\n * @param   {Hsh}           hash      Must be SubtleCrypto.digest() compatible (i.e. 'SHA-256').\n * @param   {Canon}         [canon]   Array for canonical keys.\n * @returns {ArrayBuffer}             ArrayBuffer of the digest.\n * @throws  {Error}                   Fails if hash is not given or invalid for SubtleCrypto.digest().\n */\nasync function CanonicalHash(input, hash, can) {\n\tif (isEmpty(hash)) {\n\t\tthrow new Error(\"Hash is not given\");\n\t}\n\treturn await crypto.subtle.digest(hash, await SToArrayBuffer(await CanonicalS(input, can)));\n}\n\n/**\n * CanonicalHash64 wraps CanonicalHash to return b64ut digest. \n *\n * @param   {Object}         obj\n * @param   {Hsh}            hash\n * @param   {Canon}          [canon]\n * @returns {Dig}\n * @throws  {Error}\n */\nasync function CanonicalHash64(obj, hash, can) {\n\treturn await ArrayBufferTo64ut(await CanonicalHash(obj, hash, can));\n}", "\"use strict\";\n\nimport {\n\tisEmpty,\n\tVerify\n} from '../coze.js';\n\nexport {\n\tVerifyCozeArray\n}\n/**\n * @typedef {import('../typedefs.js').Coze}  Coze\n */\n\n/**\n * VerifiedArray - Used when verifying array of cozies.\n * \n * - VerifiedAll:     Indicates if whole array was verified. False on error or\n *                    if anything was not verified.\n * - VerifiedCount:   Number of objects verified.\n * - FailedCount:     Number of objects that failed verification.\n * - FailedCozies:    Objects that failed verification.\n * - FailedPositions: Position in input array of all failed cozies.  \n * @typedef  {Object}    VerifiedCozeArray\n * @property {Boolean}   VerifiedAll\n * @property {Number}    VerifiedCount\n * @property {Number}    FailedCount\n * @property {Coze[]}    FailedCozies\n * @property {Number[]}  FailedPositions\n */\n\n/**\n * VerifyCozeArray verifies an array of `coze`s and returns a single\n * \"VerifiedArray\" object.  If a coze has a key, it is ignored, the given\n * cozeKey is always used.  Assumes that object has no duplicate fields since\n * this is disallowed in Javascript.\n *\n * @param  {coze[]}           coze       Array of Coze objects.\n * @param  {Key}              cozeKey    Javascript object. Coze Key.\n * @return {VerifiedArray}\n * @throws {Error}\n */\nasync function VerifyCozeArray(coze, cozeKey) {\n\tif (!Array.isArray(coze)) {\n\t\treturn Verify(coze, cozeKey)\n\t}\n\n\t/** @type {VerifiedCozeArray} */\n\tvar v = {\n\t\tVerifiedAll: false,\n\t\tVerifiedCount: 0,\n\t\tFailedCount: 0,\n\t\tFailedCozies: [],\n\t\tFailedPosition:[],\n\t};\n\n\tlet i = 0;\n\tlet copy = [...coze]; // Copy so original isn't modified.\n\tfor (let c of copy) {\n\n\t\tif (!isEmpty(c.coze)) { // \"coze\" encapsulated?\n\t\t\tc = c.coze;\n\t\t}\n\n\t\tlet valid = await Verify(c, cozeKey);\n\t\tif (valid) {\n\t\t\tv.VerifiedCount++;\n\t\t} else {\n\t\t\tv.FailedCount++;\n\t\t\tv.FailedCozies.push(c);\n\t\t\tv.FailedPosition.push(i);\n\t\t}\n\t\ti++;\n\t}\n\n\tif (v.FailedCount == 0 && v.VerifiedCount > 1) {\n\t\tv.VerifiedAll = true;\n\t}\n\n\treturn v;\n};"],
  "mappings": "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",
  "names": ["Algs", "FamAlgs", "GenAlgs", "Curves", "Uses", "Params", "alg", "p", "Genus", "Family", "Use", "HashAlg", "HashSize", "XSize", "DSize", "Curve", "SigSize", "order", "halfOrder", "CurveOrder", "CurveHalfOrder", "CryptoKey", "alg", "isEmpty", "Algs", "GenAlgs", "Curve", "cozeKey", "onlyPublic", "Genus", "jwk", "Uses", "FamAlgs", "half", "XSize", "xyab", "B64ToUint8Array", "ArrayBufferTo64ut", "signOrVerify", "cryptoKey", "exported", "czk", "xui8", "yui8", "xyui8", "Thumbprint", "arrayBuffer", "sig", "HashAlg", "sigToLowSArrayBuffer", "utf8", "SToArrayBuffer", "msg", "IsSigLowS", "B64uToArrayBuffer", "crv", "Curves", "IsLowS", "s", "CurveHalfOrder", "toLowS", "CurveOrder", "SigToLowS", "ab", "lowSSigAB", "bigIntS", "sigToS", "SigSize", "arrayBufferToBigInt", "r", "bigIntNormS", "normS", "bigIntToArrayBuffer", "tmp", "buffer", "result", "i", "size", "bigInt", "view", "TmbCanon", "NewKey", "alg", "isEmpty", "Algs", "Genus", "GenAlgs", "keyPair", "CryptoKey", "k", "Thumbprint", "cozeKey", "CanonicalHash64", "HashAlg", "Valid", "privateCozeKey", "msg", "sig", "SignPay", "VerifyPay", "Correct", "ck", "p", "Params", "isTmbEmpty", "isXEmpty", "isDEmpty", "t", "cryptoKey", "mldBuffer", "SToArrayBuffer", "pubKey", "Revoke", "coze", "prevRvk", "Sign", "IsRevoked", "PayCanon", "Sign", "coze", "cozeKey", "canon", "IsRevoked", "Thumbprint", "isEmpty", "Canonical", "SignPay", "pay", "CryptoKey", "SToArrayBuffer", "SignCozeRaw", "Verify", "VerifyPay", "cozekey", "sig", "Meta", "alg", "hashAlg", "HashAlg", "Canon", "CanonicalHash64", "string", "B64uToArrayBuffer", "B64ToUint8Array", "c", "ArrayBufferTo64ut", "buffer", "thing", "isBool", "bool", "Canon", "obj", "Canonical", "object", "can", "isEmpty", "e", "CanonicalS", "CanonicalHash", "input", "hash", "SToArrayBuffer", "CanonicalHash64", "ArrayBufferTo64ut", "VerifyCozeArray", "coze", "cozeKey", "Verify", "v", "i", "copy", "c", "isEmpty"]
}
