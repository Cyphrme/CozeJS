var e={UnknownAlg:"UnknownAlg",ES224:"ES224",ES256:"ES256",ES384:"ES384",ES512:"ES512",Ed25519:"Ed25519",Ed25519ph:"Ed25519ph",Ed448:"Ed448",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512",SHA3224:"SHA3-224",SHA3256:"SHA3-256",SHA3384:"SHA3-384",SHA3512:"SHA3-512",SHAKE128:"SHAKE128",SHAKE256:"SHAKE256"},p={EC:"EC",SHA:"SHA",RSA:"RSA"},o={ECDSA:"ECDSA",EdDSA:"EdDSA",SHA2:"SHA2",SHA3:"SHA3"},u={P224:"P-224",P256:"P-256",P384:"P-384",P521:"P-521",Curve25519:"Curve25519",Curve448:"Curve448"},E={Sig:"sig",Enc:"enc",Hsh:"hsh"};function B(r){let t={};t.Name=r,t.Genus=y(r),t.Family=R(r),t.Use=O(r),t.Hash=f(r),t.HashSize=M(r),t.HashSizeB64=Math.ceil(4*t.HashSize/3);try{t.XSize=d(r),t.XSizeB64=Math.ceil(4*t.XSize/3),t.DSize=j(r),t.DSizeB64=Math.ceil(4*t.DSize/3),t.Curve=w(r),t.SigSize=V(r),t.SigSizeB64=Math.ceil(4*t.SigSize/3)}catch{}return t}function y(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:return o.ECDSA;case e.Ed25519:case e.Ed25519ph:case e.Ed448:return o.EdDSA;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:return o.SHA2;case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return o.SHA3;default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function R(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:case e.Ed25519:case e.Ed25519ph:case e.Ed448:return p.EC;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return p.SHA;default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function f(r){switch(r){case e.ES224:case e.SHA224:return e.SHA224;case e.SHA256:case e.ES256:return e.SHA256;case e.SHA384:case e.ES384:return e.SHA384;case e.SHA512:case e.ES512:case e.Ed25519:case e.Ed25519ph:return e.SHA512;case e.SHAKE128:return e.SHAKE128;case e.SHAKE256:case e.Ed448:return e.SHAKE256;case e.SHA3224:return e.SHA3224;case e.SHA3256:return e.SHA3256;case e.SHA3384:return e.SHA3384;case e.SHA3512:return e.SHA3512;default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function M(r){switch(f(r)){case e.SHA224:case e.SHA3224:return 28;case e.SHA256:case e.SHA3256:case e.SHAKE128:return 32;case e.SHA384:case e.SHA3384:return 48;case e.SHA512:case e.SHA3512:case e.SHAKE256:return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function V(r){switch(r){case e.ES224:return 56;case e.ES256:case e.Ed25519:case e.Ed25519ph:return 64;case e.ES384:return 96;case e.Ed448:return 114;case e.ES512:return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function d(r){switch(r){case e.Ed25519:case e.Ed25519ph:return 32;case e.ES224:return 56;case e.Ed448:return 57;case e.ES256:return 64;case e.ES384:return 96;case e.ES512:return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function j(r){switch(r){case e.ES224:return 28;case e.ES256:case e.Ed25519:case e.Ed25519ph:return 32;case e.ES384:return 48;case e.Ed448:return 57;case e.ES512:return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function w(r){switch(r){case e.ES224:return u.P224;case e.ES256:return u.P256;case e.ES384:return u.P384;case e.ES512:return u.P521;case e.Ed25519:case e.Ed25519ph:return u.Curve25519;case e.Ed448:return u.Curve448;default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function O(r){switch(y(r)){case o.EdDSA:case o.ECDSA:return E.Sig;case o.SHA2:case o.SHA3:return E.Hsh;default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var s={New:async function(r){switch(n(r)&&(r=e.ES256),r){case e.ES256:case e.ES384:case e.ES512:return await window.crypto.subtle.generateKey({name:o.ECDSA,namedCurve:w(r)},!0,["sign","verify"]);default:throw new Error("CryptoKey.New: Unsupported key algorithm:"+r)}},FromCozeKey:async function(r,t){if(y(r.alg)!=o.ECDSA)throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var a={};a.use=E.Sig,a.crv=w(r.alg),a.kty=p.EC;let i=d(r.alg)/2,c=await m(r.x);if(a.x=await A(c.slice(0,i)),a.y=await A(c.slice(i)),n(r.d)||t)var S="verify";else S="sign",a.d=r.d;return await crypto.subtle.importKey("jwk",a,{name:o.ECDSA,namedCurve:a.crv},!0,[S])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let t=await window.crypto.subtle.exportKey("jwk",r);var a={};a.alg=await s.algFromCrv(t.crv);let i=m(t.x),c=m(t.y);var S=new Uint8Array([...i,...c]);return a.x=A(S.buffer),t.hasOwnProperty("d")&&(a.d=t.d),a.tmb=await C(a),a},SignBuffer:async function(r,t){return await window.crypto.subtle.sign({name:o.ECDSA,hash:{name:await s.GetSignHashAlgoFromCryptoKey(r)}},r,t)},SignBufferB64:async function(r,t){return await A(await s.SignBuffer(r,t))},SignString:async function(r,t){return await s.SignBufferB64(r,await l(t))},VerifyArrayBuffer:async function(r,t,a){return await s.ToPublic(r),await window.crypto.subtle.verify({name:o.ECDSA,hash:{name:await s.GetSignHashAlgoFromCryptoKey(r)}},r,a,t)},VerifyMsg:async function(r,t,a){return s.VerifyArrayBuffer(r,await l(t),await D(a))},GetSignHashAlgoFromCryptoKey:async function(r){return f(await s.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case u.P224:var t=e.ES224;break;case u.P256:t=e.ES256;break;case u.P384:t=e.ES384;break;case u.P521:t=e.ES512;break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return t}};var I=["alg","x"];async function Y(r){if(n(r)&&(r=e.ES256),y(r)==o.ECDSA)var t=await s.New(r);else throw new Error("Coze.NewKey: only ECDSA algs are currently supported.");let a=await s.ToCozeKey(t.privateKey);return a.iat=Math.floor(Date.now()/1e3),a.tmb=await C(a),a.kid="My Cyphr.me Key.",a}async function C(r){if(n(r.alg)||n(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return g(r,await f(r.alg),I)}async function q(r){if(n(r.d))return console.error("Coze key missing `d`"),!1;try{let t="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",a=await h(t,r);return K(t,r,a)}catch{return!1}}async function L(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(n(r.alg))return console.error("Correct: Alg must be set"),!1;let t=B(r.alg),a=n(r.tmb),i=n(r.x),c=n(r.d);if(a&&i&&c)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(i&&c)return a||r.tmb.length!==t.HashSizeB64?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!i&&r.x.length!==t.XSizeB64)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!a&&!i){let S=await C(r);if(r.tmb!==S)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!c&&!i){let S=await s.FromCozeKey(r),T=await l("Test Signing"),U=await s.SignBuffer(S,T),N=await s.FromCozeKey(r,!0);if(!await s.VerifyArrayBuffer(N,T,U))return console.error("Correct: private key invalid."),!1}return!0}async function $(r,t){if(n(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var a={};a.pay={},n(t)||(a.pay.msg=t),a.pay.rvk=Math.round(Date.now()/1e3);let i=r.rvk;return delete r.rvk,a=await P(a,r),i!==void 0?r.rvk=i:r.rvk=a.pay.rvk,a}function b(r){return!(n(r.rvk)||!(parseInt(r.rvk)>0))}var rr=["alg","iat","tmb","typ"];async function h(r,t){return s.SignBufferB64(await s.FromCozeKey(t),await l(r))}async function P(r,t,a){if(b(t))throw new Error("SignCoze: Cannot sign with revoked key.");return r.pay.alg=t.alg,r.pay.tmb=await C(t),r.pay.iat=Math.round(Date.now()/1e3),n(a)||(r.pay=await H(r.pay,a)),r.sig=await h(JSON.stringify(r.pay),t),r}async function er(r,t,a){if(b(t))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return n(a)||(r.pay=await H(r.pay,a)),r.sig=await h(JSON.stringify(r.pay),t),r}async function K(r,t,a){return s.VerifyMsg(await s.FromCozeKey(t,!0),r,a)}async function tr(r,t){if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("VerifyCoze: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.");return K(JSON.stringify(r.pay),t,r.sig)}async function ar(r,t){if(n(r.pay.alg))a=f(t);else var a=f(r.pay.alg);return r.can=await G(r.pay),r.cad=await g(r.pay,a),n(r.sig)||(r.czd=await g({cad:r.cad,sig:r.sig},a)),r}async function l(r){return new TextEncoder().encode(r).buffer}function D(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0)).buffer}function m(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0))}function A(r){return btoa(String.fromCharCode.apply(null,new Uint8Array(r))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function n(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!X(r)}function X(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function G(r){return Object.keys(r)}async function H(r,t){if(n(t))return r;let a={};for(let i of t)a[i]=r[i];return a}async function Z(r,t){return JSON.stringify(await H(r,t))}async function _(r,t,a){if(n(t))throw new Error("Hash is not given");return await crypto.subtle.digest(t,await l(await Z(r,a)))}async function g(r,t,a){return await A(await _(r,t,a))}export{e as Algs,A as ArrayBufferTo64ut,D as B64uToArrayBuffer,m as B64utToUint8Array,G as Canon,H as Canonical,_ as CanonicalHash,g as CanonicalHash64,Z as CanonicalS,L as Correct,s as CryptoKey,w as Curve,u as Curves,j as DSize,p as FamAlgs,R as Family,o as GenAlgs,y as Genus,f as HashAlg,M as HashSize,b as IsRevoked,ar as Meta,Y as NewKey,B as Params,rr as PayCanon,$ as Revoke,l as SToArrayBuffer,V as SigSize,h as Sign,P as SignCoze,er as SignCozeRaw,C as Thumbprint,I as TmbCanon,O as Use,E as Uses,q as Valid,K as Verify,tr as VerifyCoze,d as XSize,n as isEmpty};
//# sourceMappingURL=coze.min.js.map
