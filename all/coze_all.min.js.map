{
  "version": 3,
  "sources": ["../alg.js", "../cryptokey.js", "../key.js", "../coze.js", "../canon.js", "../standard/coze_array.js"],
  "sourcesContent": ["\"use strict\";\n\n// For more documentation and notes, see the main Coze README.\n\nexport {\n\tAlgs,\n\tFamAlgs,\n\tGenAlgs,\n\tCurves,\n\tUses,\n\n\tParams,\n\tCurve,\n\tFamily,\n\tGenus,\n\tHashAlg,\n\tHashSize,\n\tSigSize,\n\tXSize,\n\tDSize,\n\tUse,\n}\n\n/**\n * @typedef {import('./typedefs.js').Params}  Params\n * @typedef {import('./typedefs.js').Alg}     Alg\n * @typedef {import('./typedefs.js').Gen}     Gen\n * @typedef {import('./typedefs.js').Fam}     Fam\n * @typedef {import('./typedefs.js').Hsh}     Hsh\n * @typedef {import('./typedefs.js').Crv}     Crv\n * @typedef {import('./typedefs.js').Use}     Use\n */\n\n/**\n * Algs holds all of the supported Coze algorithms.\n */\nconst Algs = {\n\tUnknownAlg: \"UnknownAlg\",\n\tES224: \"ES224\",\n\tES256: \"ES256\",\n\tES384: \"ES384\",\n\tES512: \"ES512\",\n\tEd25519: \"Ed25519\",\n\tEd25519ph: \"Ed25519ph\",\n\tEd448: \"Ed448\",\n\tSHA224: \"SHA-224\",\n\tSHA256: \"SHA-256\",\n\tSHA384: \"SHA-384\",\n\tSHA512: \"SHA-512\",\n\tSHA3224: \"SHA3-224\",\n\tSHA3256: \"SHA3-256\",\n\tSHA3384: \"SHA3-384\",\n\tSHA3512: \"SHA3-512\",\n\tSHAKE128: \"SHAKE128\",\n\tSHAKE256: \"SHAKE256\",\n};\n\n/**\n * FamAlgs holds all of the supported Coze Family algorithms.\n */\nconst FamAlgs = {\n\tEC: \"EC\",\n\tSHA: \"SHA\",\n\tRSA: \"RSA\",\n};\n\n/**\n * GenAlgs holds all of the supported Coze Genus algorithms.\n */\nconst GenAlgs = {\n\tECDSA: \"ECDSA\",\n\tEdDSA: \"EdDSA\",\n\tSHA2: \"SHA2\",\n\tSHA3: \"SHA3\",\n};\n\n/**\n * Curves holds all of the supported Coze curve algorithms.\n */\nconst Curves = {\n\tP224: \"P-224\",\n\tP256: \"P-256\",\n\tP384: \"P-384\",\n\tP521: \"P-521\",\n\tCurve25519: \"Curve25519\",\n\tCurve448: \"Curve448\",\n};\n\n/**\n * Uses holds all of the supported Coze uses.\n */\nconst Uses = {\n\tSig: \"sig\",\n\tEnc: \"enc\",\n\tHsh: \"hsh\",\n};\n\n/**\n * Param reports all relevant values for a given `alg`.\n * Returns Params object with populated values for relevant fields.\n * All functions defined in this file will throw an error when given an\n * unsupported algorithm.\n * \n * @param   {Alg}      alg\n * @returns {Params}\n * @throws  {Error}\n */\nfunction Params(alg) {\n\t/** @type {Params} */\n\tlet p = {};\n\tp.Name = alg;\n\tp.Genus = Genus(alg);\n\tp.Family = Family(alg);\n\tp.Use = Use(alg);\n\tp.Hash = HashAlg(alg);\n\tp.HashSize = HashSize(alg);\n\tp.HashSizeB64 = Math.ceil(4 * p.HashSize / 3);\n\n\t// SigAlg parameters\n\ttry {\n\t\tp.XSize = XSize(alg);\n\t\tp.XSizeB64 = Math.ceil(4 * p.XSize / 3);\n\t\tp.DSize = DSize(alg);\n\t\tp.DSizeB64 = Math.ceil(4 * p.DSize / 3);\n\t\tp.Curve = Curve(alg);\n\t\tp.SigSize = SigSize(alg);\n\t\tp.SigSizeB64 = Math.ceil(4 * p.SigSize / 3);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\n\treturn p;\n}\n\n/**\n * Genus returns the genus for an alg (ECDSA, EdDSA, SHA-2, SHA-3).\n * See notes on the Go implementation of Coze for more on genus.\n *\n * @param   {Alg}   alg\n * @returns {Gen}\n * @throws  {Error}\n */\nfunction Genus(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.ES256:\n\t\tcase Algs.ES384:\n\t\tcase Algs.ES512:\n\t\t\treturn GenAlgs.ECDSA;\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\tcase Algs.Ed448:\n\t\t\treturn GenAlgs.EdDSA;\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA512:\n\t\t\treturn GenAlgs.SHA2;\n\t\tcase Algs.SHA3224:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHA3384:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE128:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn GenAlgs.SHA3;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Genus: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Family returns the family for an alg (EC and SHA).\n * See notes on the Go implementation of Coze for more on family.\n *\n * @param   {Alg}     alg\n * @returns {Fam}\n * @throws  {Error}\n */\nfunction Family(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.ES256:\n\t\tcase Algs.ES384:\n\t\tcase Algs.ES512:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\tcase Algs.Ed448:\n\t\t\treturn FamAlgs.EC;\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA512:\n\t\tcase Algs.SHA3224:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHA3384:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE128:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn FamAlgs.SHA\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Family:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Hash returns the hashing algorithm for the given algorithm.  A hash alg can\n * return itself.\n * See notes on the Go implementation of Coze for more.\n *\n * @param   {Alg}   alg \n * @returns {Hsh}\n * @throws  {Error}\n */\nfunction HashAlg(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.SHA224:\n\t\t\treturn Algs.SHA224;\n\t\tcase Algs.SHA256:\n\t\tcase Algs.ES256:\n\t\t\treturn Algs.SHA256;\n\t\tcase Algs.SHA384:\n\t\tcase Algs.ES384:\n\t\t\treturn Algs.SHA384;\n\t\tcase Algs.SHA512:\n\t\tcase Algs.ES512: // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn Algs.SHA512;\n\t\tcase Algs.SHAKE128:\n\t\t\treturn Algs.SHAKE128\n\t\tcase Algs.SHAKE256:\n\t\tcase Algs.Ed448:\n\t\t\treturn Algs.SHAKE256\n\t\tcase Algs.SHA3224:\n\t\t\treturn Algs.SHA3224\n\t\tcase Algs.SHA3256:\n\t\t\treturn Algs.SHA3256\n\t\tcase Algs.SHA3384:\n\t\t\treturn Algs.SHA3384\n\t\tcase Algs.SHA3512:\n\t\t\treturn Algs.SHA3512\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashAlg:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * HashSize returns the hashing algorithm size for the given algorithm in bytes\n * E.g. 32.\n * \n * SHAKE128 has 128 bits of pre-collision resistance and a capacity of 256,\n * although it has arbitrary output size. SHAKE256 has 256 bits of pre-collision\n * resistance and a capacity of 512, although it has arbitrary output size.\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction HashSize(alg) {\n\tswitch (HashAlg(alg)) {\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA3224:\n\t\t\treturn 28;\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHAKE128:\n\t\t\treturn 32;\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA3384:\n\t\t\treturn 48;\n\t\tcase Algs.SHA512:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn 64;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * SigSize returns the signature size for the given algorithm in bytes.\n * \n * Curve P-521 uses 521 bits.  This is then padded up the the nearest byte (528)\n * for R and S. 132 = (528*2)/8\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}      alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction SigSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn 56\n\t\tcase Algs.ES256:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 64\n\t\tcase Algs.ES384:\n\t\t\treturn 96\n\t\tcase Algs.Ed448:\n\t\t\treturn 114\n\t\tcase Algs.ES512:\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.SigSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * XSize returns the signature size for the given signature algorithm in bytes.\n * E.g. 64.\n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528) for R and S. (528*2)/8 = 132.\n *\n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction XSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 32\n\t\tcase Algs.ES224:\n\t\t\treturn 56\n\t\tcase Algs.Ed448:\n\t\t\treturn 57\n\t\tcase Algs.ES256:\n\t\t\treturn 64\n\t\tcase Algs.ES384:\n\t\t\treturn 96\n\t\tcase Algs.ES512:\n\t\t\treturn 132 // X and Y are 66 bytes (Rounded up for P521)\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.XSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * DSize returns the signature size for the given signature algorithm in bytes.\n * E.g. 64.\n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528). (528)/8 = 66.\n *\n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction DSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn 28\n\t\tcase Algs.ES256:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 32\n\t\tcase Algs.ES384:\n\t\t\treturn 48\n\t\tcase Algs.Ed448:\n\t\t\treturn 57\n\t\tcase Algs.ES512:\n\t\t\treturn 66\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.DSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Curve returns the curve algorithm for the given signature algorithm.\n * E.g. \"P-256\".\n * \n * See notes on the Go implementation of Coze for more.\n *\n * @param   {Alg}    alg \n * @returns {Crv}\n * @throws  {Error}\n */\nfunction Curve(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn Curves.P224;\n\t\tcase Algs.ES256:\n\t\t\treturn Curves.P256;\n\t\tcase Algs.ES384:\n\t\t\treturn Curves.P384;\n\t\tcase Algs.ES512: // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\t\treturn Curves.P521;\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn Curves.Curve25519;\n\t\tcase Algs.Ed448:\n\t\t\treturn Curves.Curve448;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Curve: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Use returns the use for the given algorithm.  Only \"sig\", \"enc\", and \"dig\"\n * are currently valid.\n * Encryption (\"enc\") is currently not supported in Coze.\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg \n * @returns {Use}\n * @throws  {Error}\n */\nfunction Use(alg) {\n\tswitch (Genus(alg)) {\n\t\tcase GenAlgs.EdDSA:\n\t\tcase GenAlgs.ECDSA:\n\t\t\treturn Uses.Sig;\n\t\tcase GenAlgs.SHA2:\n\t\tcase GenAlgs.SHA3:\n\t\t\treturn Uses.Hsh;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Use: unsupported algorithm: \" + alg);\n\t}\n}", "\"use strict\";\n\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport * as CZK from './key.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\n\nexport {\n\tCryptoKey,\n};\n\n/**\n * @typedef {import('./typedefs.js').B64}      B64\n * @typedef {import('./typedefs.js').Alg}      Alg\n * @typedef {import('./typedefs.js').Sig}      Sig\n * @typedef {import('./typedefs.js').Hsh}      Hsh\n * @typedef {import('./typedefs.js').Key}      Key\n * @typedef {import('./typedefs.js').Crv}      Crv\n * @typedef {import('./typedefs.js').Msg}      Msg\n */\n\nvar CryptoKey = {\n\n\t/**\n\t * New returns a ECDSA CryptoKeyPair. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKeyPair\n\t * \n\t * @param  {Alg}           [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n\t * @return {CryptoKeyPair}\n\t * @throws {Error}         Error, SyntaxError, DOMException, TypeError\n\t */\n\tNew: async function (alg) {\n\t\tif (isEmpty(alg)) {\n\t\t\talg = Alg.Algs.ES256;\n\t\t}\n\t\t// Javascript only supports ECDSA, and doesn't support ES192 or ES224.  See\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams\n\t\tswitch (alg) {\n\t\t\tcase Alg.Algs.ES256:\n\t\t\tcase Alg.Algs.ES384:\n\t\t\tcase Alg.Algs.ES512:\n\t\t\t\treturn await window.crypto.subtle.generateKey({\n\t\t\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\t\t\tnamedCurve: Alg.Curve(alg)\n\t\t\t\t\t},\n\t\t\t\t\ttrue,\n\t\t\t\t\t[\"sign\", \"verify\"]\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.New: Unsupported key algorithm:\" + alg);\n\t\t}\n\t},\n\n\t/**\n\t * FromCozeKey takes a Coze Key and returns a Javascript CryptoKey.  Only\n\t * supports ECDSA since Crypto.subtle only supports ECDSA. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * \n\t * Throws error on invalid keys.\n\t * \n\t * @param   {Key}        cozeKey          Coze key.\n\t * @param   {Boolean}    [public=false]   Return only a public key.\n\t * @returns {CryptoKey}\n\t * @throws  {Error}                Error, SyntaxError, DOMException, TypeError\n\t */\n\tFromCozeKey: async function (cozeKey, onlyPublic) {\n\t\tif (Alg.Genus(cozeKey.alg) != Alg.GenAlgs.ECDSA) {\n\t\t\tthrow new Error(\"CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: \" + cozeKey.alg);\n\t\t}\n\n\t\t// Create a new JWK that can be used to create and \"import\" a CryptoKey\n\t\tvar jwk = {};\n\t\tjwk.use = Alg.Uses.Sig;\n\t\tjwk.crv = Alg.Curve(cozeKey.alg);\n\t\tjwk.kty = Alg.FamAlgs.EC;\n\n\t\tlet half = Alg.XSize(cozeKey.alg) / 2;\n\t\tlet xyab = await Coze.B64utToUint8Array(cozeKey.x);\n\t\tjwk.x = await Coze.ArrayBufferTo64ut(xyab.slice(0, half));\n\t\tjwk.y = await Coze.ArrayBufferTo64ut(xyab.slice(half));\n\n\t\t// Public CryptoKey \"crypto.subtle.importKey\" needs key use to be \"verify\"\n\t\t// even though this doesn't exist in JWK RFC or IANA registry. (2021/05/12)\n\t\t// Gawd help us.  Private CryptoKey needs key `use` to be \"sign\".\n\t\tif (isEmpty(cozeKey.d) || onlyPublic) {\n\t\t\tvar signOrVerify = \"verify\";\n\t\t} else {\n\t\t\tsignOrVerify = \"sign\";\n\t\t\tjwk.d = cozeKey.d;\n\t\t}\n\n\t\treturn await crypto.subtle.importKey(\n\t\t\t\"jwk\",\n\t\t\tjwk, {\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\tnamedCurve: jwk.crv,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[signOrVerify]\n\t\t);\n\t},\n\n\t/**\n\t * ToPublic accepts a Javascript CryptoKey and modifies the key to remove\n\t * any private components.\n\t *\n\t * @param   {CryptoKey} cryptoKey\n\t * @returns {void}\n\t */\n\tToPublic: async function (cryptoKey) {\n\t\tdelete cryptoKey.d; // Remove private `d` from the key.\n\t\t// Only [\"verify\"] is a valid `key_ops` value for a public CryptoKey.\n\t\t// `key_ops` must be an array.\n\t\tcryptoKey.key_ops = [\"verify\"];\n\t},\n\n\t/**\n\t * CryptoKeyToCozeKey returns a Coze Key from Javascript's \"CryptoKey\" type.\n\t * (https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) Coze keys are\n\t * similiar to JOSE JWK's but has a few significant differences.\n\t * See the Coze docs for more on these differences.\n\t * \n\t * - Coze Byte-to-string values are always b64ut, \"RFC 4648 base64 URI Safe\n\t * Truncated\".\n\t * - Coze keys also use the field `alg` to denote everything about the key:\n\t * it's use, hashing algorithm, curve, family, signature size, private\n\t * component size, public component size, etc...\n\t * - A Coze key's Thumbprint's hashing algorithm must always be in alignment\n\t * with the alg.  This is unlike JOSE which appears to use SHA-256 even for\n\t * keys that don't use that algorithm.\n\t * \n\t * This function currently only supports ECDSA (ES256. ES384, ES512) as\n\t * crypto.subtle only supports these ECDSA algorithms. From Cryptokey,\n\t * `exported` key output should is in the following form:\n\t * \n\t * {\n\t * \"crv\": \"P-256\",\n\t * \"d\": \"GwJgQIcbB29IfWO46QZwansE5XVVOg_CfafcpGk3K9I\",\n\t * \"key_ops\": [\n\t * \"sign\",\n\t * \"verify\"\n\t * ],\n\t * \"kty\": \"EC\",\n\t * \"x\": \"bMgUwXPLFR5WPERFIdUR8f6J9znFlM4fL-TaYr7YNSo\",\n\t * \"y\": \"vuU0bE-JafF1zEW_MbL-oaO0eGltDeMHIfc_bxkdCHU\",\n\t * \"use\": \"sig\"\n\t * }\n\t * \n\t * Some aspects of the Javascript exported key are in conflict with JOSE. The\n\t * `delete`s below are for reference of how out of alignment the Javascript\n\t * representation is from JOSE.  If for some reason a JOSE representation is\n\t * required, the deletes are suggested.\n\t * \n\t * `delete exported.key_ops;`\n\t * \n\t * According to RFC 7517 Section 4.3, \"use\" is mutually exclusive with\n\t * key_ops.\n\t * \n\t * `delete exported[\"ext\"];`\n\t * \n\t * `ext` is define by the Web Cryptography API and does not appear in the\n\t * core JOSE RFC's.  It stands for \"extractable\".  Since the key is already\n\t * \"extracted\" we don't care, and we're not going to burden downstream with\n\t * it.  However, this may need to be added again later if the key is further\n\t * manipulated by SubtleCrypto. \n\t * \n\t * Coze does not use \"crv\", \"kty\", or \"use\" and instead relies solely on\n\t * \"alg\". Since alg is not given, it's assumed from `crv` while `kty`is\n\t * ignored.\n\t * \n\t * Why are we exporting to JWK?\n\t * 1. There's no access to the key fields without exporting. (The\n\t * browser hides the information from Javascript.)\n\t * 2. The exporting formats are limited.  \n\t * 3. Can't export to \"raw\" because \"raw\" appears to only work on public\n\t * keys.  This may be a private key.\n\t * \n\t * @param   {CryptoKey}   cryptoKey \n\t * @returns {Key}\n\t * @throws  {Error}\n\t */\n\tToCozeKey: async function (cryptoKey) {\n\t\tlet exported = await window.crypto.subtle.exportKey(\n\t\t\t\"jwk\",\n\t\t\tcryptoKey\n\t\t);\n\n\t\tvar czk = {};\n\t\tczk.alg = await CryptoKey.algFromCrv(exported.crv);\n\t\t// Concatenate x and y, but concatenation is done at the byte level, so:\n\t\t// unencode, concatenated, and encoded. \n\t\tlet xui8 = Coze.B64utToUint8Array(exported.x);\n\t\tlet yui8 = Coze.B64utToUint8Array(exported.y);\n\t\tvar xyui8 = new Uint8Array([\n\t\t\t...xui8,\n\t\t\t...yui8,\n\t\t]);\n\t\tczk.x = Coze.ArrayBufferTo64ut(xyui8.buffer);\n\n\t\t// Only private ECDSA keys have `d`.\n\t\tif (exported.hasOwnProperty('d')) {\n\t\t\tczk.d = exported.d;\n\t\t}\n\n\t\tczk.tmb = await CZK.Thumbprint(czk);\n\t\t// console.log(\"exported: \" + JSON.stringify(exported), \"Coze Key: \" + JSON.stringify(czk)); // Debugging\n\t\treturn czk;\n\t},\n\n\t/**\n\t * Uses a Javascript `CryptoKey` to sign a array buffer.  Returns array buffer\n\t * bytes of the signature. Returns empty buffer on error.\n\t *\n\t * The signing algorithm's hashing algorithm is used for the digest of the\n\t * payload.  \n\t * \n\t * Coze uses UTF-8.\n\t *\n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n\t * \n\t * @param   {CryptoKey}      cryptoKey\n\t * @param   {ArrayBuffer}    payloadBuffer\n\t * @returns {ArrayBuffer}\n\t * @throws  {Error}\n\t */\n\tSignBuffer: async function (cryptoKey, arrayBuffer) {\n\t\treturn await window.crypto.subtle.sign({\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tarrayBuffer\n\t\t);\n\t},\n\n\t/**\n\t * SignBufferB64 signs a buffer with a CryptoKey and returns the b64ut\n\t * signature. The input is hashed before it's signed.\n\t * Coze uses UTF-8.\n\t *\n\t * @param   {CryptoKey}   cryptoKey       Private CryptoKey\n\t * @param   {ArrayBuffer} arrayBuffer     ArrayBuffer to sign.\n\t * @returns {B64}\n\t */\n\tSignBufferB64: async function (cryptoKey, arrayBuffer) {\n\t\treturn await Coze.ArrayBufferTo64ut(await CryptoKey.SignBuffer(cryptoKey, arrayBuffer));\n\t},\n\n\t/**\n\t * SignString signs a string and returns the b64ut signature.\n\t * Coze uses UTF-8.\n\t * \n\t * @param   {CryptoKey} cryptoKey      Private key used for signing.\n\t * @param   {String}    utf8           String to sign.\n\t * @returns {B64}\n\t */\n\tSignString: async function (cryptoKey, utf8) {\n\t\treturn await CryptoKey.SignBufferB64(cryptoKey, await Coze.SToArrayBuffer(utf8));\n\t},\n\n\t/**\n\t * VerifyArrayBuffer verifies an ArrayBuffer msg with an ArrayBuffer sig and\n\t * Javascript CryptoKey.\n\t * Returns whether or not message is verified by the given key and signature.\n\t * \n\t * @param   {CryptoKey}   cryptoKey           Javascript CryptoKey.\n\t * @param   {ArrayBuffer} sig                 Signature.\n\t * @param   {ArrayBuffer} msg                 Message.\n\t * @returns {Boolean}\n\t */\n\tVerifyArrayBuffer: async function (cryptoKey, msg, sig) {\n\t\t// Guarantee key is not private to appease Javascript:\n\t\tawait CryptoKey.ToPublic(cryptoKey);\n\t\treturn await window.crypto.subtle.verify({\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tsig,\n\t\t\tmsg);\n\t},\n\n\t/**\n\t * VerifyMsg uses a public key to verify a string msg with a b64ut sig.\n\t * Returns whether or not the signature is valid.\n\t * \n\t * @param   {CryptoKey}  cryptoKey         Javascript CryptoKey.\n\t * @param   {Msg}        msg               String that was signed.\n\t * @param   {Sig}        sig               B64 signature.\n\t * @returns {Boolean}\n\t */\n\tVerifyMsg: async function (cryptoKey, msg, sig) {\n\t\treturn CryptoKey.VerifyArrayBuffer(cryptoKey, await Coze.SToArrayBuffer(msg), await Coze.B64uToArrayBuffer(sig));\n\t},\n\n\t/**\n\t * GetSignHashAlgoFromCryptoKey gets the signing hashing algorithm from the\n\t * CryptoKey.\n\t * Returns the name of the hashing algorithm. E.g. \"SHA-256\".\n\t *\n\t * Javascript's CryptoKey explicitly requires a signing hashing algorithm, but\n\t * the CryptoKey itself may not explicitly contain that information. For\n\t * example, a ES256 key will have the curve (P-256) and the general key type\n\t * (ECDSA), but the hashing algo is not explicitly stated (SHA-256), nor is\n\t * the algorithm explicitly stated (ES256).\n\t *\n\t * However, for some CryptoKeys, the hashing algorithm is explicitly stated.\n\t * For example, \"RsaHashedKeyGenParams\" has the field \"hash\" which explicitly\n\t * denotes what hashing algorithm was used.  As of 2021/05/26,\n\t * \"EcKeyGenParams\" has no such field, so it must be assumed that certain\n\t * hashing algorithms are paired with certain curves.\n\t *\n\t * The purpose of this function is to return the correct hashing digest for\n\t * all CryptoKeys regardless of their form.\n\t * \n\t * @param   {CryptoKey} CryptoKey  CryptoKey Javascript object.\n\t * @returns {Hsh}\n\t * @throws  {Error}                Fails if alg is not supported.\n\t */\n\tGetSignHashAlgoFromCryptoKey: async function (cryptoKey) {\n\t\treturn Alg.HashAlg(await CryptoKey.algFromCrv(cryptoKey.algorithm.namedCurve));\n\t},\n\n\t/**\n\t * algFromCrv returns a SEAlg from the given curve.\n\t * Fails if curve is not supported.\n\t * \n\t * @param   {Crv}     src    Curve type. E.g. \"P-256\".\n\t * @returns {Alg}\n\t * @throws  {Error}\n\t */\n\talgFromCrv: async function (crv) {\n\t\tswitch (crv) {\n\t\t\tcase Alg.Curves.P224:\n\t\t\t\tvar alg = Alg.Algs.ES224;\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P256:\n\t\t\t\talg = Alg.Algs.ES256\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P384:\n\t\t\t\talg = Alg.Algs.ES384;\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P521: // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\t\talg = Alg.Algs.ES512;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\t\treturn alg;\n\t}\n}; // End CryptoKey", "\"use strict\";\n\nimport * as CTK from './cryptokey.js';\nimport * as Can from './canon.js';\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tNewKey,\n\tCorrect,\n\tValid,\n\tThumbprint,\n\tRevoke,\n\tIsRevoked,\n\n\t// RecalcX,\n\n\tTmbCanon,\n}\n\n/**\n * @typedef {import('./typedefs.js').B64}  B64\n * @typedef {import('./typedefs.js').Alg}  Alg\n * @typedef {import('./typedefs.js').Use}  Use\n * @typedef {import('./typedefs.js').Sig}  Sig\n * @typedef {import('./typedefs.js').Key}  Key\n * @typedef {import('./typedefs.js').Time} Time\n */\n\n// Coze key Thumbprint Canons.\nconst TmbCanon = [\"alg\", \"x\"];\n\n/**\n * NewKey returns a new Coze key.\n * If no alg is given, the returned key will be an 'ES256' key.\n * \n * @param   {Alg}     [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n * @returns {Key}\n */\nasync function NewKey(alg) {\n\tif (isEmpty(alg)) {\n\t\talg = Alg.Algs.ES256;\n\t}\n\tif (Alg.Genus(alg) == Alg.GenAlgs.ECDSA) {\n\t\tvar keyPair = await CTK.CryptoKey.New(alg);\n\t} else {\n\t\tthrow new Error(\"Coze.NewKey: only ECDSA algs are currently supported.\");\n\t}\n\n\tlet k = await CTK.CryptoKey.ToCozeKey(keyPair.privateKey);\n\tk.iat = Math.floor(Date.now() / 1000); // To get Unix from js, divide by 1000.\n\tk.tmb = await Thumbprint(k);\n\tk.kid = \"My Cyphr.me Key.\";\n\n\treturn k;\n}\n\n/**\n * Thumbprint generates and returns a B64 Coze key thumbprint.\n * Fails on empty 'alg' or 'x'.\n *\n * @param   {Key} cozeKey\n * @returns {B64}\n * @throws  {Error}\n */\nasync function Thumbprint(cozeKey) {\n\tif (isEmpty(cozeKey.alg) || isEmpty(cozeKey.x)) {\n\t\tthrow new Error(\"Coze.Thumbprint: alg or x is empty.\");\n\t}\n\treturn Can.CanonicalHash64(cozeKey, await Alg.HashAlg(cozeKey.alg), TmbCanon);\n};\n\n/**\n * Valid validates a private Coze key.  See notes on `Correct`.\n * If the key is invalid, Valid may log an error.\n * Returns whether or not the given key is valid.\n *\n * @param   {Key}      privateCozeKey  Private Coze key.\n * @returns {Boolean}\n */\nasync function Valid(privateCozeKey) {\n\tif (isEmpty(privateCozeKey.d)) {\n\t\tconsole.error(\"Coze key missing `d`\");\n\t\treturn false;\n\t}\n\ttry {\n\t\tlet msg = `7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q`;\n\t\tlet sig = await Coze.Sign(msg, privateCozeKey);\n\t\treturn Coze.Verify(msg, privateCozeKey, sig);\n\t} catch (e) {\n\t\t// Don't throw error, but still log it for debugging.\n\t\tconsole.error(\"Valid: \" + e);\n\t\treturn false;\n\t}\n}\n\n/**\n * Correct checks for the correct construction of a Coze key, but may return\n * true on cryptographically invalid public keys.  Key must have `alg` and at\n * least one of `tmb`, `x`, and `d`. Using input information, if it is possible\n * to definitively know the given key is incorrect, Correct returns false, but\n * if it's plausible it's correct, Correct returns true. Correct answers the\n * question: \"Is the given Coze key reasonable using the information provided?\".\n * Correct is useful for sanity checking public keys without signed messages,\n * sanity checking `tmb` only keys, and validating private keys. Use function\n * \"Verify\" instead for verifying public keys when a signed message is\n * available. Correct is considered an advanced function. Please understand it\n * thoroughly before use.\n * \n * Correct:\n * \n * 1. Checks the length of `x` and/or `tmb` against `alg`.\n * 2. If `x` and `tmb` are present, verifies correct `tmb`.\n * 3. If `d` is present, verifies correct `tmb` and `x` if present, and verifies\n * the key by verifying a generated signature.\n * \n * @param   {Key}     ck\n * @returns {Boolean}\n */\nasync function Correct(ck) {\n\tif (typeof ck !== \"object\") {\n\t\tconsole.error(\"Correct: CozeKey must be passed in as an object.\");\n\t\treturn false;\n\t}\n\n\tif (isEmpty(ck.alg)) {\n\t\tconsole.error(\"Correct: Alg must be set\");\n\t\treturn false;\n\t}\n\n\tlet p = Alg.Params(ck.alg);\n\n\tlet isTmbEmpty = isEmpty(ck.tmb);\n\tlet isXEmpty = isEmpty(ck.x);\n\tlet isDEmpty = isEmpty(ck.d);\n\n\tif (isTmbEmpty && isXEmpty && isDEmpty) {\n\t\tconsole.error(\"Correct: At least one of [x, tmb, d] must be set\");\n\t\treturn false;\n\t}\n\n\t// tmb only key\n\tif (isXEmpty && isDEmpty) {\n\t\tif (isTmbEmpty || ck.tmb.length !== p.HashSizeB64) {\n\t\t\tconsole.error(\"Correct: Incorrect `tmb` size: \", ck.tmb.length);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// d is not set\n\tif (!isXEmpty && ck.x.length !== p.XSizeB64) {\n\t\tconsole.error(\"Correct: Incorrect x size: \", ck.x.length);\n\t\treturn false;\n\t}\n\n\t// We currently do not support recalculating `x`, as subtle does not provide\n\t// the necessary API for computing the points from the private component.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle\n\t//\n\t// See RecalcX docs below\n\t//\n\t// If d and (x and/or tmb) is given, recompute from d and compare:\n\t// let x = RecalcX(ck);\n\n\t// If tmb is set, recompute and compare.\n\tif (!isTmbEmpty && !isXEmpty) {\n\t\tlet t = await Thumbprint(ck);\n\t\tif (ck.tmb !== t) {\n\t\t\tconsole.error(\"Correct: Incorrect given `tmb`: \", ck.tmb);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// // Sanity check - No keys from the future allowed.\n\t// if (ck.iat > Math.round((Date.now() / 1000))) {\n\t// \tconsole.error(\"Correct: cannot have iat greater than present time\");\n\t// }\n\n\n\t// If private key, validate by signing and verifying.\n\t// `x` must also be populated, for cryptokey, since we do not have RecalcX().\n\tif (!isDEmpty && !isXEmpty) {\n\t\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(ck);\n\t\tlet mldBuffer = await Coze.SToArrayBuffer(\"Test Signing\")\n\t\tlet sig = await CTK.CryptoKey.SignBuffer(cryptoKey, mldBuffer);\n\t\tlet pubKey = await CTK.CryptoKey.FromCozeKey(ck, true);\n\t\tlet result = await CTK.CryptoKey.VerifyArrayBuffer(pubKey, mldBuffer, sig);\n\n\t\tif (!result) {\n\t\t\tconsole.error(\"Correct: private key invalid.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n\n// TODO Support RecalcX if crypto.subtle provides necessary API for computing\n// https://stackoverflow.com/questions/72151096/how-to-derive-public-key-from-private-key-using-webcryptoapi/72153942#72153942\n//\n// scalar/jacobian/affinity from private component.\n// Alternatively, use noble.\n// function RecalcX(ck) {\n// \tlet x;\n// \tswitch (ck.alg) {\n// \t\tcase \"ES256\":\n// \t\tcase \"ES384\":\n// \t\tcase \"ES512\":\n// \t\t\tbreak;\n// \t\tdefault:\n// \t\t\tx = null;\n// \t}\n\n// \treturn x;\n// }\n\n\n/**\n * Revoke generates a self revoke message and sets the input key as revoked.\n * 'rvk' will be set on given cozeKey.\n * \n * @param   {Key}       cozeKey  Private Coze key.\n * @param   {String}    [msg]    Optional, human readable non programmatic reason for revoking the key.\n * @returns {Coze}               Signed revoke Coze.\n * @throws  {Error}              Fails if cryptoKeyPrivate is nil or invalid.\n */\nasync function Revoke(cozeKey, msg) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"CozeKey.Revoke: Private key not set.  Cannot sign message\");\n\t}\n\n\tvar coze = {};\n\tcoze.pay = {};\n\tif (!isEmpty(msg)) { // Optional revoke message. \n\t\tcoze.pay.msg = msg;\n\t}\n\tcoze.pay.rvk = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\t// SignCoze does not allow revoked keys to sign messages.  Temporarily remove\n\t// key.revoke and then set back afterward, otherwise set key with new revoke. \n\tlet prevRvk = cozeKey.rvk;\n\tdelete cozeKey.rvk;\n\tcoze = await Coze.SignCoze(coze, cozeKey);\n\tif (prevRvk !== undefined) {\n\t\tcozeKey.rvk = prevRvk;\n\t} else {\n\t\tcozeKey.rvk = coze.pay.rvk;\n\t}\n\n\treturn coze\n};\n\n/**\n * IsRevoked returns true if a key or a coze is marked as revoked. `rvk` should\n * be an integer Unix timestamp, however this function also checks for the\n * string \"true\" as well as the bool `true`.\n *\n * Messages self-revoking keys must have `rvk` with an integer value greater\n * than 0.  \n *\n * @param   {Key|Coze}       cozeKey  Coze key or coze object.\n * @param   {String}         [msg]    Optional reason for revoking the key.\n * @returns {Boolean}\n */\nfunction IsRevoked(cozeKey) {\n\tif (isEmpty(cozeKey.rvk) || !(parseInt(cozeKey.rvk) > 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as Can from './canon.js'; // import as \"Can\" since func \"Canon\" will conflict in `coze.join.js`.\nimport * as Enum from './alg.js';\nimport * as CZK from './key.js';\nimport * as CTK from './cryptokey.js';\n\nexport {\n\tPayCanon,\n\tSign,\n\tSignCoze,\n\tSignCozeRaw,\n\tVerify,\n\tVerifyCoze,\n\tMeta,\n\n\t// Base conversion\n\tSToArrayBuffer,\n\tB64uToArrayBuffer,\n\tB64utToUint8Array,\n\tArrayBufferTo64ut,\n\n\t// Helpers\n\tisEmpty,\n}\n\n/**\n * @typedef {import('./typedefs.js').Key}            Key\n * @typedef {import('./typedefs.js').Alg}            Alg\n * @typedef {import('./typedefs.js').Msg}            Msg\n * @typedef {import('./typedefs.js').Coze}           Coze\n * @typedef {import('./typedefs.js').Sig}            Sig\n * @typedef {import('./typedefs.js').Canon}          Canon\n * @typedef {import('./typedefs.js').Meta}           Meta\n * @typedef {import('./typedefs.js').VerifiedArray}  VerifiedArray\n */\n\n// PayCanon is the standard coze.pay fields.\nconst PayCanon = [\"alg\", \"iat\", \"tmb\", \"typ\"];\n\n/**\n * Sign signs message with private Coze key and returns b64ut sig.\n * \n * @param   {Msg}       message\n * @param   {Key}       cozeKey\n * @returns {Sig}\n * @throws  {Error}     Error, SyntaxError, DOMException, TypeError\n */\nasync function Sign(message, cozeKey) {\n\treturn CTK.CryptoKey.SignBufferB64(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozeKey),\n\t\tawait SToArrayBuffer(message)\n\t);\n}\n\n/**\n * SignCoze signs in place coze.pay.  It populates/replaces alg and tmb using\n * the given private Coze key and populates/updates iat. Returns the same, but\n * updated, coze.  The optional canon is used to canonicalize pay before\n * signing.  If needing a coze without alg, tmb, or iat, use SignCozeRaw.  \n *\n * SignCoze, SignCozeRaw, and VerifyCoze assumes that object has no duplicate\n * fields since this is disallowed in Javascript.\n * \n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}                 Coze that may have been modified from given.\n * @throws  {Error}                Fails on invalid key, parse error, mismatch fields.\n */\nasync function SignCoze(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCoze: Cannot sign with revoked key.\");\n\t}\n\n\tcoze.pay.alg = cozeKey.alg;\n\tcoze.pay.tmb = await CZK.Thumbprint(cozeKey);\n\tcoze.pay.iat = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\n\tcoze.sig = await Sign(JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n\n/**\n * SignCozeRaw signs in place coze.pay with a private Coze key, but unlike\n * SignCoze, does not set `alg`, `tmb` or `iat`. The optional canon is used to\n * canonicalize pay before signing. \n *\n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}                 Coze with new `sig` and canonicalized `pay`.\n * @throws  {Error}                Fails on rvk or mismatch `alg` or `tmb`.\n */\nasync function SignCozeRaw(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCozeRaw: Cannot sign with revoked key.\");\n\t}\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\tcoze.sig = await Sign(JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n/**\n * Verify verifies a `pay` with `sig` and returns whether or not the message is\n * verified. Verify does no Coze checks.  If checks are needed, use\n * VerifyCoze();\n *\n * @param  {Msg}       message    Message string. Typically is pay. e.g. `{\"alg\"...}`\n * @param  {Key}       cozekey    Coze key for validation.\n * @param  {Sig}       sig        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function Verify(message, cozekey, sig) {\n\treturn CTK.CryptoKey.VerifyMsg(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozekey, true),\n\t\tmessage,\n\t\tsig,\n\t);\n};\n\n/**\n * VerifyCoze returns a whether or not the Coze is valid. coze.sig must be set.\n * If set, pay.alg and pay.tmb must match with cozeKey.\n * \n * @param  {Coze}     coze         Coze with signed pay.\n * @param  {Key}      [cozeKey]    Public Coze key for verification.\n * @param  {Sig}      [sig]        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function VerifyCoze(coze, cozeKey) {\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"VerifyCoze: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\treturn Verify(JSON.stringify(coze.pay), cozeKey, coze.sig);\n}\n\n/**\n * Meta generates coze.can, coze.cad, and if possible coze.czd. Coze.Pay must be\n * set, and either Coze.Pay.Alg or parameter alg must be set. If Coze.Sig is\n * populated, czd is set. \n *\n * Meta does no cryptographic verification.\n *\n * @param  {Coze}      coze     coze.\n * @param  {Alg}       [alg]    coze.pay.alg takes precedence.\n * @return {Meta}               Meta Coze (sets fields [can, cad, czd]).\n * @throws {Error}              Fails on JSON parse exception.\n */\nasync function Meta(coze, alg) {\n\tif (!isEmpty(coze.pay.alg)) {\n\t\tvar hashAlg = Enum.HashAlg(coze.pay.alg);\n\t} else {\n\t\thashAlg = Enum.HashAlg(alg);\n\t}\n\tcoze.can = await Can.Canon(coze.pay);\n\tcoze.cad = await Can.CanonicalHash64(coze.pay, hashAlg);\n\tif(!isEmpty(coze.sig)){\n\t\tcoze.czd = await Can.CanonicalHash64({\n\t\t\tcad: coze.cad,\n\t\t\tsig: coze.sig\n\t\t}, hashAlg);\n\t}\n\n\treturn coze;\n}\n\n\n///////////////////////////////////\n// Base Conversion\n///////////////////////////////////\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @param  {String}        string\n * @return {ArrayBuffer}\n */\nasync function SToArrayBuffer(string) {\n\treturn new TextEncoder().encode(string).buffer; // Suppose to be always in UTF-8\n}\n\n/**\n * B64uToArrayBuffer takes a b64u (truncated or not truncated) string and\n * decodes it to an ArrayBuffer.\n * \n * @param   {B64}          string \n * @returns {ArrayBuffer}\n */\nfunction B64uToArrayBuffer(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0)).buffer;\n};\n\n/**\n * B64utToUint8Array takes a b64ut string and decodes it back into a string.\n * \n * @param   {B64}          string \n * @returns {Uint8Array}\n */\nfunction B64utToUint8Array(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));\n};\n\n/**\n * ArrayBufferTo64ut returns a b64 string from an Array buffer.\n * \n * @param   {ArrayBuffer} buffer  Arbitrary bytes. UTF-16 is Javascript native.\n * @returns {B64}\n */\nfunction ArrayBufferTo64ut(buffer) {\n\treturn btoa(String.fromCharCode.apply(null, new Uint8Array(buffer))).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\n\n///////////////////////////////////\n// Helpers - Taken from Cyphr.me\n///////////////////////////////////\n\n/**\n * isEmpty is a helper function to determine if thing is empty. \n * \n * Objects are empty if they have no keys. (Returns len === 0 of object keys.)\n *\n * Functions are considered always not empty. \n * \n * NaN returns true.  (NaN === NaN is always false, as NaN is never equal to\n * anything. NaN is the only JavaScript value unequal to itself.)\n *\n * Don't use on HTMl elements. For HTML elements, use the !== equality check\n * (element !== null).\n *\n * Cannot use CryptoKey with this function since (len === 0) always. \n *\n * @param   {any}     thing    Thing you wish was empty.\n * @returns {Boolean}\n */\nfunction isEmpty(thing) {\n\tif (typeof thing === 'function') {\n\t\treturn false;\n\t}\n\n\tif (thing === Object(thing)) {\n\t\tif (Object.keys(thing).length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!isBool(thing)) {\n\t\treturn true;\n\t}\n\treturn false\n};\n\n/**\n * Helper function to determine boolean.  \n *\n * Javascript, instead of considering everything false except a few key words,\n * decided everything is true instead of a few key words.  Why?  Because\n * Javascript.  This function inverts that assumption, so that everything can be\n * considered false unless true. \n *\n * @param   {any}      bool   Thing that you wish was a boolean.  \n * @returns {Boolean}\n */\nfunction isBool(bool) {\n\tif (\n\t\tbool === false ||\n\t\tbool === \"false\" ||\n\t\tbool === undefined ||\n\t\tbool === \"undefined\" ||\n\t\tbool === \"\" ||\n\t\tbool === 0 ||\n\t\tbool === \"0\" ||\n\t\tbool === null ||\n\t\tbool === \"null\" ||\n\t\tbool === \"NaN\" ||\n\t\tNumber.isNaN(bool) ||\n\t\tbool === Object(bool) // isObject\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport {\n\tisEmpty,\n\tSToArrayBuffer,\n\tArrayBufferTo64ut\n} from './coze.js';\n\nexport {\n\tCanon,\n\tCanonical,\n\tCanonicalS,\n\tCanonicalHash,\n\tCanonicalHash64,\n}\n\n/**\n * @typedef {import('./typedefs.js').Hsh}     Hsh\n * @typedef {import('./typedefs.js').Dig}     Dig\n * @typedef {import('./typedefs.js').Canon}   Canon\n */\n\n/**\n * Canon returns the canon from first level object keys.\n * \n * @param   {Object} obj      Object to create the canon from.\n * @returns {Canon}\n */\nfunction Canon(obj) {\n\treturn Object.keys(obj);\n}\n\n/**\n * Canon canonicalizes the first level of \"object\" into the form of \"can\".\n *\n * Arrays must be converted to objects in order to deduplicate fields.\n * \n * @param   {Object}  object    Object to be canonicalized.\n * @param   {Canon}   [can]     Array|Object canon.\n * @returns {Object}            Canonicalized object.\n * @throws  {Error}             Fails on invalid canon.\n */\nasync function Canonical(object, can) {\n\tif (isEmpty(can)) {\n\t\treturn object;\n\t}\n\tlet obj = {};\n\tfor (const e of can) {\n\t\tobj[e] = object[e];\n\t}\n\treturn obj;\n}\n\n/**\n * CanonicalS canonicalizes obj and returns a JSON string.\n *\n * @param   {Object}   obj\n * @param   {Canon}    [canon]\n * @returns {String}\n * @throws  {Error}\n */\nasync function CanonicalS(obj, can) {\n\treturn JSON.stringify(await Canonical(obj, can));\n}\n\n/**\n * CanonicalHash puts input into canonical form and returns the array buffer of\n * the digest.\n *\n * @param   {Object}        input     Object being canonicalized.\n * @param   {Hsh}           hash      Must be SubtleCrypto.digest() compatible (i.e. 'SHA-256').\n * @param   {Canon}         [canon]   Array for canonical keys.\n * @returns {ArrayBuffer}             ArrayBuffer of the digest.\n * @throws  {Error}                   Fails if hash is not given or invalid for SubtleCrypto.digest().\n */\nasync function CanonicalHash(input, hash, can) {\n\tif (isEmpty(hash)) {\n\t\tthrow new Error(\"Hash is not given\");\n\t}\n\treturn await crypto.subtle.digest(hash, await SToArrayBuffer(await CanonicalS(input, can)));\n}\n\n/**\n * CanonicalHash64 wraps CanonicalHash to return b64ut digest. \n *\n * @param   {Object}         obj\n * @param   {Hsh}            hash\n * @param   {Canon}          [canon]\n * @returns {Dig}\n * @throws  {Error}\n */\nasync function CanonicalHash64(obj, hash, can) {\n\treturn await ArrayBufferTo64ut(await CanonicalHash(obj, hash, can));\n}", "\"use strict\";\n\nimport {\n\tisEmpty,\n\tVerifyCoze\n} from '../coze.js';\n\nexport {\n\tVerifyCozeArray\n}\n/**\n * @typedef {import('../typedefs.js').Coze}  Coze\n */\n\n/**\n * VerifiedArray - Used when verifying array of cozies.\n * \n * - VerifiedAll:     Indicates if whole array was verified. False on error or\n *                    if anything was not verified.\n * - VerifiedCount:   Number of objects verified.\n * - FailedCount:     Number of objects that failed verification.\n * - FailedCozies:    Objects that failed verification.\n * - FailedPositions: Position in input array of all failed cozies.  \n * @typedef  {Object}    VerifiedCozeArray\n * @property {Boolean}   VerifiedAll\n * @property {Number}    VerifiedCount\n * @property {Number}    FailedCount\n * @property {Coze[]}    FailedCozies\n * @property {Number[]}  FailedPositions\n */\n\n/**\n * VerifyCozeArray verifies an array of `coze`s and returns a single\n * \"VerifiedArray\" object.  If a coze has a key, it is ignored, the given\n * cozeKey is always used.  Assumes that object has no duplicate fields since\n * this is disallowed in Javascript.\n *\n * @param  {coze[]}           coze       Array of Coze objects.\n * @param  {Key}              cozeKey    Javascript object. Coze Key.\n * @return {VerifiedArray}\n * @throws {Error}\n */\nasync function VerifyCozeArray(coze, cozeKey) {\n\tif (!Array.isArray(coze)) {\n\t\treturn VerifyCoze(coze, cozeKey)\n\t}\n\n\t/** @type {VerifiedCozeArray} */\n\tvar v = {\n\t\tVerifiedAll: false,\n\t\tVerifiedCount: 0,\n\t\tFailedCount: 0,\n\t\tFailedCozies: [],\n\t\tFailedPosition:[],\n\t};\n\n\tlet i = 0;\n\tlet copy = [...coze]; // Copy so original isn't modified.\n\tfor (let c of copy) {\n\n\t\tif (!isEmpty(c.coze)) { // \"coze\" encapsulated?\n\t\t\tc = c.coze;\n\t\t}\n\n\t\tlet valid = await VerifyCoze(c, cozeKey);\n\t\tif (valid) {\n\t\t\tv.VerifiedCount++;\n\t\t} else {\n\t\t\tv.FailedCount++;\n\t\t\tv.FailedCozies.push(c);\n\t\t\tv.FailedPosition.push(i);\n\t\t}\n\t\ti++;\n\t}\n\n\tif (v.FailedCount == 0 && v.VerifiedCount > 1) {\n\t\tv.VerifiedAll = true;\n\t}\n\n\treturn v;\n};"],
  "mappings": "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",
  "names": ["Algs", "FamAlgs", "GenAlgs", "Curves", "Uses", "Params", "alg", "p", "Genus", "Family", "Use", "HashAlg", "HashSize", "XSize", "DSize", "Curve", "SigSize", "CryptoKey", "alg", "isEmpty", "Algs", "GenAlgs", "Curve", "cozeKey", "onlyPublic", "Genus", "jwk", "Uses", "FamAlgs", "half", "XSize", "xyab", "B64utToUint8Array", "ArrayBufferTo64ut", "signOrVerify", "cryptoKey", "exported", "czk", "xui8", "yui8", "xyui8", "Thumbprint", "arrayBuffer", "utf8", "SToArrayBuffer", "msg", "sig", "B64uToArrayBuffer", "HashAlg", "crv", "Curves", "TmbCanon", "NewKey", "alg", "isEmpty", "Algs", "Genus", "GenAlgs", "keyPair", "CryptoKey", "k", "Thumbprint", "cozeKey", "CanonicalHash64", "HashAlg", "Valid", "privateCozeKey", "msg", "sig", "Sign", "Verify", "e", "Correct", "ck", "p", "Params", "isTmbEmpty", "isXEmpty", "isDEmpty", "t", "cryptoKey", "mldBuffer", "SToArrayBuffer", "pubKey", "Revoke", "coze", "prevRvk", "SignCoze", "IsRevoked", "PayCanon", "Sign", "message", "cozeKey", "CryptoKey", "SToArrayBuffer", "SignCoze", "coze", "canon", "IsRevoked", "Thumbprint", "isEmpty", "Canonical", "SignCozeRaw", "Verify", "cozekey", "sig", "VerifyCoze", "Meta", "alg", "hashAlg", "HashAlg", "Canon", "CanonicalHash64", "string", "B64uToArrayBuffer", "c", "B64utToUint8Array", "ArrayBufferTo64ut", "buffer", "thing", "isBool", "bool", "Canon", "obj", "Canonical", "object", "can", "isEmpty", "e", "CanonicalS", "CanonicalHash", "input", "hash", "SToArrayBuffer", "CanonicalHash64", "ArrayBufferTo64ut", "VerifyCozeArray", "coze", "cozeKey", "VerifyCoze", "v", "i", "copy", "c", "isEmpty"]
}
