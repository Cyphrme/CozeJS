var t={UnknownAlg:"UnknownAlg",ES224:"ES224",ES256:"ES256",ES384:"ES384",ES512:"ES512",Ed25519:"Ed25519",Ed25519ph:"Ed25519ph",Ed448:"Ed448",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512",SHA3224:"SHA3-224",SHA3256:"SHA3-256",SHA3384:"SHA3-384",SHA3512:"SHA3-512",SHAKE128:"SHAKE128",SHAKE256:"SHAKE256"},h={EC:"EC",SHA:"SHA",RSA:"RSA"},u={ECDSA:"ECDSA",EdDSA:"EdDSA",SHA2:"SHA2",SHA3:"SHA3"},S={P224:"P-224",P256:"P-256",P384:"P-384",P521:"P-521",Curve25519:"Curve25519",Curve448:"Curve448"},H={Sig:"sig",Enc:"enc",Hsh:"hsh"};function I(r){let e={};e.Name=r,e.Genus=F(r),e.Family=Z(r),e.Use=W(r),e.Hash=l(r),e.HashSize=_(r),e.HashSizeB64=Math.ceil(4*e.HashSize/3);try{e.XSize=T(r),e.XSizeB64=Math.ceil(4*e.XSize/3),e.DSize=J(r),e.DSizeB64=Math.ceil(4*e.DSize/3),e.Curve=v(r),e.SigSize=w(r),e.SigSizeB64=Math.ceil(4*e.SigSize/3)}catch{}return e}function F(r){switch(r){case t.ES224:case t.ES256:case t.ES384:case t.ES512:return u.ECDSA;case t.Ed25519:case t.Ed25519ph:case t.Ed448:return u.EdDSA;case t.SHA224:case t.SHA256:case t.SHA384:case t.SHA512:return u.SHA2;case t.SHA3224:case t.SHA3256:case t.SHA3384:case t.SHA3512:case t.SHAKE128:case t.SHAKE256:return u.SHA3;default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function Z(r){switch(r){case t.ES224:case t.ES256:case t.ES384:case t.ES512:case t.Ed25519:case t.Ed25519ph:case t.Ed448:return h.EC;case t.SHA224:case t.SHA256:case t.SHA384:case t.SHA512:case t.SHA3224:case t.SHA3256:case t.SHA3384:case t.SHA3512:case t.SHAKE128:case t.SHAKE256:return h.SHA;default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function l(r){switch(r){case t.ES224:case t.SHA224:return t.SHA224;case t.SHA256:case t.ES256:return t.SHA256;case t.SHA384:case t.ES384:return t.SHA384;case t.SHA512:case t.ES512:case t.Ed25519:case t.Ed25519ph:return t.SHA512;case t.SHAKE128:return t.SHAKE128;case t.SHAKE256:case t.Ed448:return t.SHAKE256;case t.SHA3224:return t.SHA3224;case t.SHA3256:return t.SHA3256;case t.SHA3384:return t.SHA3384;case t.SHA3512:return t.SHA3512;default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function _(r){switch(l(r)){case t.SHA224:case t.SHA3224:return 28;case t.SHA256:case t.SHA3256:case t.SHAKE128:return 32;case t.SHA384:case t.SHA3384:return 48;case t.SHA512:case t.SHA3512:case t.SHAKE256:return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function w(r){switch(r){case t.ES224:return 56;case t.ES256:case t.Ed25519:case t.Ed25519ph:return 64;case t.ES384:return 96;case t.Ed448:return 114;case t.ES512:return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function T(r){switch(r){case t.Ed25519:case t.Ed25519ph:return 32;case t.ES224:return 56;case t.Ed448:return 57;case t.ES256:return 64;case t.ES384:return 96;case t.ES512:return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function J(r){switch(r){case t.ES224:return 28;case t.ES256:case t.Ed25519:case t.Ed25519ph:return 32;case t.ES384:return 48;case t.Ed448:return 57;case t.ES512:return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function v(r){switch(r){default:throw new Error("alg.Curve: unsupported algorithm: "+r);case t.ES224:return S.P224;case t.ES256:return S.P256;case t.ES384:return S.P384;case t.ES512:return S.P521;case t.Ed25519:case t.Ed25519ph:return S.Curve25519;case t.Ed448:return S.Curve448}}function W(r){switch(F(r)){default:throw new Error("alg.Use: unsupported algorithm: "+r);case u.EdDSA:case u.ECDSA:return H.Sig;case u.SHA2:case u.SHA3:return H.Hsh}}var E={ES224:BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D"),ES256:BigInt("0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551"),ES384:BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973"),ES512:BigInt("0x1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409")},Q={ES224:E.ES224>>BigInt(1),ES256:E.ES256>>BigInt(1),ES384:E.ES384>>BigInt(1),ES512:E.ES512>>BigInt(1)};function z(r){switch(r){default:throw new Error("CurveOrder: unsupported curve: "+r);case"ES224":case"ES256":case"ES384":case"ES512":return E[r]}}function U(r){switch(r){default:throw new Error("CurveHalfOrder: unsupported curve: "+r);case"ES224":case"ES256":case"ES384":case"ES512":return Q[r]}}var s={New:async function(r){switch(i(r)&&(r=t.ES256),r){case t.ES256:case t.ES384:case t.ES512:return await window.crypto.subtle.generateKey({name:u.ECDSA,namedCurve:v(r)},!0,["sign","verify"]);default:throw new Error("CryptoKey.New: Unsupported key algorithm:"+r)}},FromCozeKey:async function(r,e){if(F(r.alg)!=u.ECDSA)throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var a={};a.use=H.Sig,a.crv=v(r.alg),a.kty=h.EC;let n=T(r.alg)/2,f=await p(r.x);if(a.x=await c(f.slice(0,n)),a.y=await c(f.slice(n)),i(r.d)||e)var o="verify";else o="sign",a.d=r.d;return await crypto.subtle.importKey("jwk",a,{name:u.ECDSA,namedCurve:a.crv},!0,[o])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let e=await window.crypto.subtle.exportKey("jwk",r);var a={};a.alg=await s.algFromCrv(e.crv);let n=p(e.x),f=p(e.y);var o=new Uint8Array([...n,...f]);return a.x=c(o.buffer),e.hasOwnProperty("d")&&(a.d=e.d),a.tmb=await y(a),a},SignBuffer:async function(r,e){let a=await s.algFromCrv(r.algorithm.namedCurve),n=await window.crypto.subtle.sign({name:u.ECDSA,hash:{name:l(a)}},r,e);return n=N(a,n),n},SignBufferB64:async function(r,e){return await c(await s.SignBuffer(r,e))},SignString:async function(r,e){return await s.SignBufferB64(r,await A(e))},VerifyArrayBuffer:async function(r,e,a,n){return await q(r,n)?(await s.ToPublic(e),await window.crypto.subtle.verify({name:u.ECDSA,hash:{name:await s.GetSignHashAlgoFromCryptoKey(e)}},e,n,a)):!1},VerifyMsg:async function(r,e,a,n){return s.VerifyArrayBuffer(r,e,await A(a),await D(n))},GetSignHashAlgoFromCryptoKey:async function(r){return l(await s.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case S.P224:var e=t.ES224;break;case S.P256:e=t.ES256;break;case S.P384:e=t.ES384;break;case S.P521:e=t.ES512;break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return e}};function V(r,e){if(typeof e!="bigint")throw new Error("IsLowS: s is not of type bigint");return U(r)>e}function Y(r,e){if(typeof e!="bigint")throw new Error("toLowS: s is not of type bigint");return V(r,e)?e:z(r)-e}async function or(r,e){let a=await D(e),n=await N(r,a);return c(n)}async function q(r,e){let a=await $(r,e);return V(r,a)}function $(r,e){let a=w(r)/2,n=e.slice(a);return O(n)}async function N(r,e){let a=w(r)/2,n=e.slice(0,a),f=e.slice(a),o=O(f),C=Y(r,o),d=rr(w(r)/2,C);var g=new Uint8Array(n.byteLength+d.byteLength);return g.set(new Uint8Array(n),0),g.set(new Uint8Array(d),n.byteLength),e=g.buffer,e}function O(r){let e=0n,a=new Uint8Array(r);for(let n=0;n<a.length;n++)e=(e<<8n)+BigInt(a[n]);return e}function rr(r,e){let a=new ArrayBuffer(r),n=new DataView(a);do r--,n.setUint8(r,Number(e&BigInt(255))),e>>=8n;while(r>0);return a}var er=["alg","x"];async function fr(r){if(i(r)&&(r=t.ES256),F(r)==u.ECDSA)var e=await s.New(r);else throw new Error("Coze.NewKey: only ECDSA algs are currently supported.");let a=await s.ToCozeKey(e.privateKey);return a.iat=Math.floor(Date.now()/1e3),a.tmb=await y(a),a.kid="My Cyphr.me Key.",a}async function y(r){if(i(r.alg)||i(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return m(r,await l(r.alg),er)}async function Sr(r){if(i(r.d))return console.error("Coze key missing `d`"),!1;try{let e="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",a=await B(e,r);return P(e,r,a)}catch{return!1}}async function lr(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(i(r.alg))return console.error("Correct: Alg must be set"),!1;let e=I(r.alg),a=i(r.tmb),n=i(r.x),f=i(r.d);if(a&&n&&f)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(n&&f)return a||r.tmb.length!==e.HashSizeB64?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!n&&r.x.length!==e.XSizeB64)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!a&&!n){let o=await y(r);if(r.tmb!==o)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!f&&!n){let o=await s.FromCozeKey(r),C=await A("Test Signing"),d=await s.SignBuffer(o,C),g=await s.FromCozeKey(r,!0);if(!await s.VerifyArrayBuffer(r.alg,g,C,d))return console.error("Correct: private key invalid."),!1}return!0}async function cr(r,e){if(i(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var a={};a.pay={},i(e)||(a.pay.msg=e),a.pay.rvk=Math.round(Date.now()/1e3);let n=r.rvk;return delete r.rvk,a=await j(a,r),n!==void 0?r.rvk=n:r.rvk=a.pay.rvk,a}function x(r){return!(i(r.rvk)||!(parseInt(r.rvk)>0))}var Ar=["alg","iat","tmb","typ"];async function j(r,e,a){if(x(e))throw new Error("SignCoze: Cannot sign with revoked key.");return r.pay.alg=e.alg,r.pay.tmb=await y(e),r.pay.iat=Math.round(Date.now()/1e3),i(a)||(r.pay=await b(r.pay,a)),r.sig=await B(JSON.stringify(r.pay),e),r}async function B(r,e){return s.SignBufferB64(await s.FromCozeKey(e),await A(r))}async function Fr(r,e,a){if(x(e))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!i(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!i(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return i(a)||(r.pay=await b(r.pay,a)),r.sig=await B(JSON.stringify(r.pay),e),r}async function k(r,e){if(!i(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("VerifyCoze: Coze key alg mismatch with coze.pay.alg.");if(!i(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.");return P(JSON.stringify(r.pay),e,r.sig)}async function P(r,e,a){return s.VerifyMsg(e.alg,await s.FromCozeKey(e,!0),r,a)}async function yr(r,e){if(i(r.pay.alg))a=l(e);else var a=l(r.pay.alg);return r.can=await X(r.pay),r.cad=await m(r.pay,a),i(r.sig)||(r.czd=await m({cad:r.cad,sig:r.sig},a)),r}async function A(r){return new TextEncoder().encode(r).buffer}function D(r){return p(r).buffer}function p(r){if(r=r.replace(/-/g,"+").replace(/_/g,"/"),btoa(atob(r)).replace(/=/g,"")!==r)throw new Error("Non-canonical base64 string");return Uint8Array.from(atob(r),a=>a.charCodeAt(0))}function c(r){return btoa(String.fromCharCode.apply(null,new Uint8Array(r))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function i(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!tr(r)}function tr(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function X(r){return Object.keys(r)}async function b(r,e){if(i(e))return r;let a={};for(let n of e)a[n]=r[n];return a}async function ar(r,e){return JSON.stringify(await b(r,e))}async function nr(r,e,a){if(i(e))throw new Error("Hash is not given");return await crypto.subtle.digest(e,await A(await ar(r,a)))}async function m(r,e,a){return await c(await nr(r,e,a))}async function Er(r,e){if(!Array.isArray(r))return k(r,e);var a={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCozies:[],FailedPosition:[]};let n=0,f=[...r];for(let o of f)i(o.coze)||(o=o.coze),await k(o,e)?a.VerifiedCount++:(a.FailedCount++,a.FailedCozies.push(o),a.FailedPosition.push(n)),n++;return a.FailedCount==0&&a.VerifiedCount>1&&(a.VerifiedAll=!0),a}export{t as Algs,c as ArrayBufferTo64ut,p as B64ToUint8Array,D as B64uToArrayBuffer,X as Canon,b as Canonical,nr as CanonicalHash,m as CanonicalHash64,ar as CanonicalS,lr as Correct,s as CryptoKey,v as Curve,U as CurveHalfOrder,z as CurveOrder,S as Curves,J as DSize,h as FamAlgs,Z as Family,u as GenAlgs,F as Genus,l as HashAlg,_ as HashSize,x as IsRevoked,q as IsSigLowS,yr as Meta,fr as NewKey,I as Params,Ar as PayCanon,cr as Revoke,A as SToArrayBuffer,w as SigSize,or as SigToLowS,j as Sign,Fr as SignCozeRaw,B as SignPay,y as Thumbprint,er as TmbCanon,W as Use,H as Uses,Sr as Valid,k as Verify,Er as VerifyCozeArray,P as VerifyPay,T as XSize,i as isEmpty};
//# sourceMappingURL=coze_all.min.js.map
