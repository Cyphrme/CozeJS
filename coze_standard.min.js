async function h(r,t){if(n(t))return r;let a={};for(let f of t)a[f]=r[f];return a}async function D(r,t){return JSON.stringify(await h(r,t))}async function x(r,t,a){if(n(t))throw new Error("Hash is not given");return await crypto.subtle.digest(t,await l(await D(r,a)))}async function C(r,t,a){return await c(await x(r,t,a))}var e={UnknownAlg:"UnknownAlg",ES224:"ES224",ES256:"ES256",ES384:"ES384",ES512:"ES512",Ed25519:"Ed25519",Ed25519ph:"Ed25519ph",Ed448:"Ed448",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512",SHA3224:"SHA3-224",SHA3256:"SHA3-256",SHA3384:"SHA3-384",SHA3512:"SHA3-512",SHAKE128:"SHAKE128",SHAKE256:"SHAKE256"},H={EC:"EC",SHA:"SHA",RSA:"RSA"},o={ECDSA:"ECDSA",EdDSA:"EdDSA",SHA2:"SHA2",SHA3:"SHA3"},s={P224:"P-224",P256:"P-256",P384:"P-384",P521:"P-521",Curve25519:"Curve25519",Curve448:"Curve448"},v={Sig:"sig",Enc:"enc",Hsh:"hsh"};function g(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:return o.ECDSA;case e.Ed25519:case e.Ed25519ph:case e.Ed448:return o.EdDSA;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:return o.SHA2;case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return o.SHA3;default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function A(r){switch(r){case e.ES224:case e.SHA224:return e.SHA224;case e.SHA256:case e.ES256:return e.SHA256;case e.SHA384:case e.ES384:return e.SHA384;case e.SHA512:case e.ES512:case e.Ed25519:case e.Ed25519ph:return e.SHA512;case e.SHAKE128:return e.SHAKE128;case e.SHAKE256:case e.Ed448:return e.SHAKE256;case e.SHA3224:return e.SHA3224;case e.SHA3256:return e.SHA3256;case e.SHA3384:return e.SHA3384;case e.SHA3512:return e.SHA3512;default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function b(r){switch(r){case e.Ed25519:case e.Ed25519ph:return 32;case e.ES224:return 56;case e.Ed448:return 57;case e.ES256:return 64;case e.ES384:return 96;case e.ES512:return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function p(r){switch(r){case e.ES224:return s.P224;case e.ES256:return s.P256;case e.ES384:return s.P384;case e.ES512:return s.P521;case e.Ed25519:case e.Ed25519ph:return s.Curve25519;case e.Ed448:return s.Curve448;default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}var i={New:async function(r){switch(n(r)&&(r=e.ES256),r){case e.ES256:case e.ES384:case e.ES512:return await window.crypto.subtle.generateKey({name:o.ECDSA,namedCurve:p(r)},!0,["sign","verify"]);default:throw new Error("CryptoKey.New: Unsupported key algorithm:"+r)}},FromCozeKey:async function(r,t){if(g(r.alg)!=o.ECDSA)throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var a={};a.use=v.Sig,a.crv=p(r.alg),a.kty=H.EC;let f=b(r.alg)/2,u=await y(r.x);if(a.x=await c(u.slice(0,f)),a.y=await c(u.slice(f)),n(r.d)||t)var S="verify";else S="sign",a.d=r.d;return await crypto.subtle.importKey("jwk",a,{name:o.ECDSA,namedCurve:a.crv},!0,[S])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let t=await window.crypto.subtle.exportKey("jwk",r);var a={};a.alg=await i.algFromCrv(t.crv);let f=y(t.x),u=y(t.y);var S=new Uint8Array([...f,...u]);return a.x=c(S.buffer),t.hasOwnProperty("d")&&(a.d=t.d),a.tmb=await E(a),a},SignBuffer:async function(r,t){return await window.crypto.subtle.sign({name:o.ECDSA,hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,t)},SignBufferB64:async function(r,t){return await c(await i.SignBuffer(r,t))},SignString:async function(r,t){return await i.SignBufferB64(r,await l(t))},VerifyArrayBuffer:async function(r,t,a){return await i.ToPublic(r),await window.crypto.subtle.verify({name:o.ECDSA,hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,a,t)},VerifyMsg:async function(r,t,a){return i.VerifyArrayBuffer(r,await l(t),await K(a))},GetSignHashAlgoFromCryptoKey:async function(r){return A(await i.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case s.P224:var t=e.ES224;break;case s.P256:t=e.ES256;break;case s.P384:t=e.ES384;break;case s.P521:t=e.ES512;break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return t}};var F=["alg","x"];async function E(r){if(n(r.alg)||n(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return C(r,await A(r.alg),F)}async function z(r,t,a){return i.VerifyMsg(await i.FromCozeKey(t,!0),r,a)}async function m(r,t){if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("VerifyCoze: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.");return z(JSON.stringify(r.pay),t,r.sig)}async function l(r){return new TextEncoder().encode(r).buffer}function K(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0)).buffer}function y(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0))}function c(r){return btoa(String.fromCharCode.apply(null,new Uint8Array(r))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function n(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!P(r)}function P(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}async function I(r,t){if(!Array.isArray(r))return m(r,t);var a={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCoze:[]};let f=[...r];for(let u of f)n(u.coze)||(u=u.coze),await m(u,t)?a.VerifiedCount++:(a.FailedCount++,a.FailedCoze.push(u));return a.FailedCount==0&&(a.VerifiedAll=!0),a}export{I as VerifyCozeArray};
//# sourceMappingURL=coze_standard.min.js.map
