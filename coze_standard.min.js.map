{
  "version": 3,
  "sources": ["canon.js", "alg.js", "cryptokey.js", "key.js", "coze.js", "standard/coze_array.js"],
  "sourcesContent": ["\"use strict\";\n\nimport {\n\tisEmpty,\n\tSToArrayBuffer,\n\tArrayBufferTo64ut\n} from './coze.js';\n\nexport {\n\tCanon,\n\tCanonical,\n\tCanonicalS,\n\tCanonicalHash,\n\tCanonicalHash64,\n}\n\n/**\n * @typedef {import('./typedefs.js').Dig}     Dig\n * @typedef {import('./typedefs.js').Digest}  Digest\n * @typedef {import('./typedefs.js').Canon}   Canon\n */\n\n/**\n * Canon returns the canon from first level object keys.\n * \n * @param   {Object} obj      Object to create the canon from.\n * @returns {Canon}\n */\nfunction Canon(obj) {\n\treturn Object.keys(obj);\n}\n\n/**\n * Canon canonicalizes the first level of \"object\" into the form of \"can\".\n *\n * Arrays must be converted to objects in order to deduplicate fields.\n * \n * @param   {Object}  object    Object to be canonicalized.\n * @param   {Canon}   [can]     Array|Object canon.\n * @returns {Object}            Canonicalized object.\n * @throws  {Error}             Fails on invalid canon.\n */\nasync function Canonical(object, can) {\n\tif (isEmpty(can)) {\n\t\treturn object;\n\t}\n\tlet obj = {};\n\tfor (const e of can) {\n\t\tobj[e] = object[e];\n\t}\n\treturn obj;\n}\n\n/**\n * CanonicalS canonicalizes obj and returns a JSON string.\n *\n * @param   {Object}   obj\n * @param   {Canon}    [canon]\n * @returns {String}\n */\nasync function CanonicalS(obj, can) {\n\treturn JSON.stringify(await Canonical(obj, can));\n}\n\n/**\n * CanonicalHash puts input into canonical form and returns the array buffer of\n * the digest.\n *\n * @param   {Object}        input     Object being canonicalized.\n * @param   {Dig}           hash      Must be SubtleCrypto.digest() compatible (i.e. 'SHA-256').\n * @param   {Canon}         [canon]   Array for canonical keys.\n * @returns {ArrayBuffer}             ArrayBuffer of the digest.\n * @throws  {Error}                   Fails if hash is not given.\n */\nasync function CanonicalHash(input, hash, can) {\n\tif (isEmpty(hash)) {\n\t\tthrow new Error(\"Hash is not given\");\n\t}\n\treturn await crypto.subtle.digest(hash, await SToArrayBuffer(await CanonicalS(input, can)));\n}\n\n/**\n * CanonicalHash64 returns the b64ut digest. See docs on Canonical.\n *\n * @param   {Object|String}  obj         Object being canonicalized.\n * @param   {Dig}            [hash]      Subtle crypto compatible digest that's being used (i.e. 'SHA-256').\n * @param   {Canon}          [canon]     Array for canonical keys.\n * @returns {Digest}\n */\nasync function CanonicalHash64(obj, hash, can) {\n\treturn await ArrayBufferTo64ut(await CanonicalHash(obj, hash, can));\n}", "\"use strict\";\n\n// For more documentation and notes, see the main Coze README.\n\nexport {\n\tAlgs,\n\tFamAlgs,\n\tGenAlgs,\n\tCurves,\n\tUses,\n\n\tParams,\n\tCurve,\n\tFamily,\n\tGenus,\n\tHashAlg,\n\tHashSize,\n\tSigSize,\n\tXSize,\n\tDSize,\n\tUse,\n}\n\n/**\n * @typedef {import('./typedefs.js').Params}  Params\n * @typedef {import('./typedefs.js').Alg}     Alg\n * @typedef {import('./typedefs.js').Gen}     Gen\n * @typedef {import('./typedefs.js').Fam}     Fam\n * @typedef {import('./typedefs.js').Dig}     Dig\n * @typedef {import('./typedefs.js').Crv}     Crv\n * @typedef {import('./typedefs.js').Use}     Use\n */\n\n/**\n * Algs holds all of the supported Coze algorithms.\n */\nconst Algs = {\n\tUnknownAlg: \"UnknownAlg\",\n\tES224: \"ES224\",\n\tES256: \"ES256\",\n\tES384: \"ES384\",\n\tES512: \"ES512\",\n\tEd25519: \"Ed25519\",\n\tEd25519ph: \"Ed25519ph\",\n\tEd448: \"Ed448\",\n\tSHA224: \"SHA-224\",\n\tSHA256: \"SHA-256\",\n\tSHA384: \"SHA-384\",\n\tSHA512: \"SHA-512\",\n\tSHA3224: \"SHA3-224\",\n\tSHA3256: \"SHA3-256\",\n\tSHA3384: \"SHA3-384\",\n\tSHA3512: \"SHA3-512\",\n\tSHAKE128: \"SHAKE128\",\n\tSHAKE256: \"SHAKE256\",\n};\n\n/**\n * FamAlgs holds all of the supported Coze Family algorithms.\n */\nconst FamAlgs = {\n\tEC: \"EC\",\n\tSHA: \"SHA\",\n\tRSA: \"RSA\",\n};\n\n/**\n * GenAlgs holds all of the supported Coze Genus algorithms.\n */\nconst GenAlgs = {\n\tECDSA: \"ECDSA\",\n\tEdDSA: \"EdDSA\",\n\tSHA2: \"SHA2\",\n\tSHA3: \"SHA3\",\n};\n\n/**\n * Curves holds all of the supported Coze curve algorithms.\n */\nconst Curves = {\n\tP224: \"P-224\",\n\tP256: \"P-256\",\n\tP384: \"P-384\",\n\tP521: \"P-521\",\n\tCurve25519: \"Curve25519\",\n\tCurve448: \"Curve448\",\n};\n\n/**\n * Uses holds all of the supported Coze uses.\n */\nconst Uses = {\n\tSig: \"sig\",\n\tEnc: \"enc\",\n\tDig: \"dig\",\n};\n\n/**\n * Param reports all relevant values for a given `alg`.\n * Returns Params object with populated values for relevant fields.\n * All functions defined in this file will throw an error when given an\n * unsupported algorithm.\n * \n * @param   {Alg}      alg\n * @returns {Params}\n * @throws  {Error}\n */\nfunction Params(alg) {\n\t/** @type {Params} */\n\tlet p = {};\n\tp.Name = alg;\n\tp.Genus = Genus(alg);\n\tp.Family = Family(alg);\n\tp.Use = Use(alg);\n\tp.Hash = HashAlg(alg);\n\tp.HashSize = HashSize(alg);\n\tp.HashSizeB64 = Math.ceil(4 * p.HashSize / 3);\n\n\t// SigAlg parameters\n\ttry {\n\t\tp.XSize = XSize(alg);\n\t\tp.XSizeB64 = Math.ceil(4 * p.XSize / 3);\n\t\tp.DSize = DSize(alg);\n\t\tp.DSizeB64 = Math.ceil(4 * p.DSize / 3);\n\t\tp.Curve = Curve(alg);\n\t\tp.SigSize = SigSize(alg);\n\t\tp.SigSizeB64 = Math.ceil(4 * p.SigSize / 3);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\n\treturn p;\n}\n\n/**\n * Genus returns the genus for an alg (ECDSA, EdDSA, SHA-2, SHA-3).\n * See notes on the Go implementation of Coze for more on genus.\n *\n * @param   {Alg}   alg\n * @returns {Gen}\n * @throws  {Error}\n */\nfunction Genus(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.ES256:\n\t\tcase Algs.ES384:\n\t\tcase Algs.ES512:\n\t\t\treturn GenAlgs.ECDSA;\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\tcase Algs.Ed448:\n\t\t\treturn GenAlgs.EdDSA;\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA512:\n\t\t\treturn GenAlgs.SHA2;\n\t\tcase Algs.SHA3224:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHA3384:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE128:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn GenAlgs.SHA3;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Genus: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Family returns the family for an alg (EC and SHA).\n * See notes on the Go implementation of Coze for more on family.\n *\n * @param   {Alg}     alg\n * @returns {Fam}\n * @throws  {Error}\n */\nfunction Family(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.ES256:\n\t\tcase Algs.ES384:\n\t\tcase Algs.ES512:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\tcase Algs.Ed448:\n\t\t\treturn FamAlgs.EC;\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA512:\n\t\tcase Algs.SHA3224:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHA3384:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE128:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn FamAlgs.SHA\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Family:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Hash returns the hashing algorithm for the given algorithm.  A hash alg can\n * return itself.\n * See notes on the Go implementation of Coze for more.\n *\n * @param   {Alg}   alg \n * @returns {Dig}\n * @throws  {Error}\n */\nfunction HashAlg(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\tcase Algs.SHA224:\n\t\t\treturn Algs.SHA224;\n\t\tcase Algs.SHA256:\n\t\tcase Algs.ES256:\n\t\t\treturn Algs.SHA256;\n\t\tcase Algs.SHA384:\n\t\tcase Algs.ES384:\n\t\t\treturn Algs.SHA384;\n\t\tcase Algs.SHA512:\n\t\tcase Algs.ES512: // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn Algs.SHA512;\n\t\tcase Algs.SHAKE128:\n\t\t\treturn Algs.SHAKE128\n\t\tcase Algs.SHAKE256:\n\t\tcase Algs.Ed448:\n\t\t\treturn Algs.SHAKE256\n\t\tcase Algs.SHA3224:\n\t\t\treturn Algs.SHA3224\n\t\tcase Algs.SHA3256:\n\t\t\treturn Algs.SHA3256\n\t\tcase Algs.SHA3384:\n\t\t\treturn Algs.SHA3384\n\t\tcase Algs.SHA3512:\n\t\t\treturn Algs.SHA3512\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashAlg:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * HashSize returns the hashing algorithm size for the given algorithm in bytes\n * E.g. 32.\n * \n * SHAKE128 has 128 bits of pre-collision resistance and a capacity of 256,\n * although it has arbitrary output size. SHAKE256 has 256 bits of pre-collision\n * resistance and a capacity of 512, although it has arbitrary output size.\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction HashSize(alg) {\n\tswitch (HashAlg(alg)) {\n\t\tcase Algs.SHA224:\n\t\tcase Algs.SHA3224:\n\t\t\treturn 28;\n\t\tcase Algs.SHA256:\n\t\tcase Algs.SHA3256:\n\t\tcase Algs.SHAKE128:\n\t\t\treturn 32;\n\t\tcase Algs.SHA384:\n\t\tcase Algs.SHA3384:\n\t\t\treturn 48;\n\t\tcase Algs.SHA512:\n\t\tcase Algs.SHA3512:\n\t\tcase Algs.SHAKE256:\n\t\t\treturn 64;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * SigSize returns the signature size for the given algorithm in bytes.\n * \n * Curve P-521 uses 521 bits.  This is then padded up the the nearest byte (528)\n * for R and S. 132 = (528*2)/8\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}      alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction SigSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn 56\n\t\tcase Algs.ES256:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 64\n\t\tcase Algs.ES384:\n\t\t\treturn 96\n\t\tcase Algs.Ed448:\n\t\t\treturn 114\n\t\tcase Algs.ES512:\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.SigSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * XSize returns the signature size for the given signature algorithm in bytes.\n * E.g. 64.\n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528) for R and S. (528*2)/8 = 132.\n *\n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction XSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 32\n\t\tcase Algs.ES224:\n\t\t\treturn 56\n\t\tcase Algs.Ed448:\n\t\t\treturn 57\n\t\tcase Algs.ES256:\n\t\t\treturn 64\n\t\tcase Algs.ES384:\n\t\t\treturn 96\n\t\tcase Algs.ES512:\n\t\t\treturn 132 // X and Y are 66 bytes (Rounded up for P521)\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.XSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * DSize returns the signature size for the given signature algorithm in bytes.\n * E.g. 64.\n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528). (528)/8 = 66.\n *\n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction DSize(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn 28\n\t\tcase Algs.ES256:\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn 32\n\t\tcase Algs.ES384:\n\t\t\treturn 48\n\t\tcase Algs.Ed448:\n\t\t\treturn 57\n\t\tcase Algs.ES512:\n\t\t\treturn 66\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.DSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Curve returns the curve algorithm for the given signature algorithm.\n * E.g. \"P-256\".\n * \n * See notes on the Go implementation of Coze for more.\n *\n * @param   {Alg}    alg \n * @returns {Crv}\n * @throws  {Error}\n */\nfunction Curve(alg) {\n\tswitch (alg) {\n\t\tcase Algs.ES224:\n\t\t\treturn Curves.P224;\n\t\tcase Algs.ES256:\n\t\t\treturn Curves.P256;\n\t\tcase Algs.ES384:\n\t\t\treturn Curves.P384;\n\t\tcase Algs.ES512: // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\t\treturn Curves.P521;\n\t\tcase Algs.Ed25519:\n\t\tcase Algs.Ed25519ph:\n\t\t\treturn Curves.Curve25519;\n\t\tcase Algs.Ed448:\n\t\t\treturn Curves.Curve448;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Curve: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Use returns the use for the given algorithm.  Only \"sig\", \"enc\", and \"dig\"\n * are currently valid.\n * Encryption (\"enc\") is currently not supported in Coze.\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg \n * @returns {Use}\n * @throws  {Error}\n */\nfunction Use(alg) {\n\tswitch (Genus(alg)) {\n\t\tcase GenAlgs.EdDSA:\n\t\tcase GenAlgs.ECDSA:\n\t\t\treturn Uses.Sig;\n\t\tcase GenAlgs.SHA2:\n\t\tcase GenAlgs.SHA3:\n\t\t\treturn Uses.Dig;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Use: unsupported algorithm: \" + alg);\n\t}\n}", "\"use strict\";\n\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport * as CZK from './key.js';\n\nexport {\n\tCryptoKey,\n};\n\n/**\n * @typedef {import('./typedefs.js').B64}      B64\n * @typedef {import('./typedefs.js').Alg}      Alg\n * @typedef {import('./typedefs.js').Sig}      Sig\n * @typedef {import('./typedefs.js').Dig}      Dig\n * @typedef {import('./typedefs.js').Key}      Key\n * @typedef {import('./typedefs.js').Crv}      Crv\n * @typedef {import('./typedefs.js').Msg}      Msg\n */\n\nvar CryptoKey = {\n\n\t/**\n\t * New returns a ECDSA CryptoKeyPair. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKeyPair\n\t * \n\t * @param  {Alg}           [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n\t * @return {CryptoKeyPair}\n\t * @throws {Error}\n\t */\n\tNew: async function (alg) {\n\t\tif (Coze.isEmpty(alg)) {\n\t\t\talg = Alg.Algs.ES256;\n\t\t}\n\t\t// Javascript only supports ECDSA, and doesn't support ES192 or ES224.  See\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams\n\t\tswitch (alg) {\n\t\t\tcase Alg.Algs.ES256:\n\t\t\tcase Alg.Algs.ES384:\n\t\t\tcase Alg.Algs.ES512:\n\t\t\t\treturn await window.crypto.subtle.generateKey({\n\t\t\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\t\t\tnamedCurve: Alg.Curve(alg)\n\t\t\t\t\t},\n\t\t\t\t\ttrue,\n\t\t\t\t\t[\"sign\", \"verify\"]\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.New: Unsupported key algorithm:\" + alg);\n\t\t}\n\t},\n\n\t/**\n\t * FromCozeKey takes a Coze Key and returns a Javascript CryptoKey.  Only\n\t * supports ECDSA since Crypto.subtle only supports ECDSA. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * \n\t * Throws error on invalid keys.\n\t * \n\t * @param   {Key}        cozeKey          Coze key.\n\t * @param   {Boolean}    [public=false]   Return only a public key.\n\t * @returns {CryptoKey}\n\t * @throws  {Error}                Error, SyntaxError, DOMException, TypeError\n\t */\n\tFromCozeKey: async function (cozeKey, onlyPublic) {\n\t\tif (Alg.Genus(cozeKey.alg) != Alg.GenAlgs.ECDSA) {\n\t\t\tthrow new Error(\"CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: \" + cozeKey.alg);\n\t\t}\n\n\t\t// Create a new JWK that can be used to create and \"import\" a CryptoKey\n\t\tvar jwk = {};\n\t\tjwk.use = Alg.Uses.Sig;\n\t\tjwk.crv = Alg.Curve(cozeKey.alg);\n\t\tjwk.kty = Alg.FamAlgs.EC;\n\n\t\tlet half = Alg.XSize(cozeKey.alg) / 2;\n\t\tlet xyab = await Coze.B64utToUint8Array(cozeKey.x);\n\t\tjwk.x = await Coze.ArrayBufferTo64ut(xyab.slice(0, half));\n\t\tjwk.y = await Coze.ArrayBufferTo64ut(xyab.slice(half));\n\n\t\t// Public CryptoKey \"crypto.subtle.importKey\" needs key use to be \"verify\"\n\t\t// even though this doesn't exist in JWK RFC or IANA registry. (2021/05/12)\n\t\t// Gawd help us.  Private CryptoKey needs key `use` to be \"sign\".\n\t\tif (Coze.isEmpty(cozeKey.d) || onlyPublic) {\n\t\t\tvar signOrVerify = \"verify\";\n\t\t} else {\n\t\t\tsignOrVerify = \"sign\";\n\t\t\tjwk.d = cozeKey.d;\n\t\t}\n\n\t\treturn await crypto.subtle.importKey(\n\t\t\t\"jwk\",\n\t\t\tjwk, {\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\tnamedCurve: jwk.crv,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[signOrVerify]\n\t\t);\n\t},\n\n\t/**\n\t * ToPublic accepts a Javascript CryptoKey and modifies the key to remove\n\t * any private components.\n\t *\n\t * @param   {CryptoKey} cryptoKey\n\t * @returns {void}\n\t */\n\tToPublic: async function (cryptoKey) {\n\t\tdelete cryptoKey.d; // Remove private `d` from the key.\n\t\t// Only [\"verify\"] is a valid `key_ops` value for a public CryptoKey.\n\t\t// `key_ops` must be an array.\n\t\tcryptoKey.key_ops = [\"verify\"];\n\t},\n\n\t/**\n\t * CryptoKeyToCozeKey returns a Coze Key from Javascript's \"CryptoKey\" type.\n\t * (https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) Coze keys are\n\t * similiar to JOSE JWK's but has a few significant differences.\n\t * See the Coze docs for more on these differences.\n\t * \n\t * - Coze Byte-to-string values are always b64ut, \"RFC 4648 base64 URI Safe\n\t * Truncated\".\n\t * - Coze keys also use the field `alg` to denote everything about the key:\n\t * it's use, hashing algorithm, curve, family, signature size, private\n\t * component size, public component size, etc...\n\t * - A Coze key's Thumbprint's hashing algorithm must always be in alignment\n\t * with the alg.  This is unlike JOSE which appears to use SHA-256 even for\n\t * keys that don't use that algorithm.\n\t * \n\t * This function currently only supports ECDSA (ES256. ES384, ES512) as\n\t * crypto.subtle only supports these ECDSA algorithms. From Cryptokey,\n\t * `exported` key output should is in the following form:\n\t * \n\t * {\n\t * \"crv\": \"P-256\",\n\t * \"d\": \"GwJgQIcbB29IfWO46QZwansE5XVVOg_CfafcpGk3K9I\",\n\t * \"key_ops\": [\n\t * \"sign\",\n\t * \"verify\"\n\t * ],\n\t * \"kty\": \"EC\",\n\t * \"x\": \"bMgUwXPLFR5WPERFIdUR8f6J9znFlM4fL-TaYr7YNSo\",\n\t * \"y\": \"vuU0bE-JafF1zEW_MbL-oaO0eGltDeMHIfc_bxkdCHU\",\n\t * \"use\": \"sig\"\n\t * }\n\t * \n\t * Some aspects of the Javascript exported key are in conflict with JOSE. The\n\t * `delete`s below are for reference of how out of alignment the Javascript\n\t * representation is from JOSE.  If for some reason a JOSE representation is\n\t * required, the deletes are suggested.\n\t * \n\t * `delete exported.key_ops;`\n\t * \n\t * According to RFC 7517 Section 4.3, \"use\" is mutually exclusive with\n\t * key_ops.\n\t * \n\t * `delete exported[\"ext\"];`\n\t * \n\t * `ext` is define by the Web Cryptography API and does not appear in the\n\t * core JOSE RFC's.  It stands for \"extractable\".  Since the key is already\n\t * \"extracted\" we don't care, and we're not going to burden downstream with\n\t * it.  However, this may need to be added again later if the key is further\n\t * manipulated by SubtleCrypto. \n\t * \n\t * Coze does not use \"crv\", \"kty\", or \"use\" and instead relies solely on\n\t * \"alg\". Since alg is not given, it's assumed from `crv` while `kty`is\n\t * ignored.\n\t * \n\t * Why are we exporting to JWK?\n\t * 1. There's no access to the key fields without exporting. (The\n\t * browser hides the information from Javascript.)\n\t * 2. The exporting formats are limited.  \n\t * 3. Can't export to \"raw\" because \"raw\" appears to only work on public\n\t * keys.  This may be a private key.\n\t * \n\t * @param   {CryptoKey}   cryptoKey \n\t * @returns {Key}\n\t * @throws  {Error}\n\t */\n\tToCozeKey: async function (cryptoKey) {\n\t\tlet exported = await window.crypto.subtle.exportKey(\n\t\t\t\"jwk\",\n\t\t\tcryptoKey\n\t\t);\n\n\t\tvar czk = {};\n\t\tczk.alg = await CryptoKey.algFromCrv(exported.crv);\n\t\t// Concatenate x and y, but concatenation is done at the byte level, so:\n\t\t// unencode, concatenated, and encoded. \n\t\tlet xui8 = Coze.B64utToUint8Array(exported.x);\n\t\tlet yui8 = Coze.B64utToUint8Array(exported.y);\n\t\tvar xyui8 = new Uint8Array([\n\t\t\t...xui8,\n\t\t\t...yui8,\n\t\t]);\n\t\tczk.x = Coze.ArrayBufferTo64ut(xyui8.buffer);\n\n\t\t// Only private ECDSA keys have `d`.\n\t\tif (exported.hasOwnProperty('d')) {\n\t\t\tczk.d = exported.d;\n\t\t}\n\n\t\tczk.tmb = await CZK.Thumbprint(czk);\n\t\t// console.log(\"exported: \" + JSON.stringify(exported), \"Coze Key: \" + JSON.stringify(czk)); // Debugging\n\t\treturn czk;\n\t},\n\n\t/**\n\t * Uses a Javascript `CryptoKey` to sign a array buffer.  Returns array buffer\n\t * bytes of the signature. Returns empty buffer on error.\n\t *\n\t * The signing algorithm's hashing algorithm is used for the digest of the\n\t * payload.  \n\t * \n\t * Coze uses UTF-8.\n\t *\n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n\t * \n\t * @param   {CryptoKey}      cryptoKey\n\t * @param   {ArrayBuffer}    payloadBuffer\n\t * @returns {ArrayBuffer}\n\t * @throws  {Error}\n\t */\n\tSignBuffer: async function (cryptoKey, arrayBuffer) {\n\t\treturn await window.crypto.subtle.sign({\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tarrayBuffer\n\t\t);\n\t},\n\n\t/**\n\t * SignBufferB64 signs a buffer with a CryptoKey and returns the b64ut\n\t * signature. The input is hashed before it's signed.\n\t * Coze uses UTF-8.\n\t *\n\t * @param   {CryptoKey}   cryptoKey       Private CryptoKey\n\t * @param   {ArrayBuffer} arrayBuffer     ArrayBuffer to sign.\n\t * @returns {B64}\n\t */\n\tSignBufferB64: async function (cryptoKey, arrayBuffer) {\n\t\treturn await Coze.ArrayBufferTo64ut(await CryptoKey.SignBuffer(cryptoKey, arrayBuffer));\n\t},\n\n\t/**\n\t * SignString signs a string and returns the b64ut signature.\n\t * Coze uses UTF-8.\n\t * \n\t * @param   {CryptoKey} cryptoKey      Private key used for signing.\n\t * @param   {String}    utf8           String to sign.\n\t * @returns {B64}\n\t */\n\tSignString: async function (cryptoKey, utf8) {\n\t\treturn await CryptoKey.SignBufferB64(cryptoKey, await Coze.SToArrayBuffer(utf8));\n\t},\n\n\t/**\n\t * VerifyArrayBuffer verifies an ArrayBuffer msg with an ArrayBuffer sig and\n\t * Javascript CryptoKey.\n\t * Returns whether or not message is verified by the given key and signature.\n\t * \n\t * @param   {CryptoKey}   cryptoKey           Javascript CryptoKey.\n\t * @param   {ArrayBuffer} sig                 Signature.\n\t * @param   {ArrayBuffer} msg                 Message.\n\t * @returns {Boolean}\n\t */\n\tVerifyArrayBuffer: async function (cryptoKey, msg, sig) {\n\t\t// Guarantee key is not private to appease Javascript:\n\t\tawait CryptoKey.ToPublic(cryptoKey);\n\t\treturn await window.crypto.subtle.verify({\n\t\t\t\tname: Alg.GenAlgs.ECDSA,\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tsig,\n\t\t\tmsg);\n\t},\n\n\t/**\n\t * VerifyMsg uses a public key to verify a string msg with a b64ut sig.\n\t * Returns whether or not the signature is valid.\n\t * \n\t * @param   {CryptoKey}  cryptoKey         Javascript CryptoKey.\n\t * @param   {Msg}        msg               String that was signed.\n\t * @param   {Sig}        sig               B64 signature.\n\t * @returns {Boolean}\n\t */\n\tVerifyMsg: async function (cryptoKey, msg, sig) {\n\t\treturn CryptoKey.VerifyArrayBuffer(cryptoKey, await Coze.SToArrayBuffer(msg), await Coze.B64uToArrayBuffer(sig));\n\t},\n\n\t/**\n\t * GetSignHashAlgoFromCryptoKey gets the signing hashing algorithm from the\n\t * CryptoKey.\n\t * Returns the name of the hashing algorithm. E.g. \"SHA-256\".\n\t *\n\t * Javascript's CryptoKey explicitly requires a signing hashing algorithm, but\n\t * the CryptoKey itself may not explicitly contain that information. For\n\t * example, a ES256 key will have the curve (P-256) and the general key type\n\t * (ECDSA), but the hashing algo is not explicitly stated (SHA-256), nor is\n\t * the algorithm explicitly stated (ES256).\n\t *\n\t * However, for some CryptoKeys, the hashing algorithm is explicitly stated.\n\t * For example, \"RsaHashedKeyGenParams\" has the field \"hash\" which explicitly\n\t * denotes what hashing algorithm was used.  As of 2021/05/26,\n\t * \"EcKeyGenParams\" has no such field, so it must be assumed that certain\n\t * hashing algorithms are paired with certain curves.\n\t *\n\t * The purpose of this function is to return the correct hashing digest for\n\t * all CryptoKeys regardless of their form.\n\t * \n\t * @param   {CryptoKey} CryptoKey  CryptoKey Javascript object.\n\t * @returns {Dig}\n\t */\n\tGetSignHashAlgoFromCryptoKey: async function (cryptoKey) {\n\t\treturn Alg.HashAlg(await CryptoKey.algFromCrv(cryptoKey.algorithm.namedCurve));\n\t},\n\n\t/**\n\t * algFromCrv returns a SEAlg from the given curve.\n\t * Fails when the curve is not supported or recognized.\n\t * \n\t * @param   {Crv}     src    Curve type. E.g. \"P-256\".\n\t * @returns {Alg}\n\t * @throws  {Error}\n\t */\n\talgFromCrv: async function (crv) {\n\t\tswitch (crv) {\n\t\t\tcase Alg.Curves.P224:\n\t\t\t\tvar alg = Alg.Algs.ES224;\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P256:\n\t\t\t\talg = Alg.Algs.ES256\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P384:\n\t\t\t\talg = Alg.Algs.ES384;\n\t\t\t\tbreak;\n\t\t\tcase Alg.Curves.P521: // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\t\talg = Alg.Algs.ES512;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\t\treturn alg;\n\t}\n}; // End CryptoKey", "\"use strict\";\n\nimport * as CTK from './cryptokey.js';\nimport * as Can from './canon.js';\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tNewKey,\n\tCorrect,\n\tValid,\n\tThumbprint,\n\tRevoke,\n\tIsRevoked,\n\n\t// RecalcX,\n\n\tTmbCanon,\n}\n\n/**\n * @typedef {import('./typedefs.js').B64}  B64\n * @typedef {import('./typedefs.js').Alg}  Alg\n * @typedef {import('./typedefs.js').Use}  Use\n * @typedef {import('./typedefs.js').Sig}  Sig\n * @typedef {import('./typedefs.js').Key}  Key\n * @typedef {import('./typedefs.js').Time} Time\n */\n\n// Coze key Thumbprint Canons.\nconst TmbCanon = [\"alg\", \"x\"];\n\n/**\n * NewKey returns a new Coze key.\n * If no alg is given, the returned key will be an 'ES256' key.\n * \n * @param   {Alg}     [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n * @returns {Key}\n */\nasync function NewKey(alg) {\n\tif (isEmpty(alg)) {\n\t\talg = Alg.Algs.ES256;\n\t}\n\tif (Alg.Genus(alg) == Alg.GenAlgs.ECDSA) {\n\t\tvar keyPair = await CTK.CryptoKey.New(alg);\n\t} else {\n\t\tthrow new Error(\"Coze.NewKey: only ECDSA algs are currently supported.\");\n\t}\n\n\tlet k = await CTK.CryptoKey.ToCozeKey(keyPair.privateKey);\n\tk.iat = Math.floor(Date.now() / 1000); // To get Unix from js, divide by 1000.\n\tk.tmb = await Thumbprint(k);\n\tk.kid = \"My Cyphr.me Key.\";\n\n\treturn k;\n}\n\n/**\n * Thumbprint generates and returns a B64 Coze key thumbprint.\n * Fails on empty 'alg' or 'x'.\n *\n * @param   {Key} cozeKey\n * @returns {B64}\n * @throws  {Error}\n */\nasync function Thumbprint(cozeKey) {\n\tif (isEmpty(cozeKey.alg) || isEmpty(cozeKey.x)) {\n\t\tthrow new Error(\"Coze.Thumbprint: alg or x is empty.\");\n\t}\n\treturn Can.CanonicalHash64(cozeKey, await Alg.HashAlg(cozeKey.alg), TmbCanon);\n};\n\n/**\n * Valid validates a private Coze key.  See notes on `Correct`.\n * If the key is invalid, Valid may log an error.\n * Returns whether or not the given key is valid.\n *\n * @param   {Key}      privateCozeKey  Private Coze key.\n * @returns {Boolean}\n */\nasync function Valid(privateCozeKey) {\n\tif (isEmpty(privateCozeKey.d)) {\n\t\tconsole.error(\"Coze key missing `d`\");\n\t\treturn false;\n\t}\n\ttry {\n\t\tlet msg = `7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q`;\n\t\tlet sig = await Coze.Sign(msg, privateCozeKey);\n\t\treturn Coze.Verify(msg, privateCozeKey, sig);\n\t} catch (e) {\n\t\t// Don't throw error, but still log it for debugging.\n\t\tconsole.error(\"Valid: \" + e);\n\t\treturn false;\n\t}\n}\n\n/**\n * Correct checks for the correct construction of a Coze key, but may return\n * true on cryptographically invalid public keys.  Key must have `alg` and at\n * least one of `tmb`, `x`, and `d`. Using input information, if it is possible\n * to definitively know the given key is incorrect, Correct returns false, but\n * if it's plausible it's correct, Correct returns true. Correct answers the\n * question: \"Is the given Coze key reasonable using the information provided?\".\n * Correct is useful for sanity checking public keys without signed messages,\n * sanity checking `tmb` only keys, and validating private keys. Use function\n * \"Verify\" instead for verifying public keys when a signed message is\n * available. Correct is considered an advanced function. Please understand it\n * thoroughly before use.\n * \n * Correct:\n * \n * 1. Checks the length of `x` and/or `tmb` against `alg`.\n * 2. If `x` and `tmb` are present, verifies correct `tmb`.\n * 3. If `d` is present, verifies correct `tmb` and `x` if present, and verifies\n * the key by verifying a generated signature.\n * \n * @param   {Key}     ck\n * @returns {Boolean}\n */\nasync function Correct(ck) {\n\tif (typeof ck !== \"object\") {\n\t\tconsole.error(\"Correct: CozeKey must be passed in as an object.\");\n\t\treturn false;\n\t}\n\n\tif (isEmpty(ck.alg)) {\n\t\tconsole.error(\"Correct: Alg must be set\");\n\t\treturn false;\n\t}\n\n\tlet p = Alg.Params(ck.alg);\n\n\tlet isTmbEmpty = isEmpty(ck.tmb);\n\tlet isXEmpty = isEmpty(ck.x);\n\tlet isDEmpty = isEmpty(ck.d);\n\n\tif (isTmbEmpty && isXEmpty && isDEmpty) {\n\t\tconsole.error(\"Correct: At least one of [x, tmb, d] must be set\");\n\t\treturn false;\n\t}\n\n\t// tmb only key\n\tif (isXEmpty && isDEmpty) {\n\t\tif (isTmbEmpty || ck.tmb.length !== p.HashSizeB64) {\n\t\t\tconsole.error(\"Correct: Incorrect `tmb` size: \", ck.tmb.length);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// d is not set\n\tif (!isXEmpty && ck.x.length !== p.XSizeB64) {\n\t\tconsole.error(\"Correct: Incorrect x size: \", ck.x.length);\n\t\treturn false;\n\t}\n\n\t// We currently do not support recalculating `x`, as subtle does not provide\n\t// the necessary API for computing the points from the private component.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle\n\t//\n\t// See RecalcX docs below\n\t//\n\t// If d and (x and/or tmb) is given, recompute from d and compare:\n\t// let x = RecalcX(ck);\n\n\t// If tmb is set, recompute and compare.\n\tif (!isTmbEmpty && !isXEmpty) {\n\t\tlet t = await Thumbprint(ck);\n\t\tif (ck.tmb !== t) {\n\t\t\tconsole.error(\"Correct: Incorrect given `tmb`: \", ck.tmb);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// // Sanity check - No keys from the future allowed.\n\t// if (ck.iat > Math.round((Date.now() / 1000))) {\n\t// \tconsole.error(\"Correct: cannot have iat greater than present time\");\n\t// }\n\n\n\t// If private key, validate by signing and verifying.\n\t// `x` must also be populated, for cryptokey, since we do not have RecalcX().\n\tif (!isDEmpty && !isXEmpty) {\n\t\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(ck);\n\t\tlet mldBuffer = await Coze.SToArrayBuffer(\"Test Signing\")\n\t\tlet sig = await CTK.CryptoKey.SignBuffer(cryptoKey, mldBuffer);\n\t\tlet pubKey = await CTK.CryptoKey.FromCozeKey(ck, true);\n\t\tlet result = await CTK.CryptoKey.VerifyArrayBuffer(pubKey, mldBuffer, sig);\n\n\t\tif (!result) {\n\t\t\tconsole.error(\"Correct: private key invalid.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n\n// TODO Support RecalcX if crypto.subtle provides necessary API for computing\n// https://stackoverflow.com/questions/72151096/how-to-derive-public-key-from-private-key-using-webcryptoapi/72153942#72153942\n//\n// scalar/jacobian/affinity from private component.\n// Alternatively, use noble.\n// function RecalcX(ck) {\n// \tlet x;\n// \tswitch (ck.alg) {\n// \t\tcase \"ES256\":\n// \t\tcase \"ES384\":\n// \t\tcase \"ES512\":\n// \t\t\tbreak;\n// \t\tdefault:\n// \t\t\tx = null;\n// \t}\n\n// \treturn x;\n// }\n\n\n/**\n * Revoke generates a self revoke message and sets the input key as revoked.\n * 'rvk' will be set on given cozeKey.\n * \n * @param   {Key}       cozeKey  Private Coze key.\n * @param   {String}    [msg]    Optional, human readable non programmatic reason for revoking the key.\n * @returns {Coze}               Signed revoke Coze.\n * @throws  {Error}              Fails if cryptoKeyPrivate is nil or invalid.\n */\nasync function Revoke(cozeKey, msg) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"CozeKey.Revoke: Private key not set.  Cannot sign message\");\n\t}\n\n\tvar coze = {};\n\tcoze.pay = {};\n\tif (!isEmpty(msg)) { // Optional revoke message. \n\t\tcoze.pay.msg = msg;\n\t}\n\tcoze.pay.rvk = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\t// SignCoze does not allow revoked keys to sign messages.  Temporarily remove\n\t// key.revoke and then set back afterward, otherwise set key with new revoke. \n\tlet prevRvk = cozeKey.rvk;\n\tdelete cozeKey.rvk;\n\tcoze = await Coze.SignCoze(coze, cozeKey);\n\tif (prevRvk !== undefined) {\n\t\tcozeKey.rvk = prevRvk;\n\t} else {\n\t\tcozeKey.rvk = coze.pay.rvk;\n\t}\n\n\treturn coze\n};\n\n/**\n * IsRevoked returns true if a key or a coze is marked as revoked. `rvk` should\n * be an integer Unix timestamp, however this function also checks for the\n * string \"true\" as well as the bool `true`.\n *\n * Messages self-revoking keys must have `rvk` with an integer value greater\n * than 0.  \n *\n * @param   {Key|Coze}       cozeKey  Coze key or coze object.\n * @param   {String}         [msg]    Optional reason for revoking the key.\n * @returns {Boolean}\n */\nfunction IsRevoked(cozeKey) {\n\tif (isEmpty(cozeKey.rvk) || !(parseInt(cozeKey.rvk) > 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as Can from './canon.js'; // import as \"Can\" since func \"Canon\" will conflict in `coze.join.js`.\nimport * as Enum from './alg.js';\nimport * as CZK from './key.js';\nimport * as CTK from './cryptokey.js';\n\nexport {\n\tPayCanon,\n\tSign,\n\tSignCoze,\n\tSignCozeRaw,\n\tVerify,\n\tVerifyCoze,\n\t// VerifyCozeArray,\n\tMeta,\n\n\t// Base conversion\n\tSToArrayBuffer,\n\tB64uToArrayBuffer,\n\tB64utToUint8Array,\n\tArrayBufferTo64ut,\n\n\t// Helpers\n\tisEmpty,\n\tisBool,\n}\n\n/**\n * @typedef {import('./typedefs.js').Key}            Key\n * @typedef {import('./typedefs.js').Alg}            Alg\n * @typedef {import('./typedefs.js').Msg}            Msg\n * @typedef {import('./typedefs.js').Coze}           Coze\n * @typedef {import('./typedefs.js').Sig}            Sig\n * @typedef {import('./typedefs.js').Canon}          Canon\n * @typedef {import('./typedefs.js').Meta}           Meta\n * @typedef {import('./typedefs.js').VerifiedArray}  VerifiedArray\n */\n\n// PayCanon is the standard coze.pay fields.\nconst PayCanon = [\"alg\", \"iat\", \"tmb\", \"typ\"];\n\n/**\n * Sign signs message with private Coze key and returns b64ut sig.\n * TODO Fix after tests for signbuffer\n * \n * @param   {Msg}           message    Message string.\n * @param   {Key}           cozeKey    Private coze key.\n * @returns {Sig}\n * @throws  {Error}\n */\nasync function Sign(message, cozeKey) {\n\treturn CTK.CryptoKey.SignBufferB64(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozeKey),\n\t\tawait SToArrayBuffer(message)\n\t);\n}\n\n/**\n * SignCoze signs in place coze.pay with a private Coze key. Returns the same,\n * but updated, coze.  Errors on mismatch `alg` or `tmb`.  If empty, `alg` and\n * `tmb` are populated. `iat` set to current time.\n *\n * SignCoze, SignCozeRaw, VerifyCoze, and VerifyCozeArray assumes that object\n * has no duplicate fields since this is disallowed in Javascript.\n * \n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}                 Coze that may have been modified from given.\n * @throws  {Error}                Fails on invalid key, parse error, mismatch fields.\n */\nasync function SignCoze(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCoze: Cannot sign with revoked key.\");\n\t}\n\tif (isEmpty(coze.pay.alg)) {\n\t\tcoze.pay.alg = cozeKey.alg;\n\t}\n\tif (isEmpty(coze.pay.tmb)) {\n\t\tcoze.pay.tmb = await CZK.Thumbprint(cozeKey);\n\t}\n\tif (coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"SignCoze: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"SignCoze: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\n\tcoze.pay.iat = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\n\tcoze.sig = await Sign(await JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n\n/**\n * SignCozeRaw signs in place coze.pay with a private Coze key, but unlike\n * SignCoze, does not set `alg`, `tmb` or `iat`.\n *\n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}                 Coze with new `sig` and canonicalized `pay`.\n * @throws  {Error}                Fails on mismatch `alg` or `tmb`.\n */\nasync function SignCozeRaw(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCozeRaw: Cannot sign with revoked key.\");\n\t}\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\tcoze.sig = await Sign(await JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n/**\n * Verify verifies a `pay` with `sig` and returns whether or not the message is\n * verified. Verify does no Coze checks.  If checks are needed, use\n * VerifyCoze();\n *\n * @param  {Msg}       message    Message string.\n * @param  {Key}       cozekey    Coze key for validation.\n * @param  {Sig}       sig        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function Verify(message, cozekey, sig) {\n\treturn CTK.CryptoKey.VerifyMsg(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozekey, true),\n\t\tmessage,\n\t\tsig,\n\t);\n};\n\n/**\n * VerifyCoze returns a whether or not the Coze is valid. coze.sig must be set.\n * If set, pay.alg and pay.tmb must match with cozeKey.\n * \n * @param  {Coze}     coze         Coze with signed pay.\n * @param  {Key}      [cozeKey]    Public Coze key for verification.\n * @param  {Sig}      [sig]        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function VerifyCoze(coze, cozeKey) {\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"VerifyCoze: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\treturn Verify(JSON.stringify(coze.pay), cozeKey, coze.sig);\n}\n\n/**\n * Meta recalculates and sets [can, cad, czd] for given `coze`. Coze.Pay, and\n * Coze.Sig must be set, and either Coze.Pay.Alg or parameter alg must be set.\n * Meta does no cryptographic verification.\n *\n * @param  {Coze}      coze     coze.\n * @param  {Alg}       [alg]    coze.pay.alg takes precedence.\n * @return {Meta}               Meta Coze (sets fields [can, cad, czd]).\n * @throws {Error}              Fails on JSON parse exception.\n */\nasync function Meta(coze, alg) {\n\tif (!isEmpty(coze.pay.alg)) {\n\t\talg = Enum.HashAlg(coze.pay.alg);\n\t} else {\n\t\talg = Enum.HashAlg(alg);\n\t}\n\tcoze.can = await Can.Canon(coze.pay);\n\tcoze.cad = await Can.CanonicalHash64(coze.pay, alg);\n\tcoze.czd = await Can.CanonicalHash64({\n\t\tcad: coze.cad,\n\t\tsig: coze.sig\n\t}, alg);\n\treturn coze;\n}\n\n\n///////////////////////////////////\n// Base Conversion\n///////////////////////////////////\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @param  {String}        string\n * @return {ArrayBuffer}\n */\nasync function SToArrayBuffer(string) {\n\treturn new TextEncoder().encode(string).buffer; // Suppose to be always in UTF-8\n}\n\n/**\n * B64uToArrayBuffer takes a b64u (truncated or not truncated) string and\n * decodes it to an ArrayBuffer.\n * \n * @param   {B64}          string \n * @returns {ArrayBuffer}\n */\nfunction B64uToArrayBuffer(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0)).buffer;\n};\n\n/**\n * B64utToUint8Array takes a b64ut string and decodes it back into a string.\n * \n * @param   {B64}          string \n * @returns {Uint8Array}\n */\nfunction B64utToUint8Array(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));\n};\n\n/**\n * ArrayBufferTo64ut returns a b64 string from an Array buffer.\n * \n * @param   {ArrayBuffer} buffer  Arbitrary bytes. UTF-16 is Javascript native.\n * @returns {B64}\n */\nfunction ArrayBufferTo64ut(buffer) {\n\treturn btoa(String.fromCharCode.apply(null, new Uint8Array(buffer))).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\n\n///////////////////////////////////\n// Helpers - Taken from Cyphr.me\n///////////////////////////////////\n\n/**\n * isEmpty is a helper function to determine if thing is empty. \n * \n * Objects are empty if they have no keys. (Returns len === 0 of object keys.)\n *\n * Functions are considered always not empty. \n * \n * NaN returns true.  (NaN === NaN is always false, as NaN is never equal to\n * anything. NaN is the only JavaScript value unequal to itself.)\n *\n * Don't use on HTMl elements. For HTML elements, use the !== equality check\n * (element !== null).\n *\n * Cannot use CryptoKey with this function since (len === 0) always. \n *\n * @param   {any}     thing    Thing you wish was empty.\n * @returns {Boolean}\n */\nfunction isEmpty(thing) {\n\tif (typeof thing === 'function') {\n\t\treturn false;\n\t}\n\n\tif (thing === Object(thing)) {\n\t\tif (Object.keys(thing).length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!isBool(thing)) {\n\t\treturn true;\n\t}\n\treturn false\n};\n\n\n/**\n * Helper function to determine boolean.  \n *\n * Javascript, instead of considering everything false except a few key words,\n * decided everything is true instead of a few key words.  Why?  Because\n * Javascript.  This function inverts that assumption, so that everything can be\n * considered false unless true. \n *\n * @param   {any}      bool   Thing that you wish was a boolean.  \n * @returns {Boolean}\n */\nfunction isBool(bool) {\n\tif (\n\t\tbool === false ||\n\t\tbool === \"false\" ||\n\t\tbool === undefined ||\n\t\tbool === \"undefined\" ||\n\t\tbool === \"\" ||\n\t\tbool === 0 ||\n\t\tbool === \"0\" ||\n\t\tbool === null ||\n\t\tbool === \"null\" ||\n\t\tbool === \"NaN\" ||\n\t\tNumber.isNaN(bool) ||\n\t\tbool === Object(bool) // isObject\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport {\n\tisEmpty,\n\tVerifyCoze\n} from '../coze.js';\n\nexport {\n\tVerifyCozeArray\n}\n/**\n * @typedef {import('../typedefs.js').Coze}  Coze\n */\n\n/**\n * VerifiedArray - Used when verifying array of cozies.\n * \n * - VerifiedAll:    Indicates if whole array was verified. False on error or if\n *                   anything was not verified.\n * - VerifiedCount:  Number of objects verified.\n * - FailedCount:    Number of objects that failed verification.\n * - FailedCoze:     Objects that failed verification.\n * @typedef  {Object}  VerifiedArray\n * @property {Boolean} VerifiedAll\n * @property {Number}  VerifiedCount\n * @property {Number}  FailedCount\n * @property {Coze[]}  FailedCoze\n */\n\n/**\n * VerifyCozeArray verifies an array of `coze`s and returns a single\n * \"VerifiedArray\" object.\n *\n * @param  {coze[]}           coze       Array of Coze objects.\n * @param  {Key}              cozeKey    Javascript object. Coze Key.\n * @return {VerifiedArray}\n * @throws {Error}\n */\nasync function VerifyCozeArray(coze, cozeKey) {\n\tif (!Array.isArray(coze)) {\n\t\treturn VerifyCoze(coze, cozeKey)\n\t}\n\n\t/** @type {VerifiedArray} */\n\tvar verifiedObj = {\n\t\tVerifiedAll: false,\n\t\tVerifiedCount: 0,\n\t\tFailedCount: 0,\n\t\tFailedCoze: [],\n\t};\n\n\tlet copy = [...coze]; // Copy so original isn't modified.\n\tfor (let c of copy) {\n\t\tif (!isEmpty(c.coze)) { // \"coze\" encapsulated?\n\t\t\tc = c.coze;\n\t\t}\n\n\t\tlet valid = await VerifyCoze(c, cozeKey);\n\t\tif (valid) {\n\t\t\tverifiedObj.VerifiedCount++;\n\t\t} else {\n\t\t\tverifiedObj.FailedCount++;\n\t\t\tverifiedObj.FailedCoze.push(c);\n\t\t}\n\t}\n\n\tif (verifiedObj.FailedCount == 0) {\n\t\tverifiedObj.VerifiedAll = true;\n\t}\n\n\treturn verifiedObj;\n};"],
  "mappings": "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",
  "names": []
}
