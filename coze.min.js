var e={UnknownAlg:"UnknownAlg",ES224:"ES224",ES256:"ES256",ES384:"ES384",ES512:"ES512",Ed25519:"Ed25519",Ed25519ph:"Ed25519ph",Ed448:"Ed448",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512",SHA3224:"SHA3-224",SHA3256:"SHA3-256",SHA3384:"SHA3-384",SHA3512:"SHA3-512",SHAKE128:"SHAKE128",SHAKE256:"SHAKE256"},p={EC:"EC",SHA:"SHA",RSA:"RSA"},o={ECDSA:"ECDSA",EdDSA:"EdDSA",SHA2:"SHA2",SHA3:"SHA3"},u={P224:"P-224",P256:"P-256",P384:"P-384",P521:"P-521",Curve25519:"Curve25519",Curve448:"Curve448"},w={Sig:"sig",Enc:"enc",Hsh:"hsh"};function K(r){let t={};t.Name=r,t.Genus=y(r),t.Family=R(r),t.Use=O(r),t.Hash=f(r),t.HashSize=V(r),t.HashSizeB64=Math.ceil(4*t.HashSize/3);try{t.XSize=d(r),t.XSizeB64=Math.ceil(4*t.XSize/3),t.DSize=j(r),t.DSizeB64=Math.ceil(4*t.DSize/3),t.Curve=E(r),t.SigSize=M(r),t.SigSizeB64=Math.ceil(4*t.SigSize/3)}catch{}return t}function y(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:return o.ECDSA;case e.Ed25519:case e.Ed25519ph:case e.Ed448:return o.EdDSA;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:return o.SHA2;case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return o.SHA3;default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function R(r){switch(r){case e.ES224:case e.ES256:case e.ES384:case e.ES512:case e.Ed25519:case e.Ed25519ph:case e.Ed448:return p.EC;case e.SHA224:case e.SHA256:case e.SHA384:case e.SHA512:case e.SHA3224:case e.SHA3256:case e.SHA3384:case e.SHA3512:case e.SHAKE128:case e.SHAKE256:return p.SHA;default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function f(r){switch(r){case e.ES224:case e.SHA224:return e.SHA224;case e.SHA256:case e.ES256:return e.SHA256;case e.SHA384:case e.ES384:return e.SHA384;case e.SHA512:case e.ES512:case e.Ed25519:case e.Ed25519ph:return e.SHA512;case e.SHAKE128:return e.SHAKE128;case e.SHAKE256:case e.Ed448:return e.SHAKE256;case e.SHA3224:return e.SHA3224;case e.SHA3256:return e.SHA3256;case e.SHA3384:return e.SHA3384;case e.SHA3512:return e.SHA3512;default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function V(r){switch(f(r)){case e.SHA224:case e.SHA3224:return 28;case e.SHA256:case e.SHA3256:case e.SHAKE128:return 32;case e.SHA384:case e.SHA3384:return 48;case e.SHA512:case e.SHA3512:case e.SHAKE256:return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function M(r){switch(r){case e.ES224:return 56;case e.ES256:case e.Ed25519:case e.Ed25519ph:return 64;case e.ES384:return 96;case e.Ed448:return 114;case e.ES512:return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function d(r){switch(r){case e.Ed25519:case e.Ed25519ph:return 32;case e.ES224:return 56;case e.Ed448:return 57;case e.ES256:return 64;case e.ES384:return 96;case e.ES512:return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function j(r){switch(r){case e.ES224:return 28;case e.ES256:case e.Ed25519:case e.Ed25519ph:return 32;case e.ES384:return 48;case e.Ed448:return 57;case e.ES512:return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function E(r){switch(r){case e.ES224:return u.P224;case e.ES256:return u.P256;case e.ES384:return u.P384;case e.ES512:return u.P521;case e.Ed25519:case e.Ed25519ph:return u.Curve25519;case e.Ed448:return u.Curve448;default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function O(r){switch(y(r)){case o.EdDSA:case o.ECDSA:return w.Sig;case o.SHA2:case o.SHA3:return w.Hsh;default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var i={New:async function(r){switch(n(r)&&(r=e.ES256),r){case e.ES256:case e.ES384:case e.ES512:return await window.crypto.subtle.generateKey({name:o.ECDSA,namedCurve:E(r)},!0,["sign","verify"]);default:throw new Error("CryptoKey.New: Unsupported key algorithm:"+r)}},FromCozeKey:async function(r,t){if(y(r.alg)!=o.ECDSA)throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var a={};a.use=w.Sig,a.crv=E(r.alg),a.kty=p.EC;let s=d(r.alg)/2,c=await m(r.x);if(a.x=await A(c.slice(0,s)),a.y=await A(c.slice(s)),n(r.d)||t)var S="verify";else S="sign",a.d=r.d;return await crypto.subtle.importKey("jwk",a,{name:o.ECDSA,namedCurve:a.crv},!0,[S])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let t=await window.crypto.subtle.exportKey("jwk",r);var a={};a.alg=await i.algFromCrv(t.crv);let s=m(t.x),c=m(t.y);var S=new Uint8Array([...s,...c]);return a.x=A(S.buffer),t.hasOwnProperty("d")&&(a.d=t.d),a.tmb=await C(a),a},SignBuffer:async function(r,t){return await window.crypto.subtle.sign({name:o.ECDSA,hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,t)},SignBufferB64:async function(r,t){return await A(await i.SignBuffer(r,t))},SignString:async function(r,t){return await i.SignBufferB64(r,await l(t))},VerifyArrayBuffer:async function(r,t,a){return await i.ToPublic(r),await window.crypto.subtle.verify({name:o.ECDSA,hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,a,t)},VerifyMsg:async function(r,t,a){return i.VerifyArrayBuffer(r,await l(t),await z(a))},GetSignHashAlgoFromCryptoKey:async function(r){return f(await i.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case u.P224:var t=e.ES224;break;case u.P256:t=e.ES256;break;case u.P384:t=e.ES384;break;case u.P521:t=e.ES512;break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return t}};var I=["alg","x"];async function Q(r){if(n(r)&&(r=e.ES256),y(r)==o.ECDSA)var t=await i.New(r);else throw new Error("Coze.NewKey: only ECDSA algs are currently supported.");let a=await i.ToCozeKey(t.privateKey);return a.iat=Math.floor(Date.now()/1e3),a.tmb=await C(a),a.kid="My Cyphr.me Key.",a}async function C(r){if(n(r.alg)||n(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return g(r,await f(r.alg),I)}async function Y(r){if(n(r.d))return console.error("Coze key missing `d`"),!1;try{let t="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",a=await h(t,r);return T(t,r,a)}catch(t){return console.error("Valid: "+t),!1}}async function q(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(n(r.alg))return console.error("Correct: Alg must be set"),!1;let t=K(r.alg),a=n(r.tmb),s=n(r.x),c=n(r.d);if(a&&s&&c)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(s&&c)return a||r.tmb.length!==t.HashSizeB64?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!s&&r.x.length!==t.XSizeB64)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!a&&!s){let S=await C(r);if(r.tmb!==S)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!c&&!s){let S=await i.FromCozeKey(r),B=await l("Test Signing"),U=await i.SignBuffer(S,B),N=await i.FromCozeKey(r,!0);if(!await i.VerifyArrayBuffer(N,B,U))return console.error("Correct: private key invalid."),!1}return!0}async function L(r,t){if(n(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var a={};a.pay={},n(t)||(a.pay.msg=t),a.pay.rvk=Math.round(Date.now()/1e3);let s=r.rvk;return delete r.rvk,a=await P(a,r),s!==void 0?r.rvk=s:r.rvk=a.pay.rvk,a}function b(r){return!(n(r.rvk)||!(parseInt(r.rvk)>0))}var $=["alg","iat","tmb","typ"];async function h(r,t){return i.SignBufferB64(await i.FromCozeKey(t),await l(r))}async function P(r,t,a){if(b(t))throw new Error("SignCoze: Cannot sign with revoked key.");if(n(r.pay.alg)&&(r.pay.alg=t.alg),n(r.pay.tmb)&&(r.pay.tmb=await C(t)),r.pay.alg!==t.alg)throw new Error("SignCoze: Coze key alg mismatch with coze.pay.alg.");if(r.pay.tmb!==t.tmb)throw new Error("SignCoze: Coze key tmb mismatch with coze.pay.tmb.");return r.pay.iat=Math.round(Date.now()/1e3),n(a)||(r.pay=await H(r.pay,a)),r.sig=await h(JSON.stringify(r.pay),t),r}async function rr(r,t,a){if(b(t))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return n(a)||(r.pay=await H(r.pay,a)),r.sig=await h(JSON.stringify(r.pay),t),r}async function T(r,t,a){return i.VerifyMsg(await i.FromCozeKey(t,!0),r,a)}async function er(r,t){if(!n(r.pay.alg)&&r.pay.alg!==t.alg)throw new Error("VerifyCoze: Coze key alg mismatch with coze.pay.alg.");if(!n(r.pay.tmb)&&r.pay.tmb!==t.tmb)throw new Error("VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.");return T(JSON.stringify(r.pay),t,r.sig)}async function tr(r,t){return n(r.pay.alg)?t=f(t):t=f(r.pay.alg),r.can=await G(r.pay),r.cad=await g(r.pay,t),r.czd=await g({cad:r.cad,sig:r.sig},t),r}async function l(r){return new TextEncoder().encode(r).buffer}function z(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0)).buffer}function m(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),t=>t.charCodeAt(0))}function A(r){return btoa(String.fromCharCode.apply(null,new Uint8Array(r))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function n(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!X(r)}function X(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function G(r){return Object.keys(r)}async function H(r,t){if(n(t))return r;let a={};for(let s of t)a[s]=r[s];return a}async function Z(r,t){return JSON.stringify(await H(r,t))}async function _(r,t,a){if(n(t))throw new Error("Hash is not given");return await crypto.subtle.digest(t,await l(await Z(r,a)))}async function g(r,t,a){return await A(await _(r,t,a))}export{e as Algs,A as ArrayBufferTo64ut,z as B64uToArrayBuffer,m as B64utToUint8Array,G as Canon,H as Canonical,_ as CanonicalHash,g as CanonicalHash64,Z as CanonicalS,q as Correct,i as CryptoKey,E as Curve,u as Curves,j as DSize,p as FamAlgs,R as Family,o as GenAlgs,y as Genus,f as HashAlg,V as HashSize,b as IsRevoked,tr as Meta,Q as NewKey,K as Params,$ as PayCanon,L as Revoke,l as SToArrayBuffer,M as SigSize,h as Sign,P as SignCoze,rr as SignCozeRaw,C as Thumbprint,I as TmbCanon,O as Use,w as Uses,Y as Valid,T as Verify,er as VerifyCoze,d as XSize,X as isBool,n as isEmpty};
//# sourceMappingURL=coze.min.js.map
