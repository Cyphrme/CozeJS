"use strict";async function u(e){var r=new TextEncoder;return r.encode(e).buffer}async function l(e){if(typeof e!="string")throw new TypeError("base_convert.HexToArrayBuffer: Expected input to be a string");if(e.length%2!=0)throw new RangeError("base_convert.HexToArrayBuffer: Expected string to be an even number of characters");for(var r=new Uint8Array(e.length/2),t=0;t<e.length;t+=2)r[t/2]=parseInt(e.substring(t,t+2),16);return r.buffer}async function y(e){return[...new Uint8Array(e)].map(r=>r.toString(16).padStart(2,"0")).join("").toUpperCase()}function g(e){let r=F(e),t=atob(r),a="";for(let n=0;n<t.length;n++){let s=t.charCodeAt(n).toString(16).toUpperCase();a+=s.length===2?s:"0"+s}return a}async function h(e){let r=await l(e);return await G(r)}function M(e){return O(e).replace(/=/g,"")}function O(e){return e.replace(/\+/g,"-").replace(/\//g,"_")}function F(e){return e.replace(/-/g,"+").replace(/_/g,"/")}function G(e){var r=String.fromCharCode.apply(null,new Uint8Array(e));return M(btoa(r))}"use strict";function J(e){let r={Name:e};r.Genus=f(e),r.Family=k(e),r.Hash=c(e),r.HashSize=E(e);try{r.Curve=w(e)}catch(t){}try{r.Use=K(e),r.SigSize=N(e)}catch(t){}return r}function f(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("coze_enum.Genus: unsupported algorithm for genus")}}function k(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("coze_enum.Family: unsupported algorithm for family")}}function c(e){switch(e){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("coze_enum.HashAlg: unsupported algorithm for HashAlg")}}function E(e){let r=c(e);switch(r!=e&&(e=r),e){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("coze_enum.HashSize: unsupported algorithm for hash size")}}function N(e){switch(e){case"ES224":return 56;case"ES256":case"Ed25519":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("coze_enum.SigSize: unsupported algorithm for sig size")}}function w(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("coze_enum.Curve: unsupported algorithm for curve")}}function K(e){switch(e){case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed448":return"sig";default:throw new Error("coze_enum.Use: unsupported algorithm for use")}}"use strict";var i={New:async function(e){if(o(e)&&(e="ES256"),f(e)!=="ECDSA"||e=="ES224"||e=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm.");return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:w(e)},!0,["sign","verify"])},FromCozeKey:async function(e){if(f(e.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+e.alg);var r={};if(r.use="sig",r.x=await h(e.x),r.y=await h(e.y),r.crv=w(e.alg),r.kty="EC",o(e.d))var t="verify";else t="sign",r.d=await h(e.d);var a=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv},!0,[t]);return a},FromCozeKeyToPublic:async function(e){let r={...e};return delete r.d,i.FromCozeKey(r)},ToPublic:async function(e){let r={...e};return delete r.d,r.key_ops=["verify"],r},ToCozeKey:async function(e){let r=await window.crypto.subtle.exportKey("jwk",e);var t={};if(r.kty!="EC")throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.");switch(r.crv){case"P-256":t.alg="ES256";break;case"P-384":t.alg="ES384";break;case"P-521":t.alg="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return t.x=g(r.x),r.hasOwnProperty("d")&&(t.d=g(r.d)),r.hasOwnProperty("y")&&(t.y=g(r.y)),t.tmb=await C(t),t},SignBuffer:async function(e,r){let t=await i.GetSignHashAlgoFromCryptoKey(e);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:t}},e,r)},SignBufferToHex:async function(e,r){let t=await i.SignBuffer(e,r);return await y(t)},SignString:async function(e,r){let t=await u(r);return await i.SignBufferToHex(e,t)},VerifyABMsgSig:async function(e,r,t){let a=await i.GetSignHashAlgoFromCryptoKey(e);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:a}},e,t,r)},VerifyMsgHexSig:async function(e,r,t){return t=await l(t),r=await u(r),i.VerifyABMsgSig(e,r,t)},GetSignHashAlgoFromCryptoKey:async function(e){let r=await i.ToCozeKey(e);return await c(r.alg)}};"use strict";var V=["alg","x","y"],U=["alg","x"];async function I(e){if(o(e)&&(e="ES256"),f(e)=="ECDSA")var r=await i.New(e);else throw new Error("CozeKey.NewCozeKey: only ECDSA algs are currently supported.");let t=await i.ToCozeKey(r.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await C(t),t.kid="My Cyphr.me Key.",t}async function R(e,r,t){let a=await u(r),n=await u(t),s=await i.FromCozeKeyToPublic(e);return await i.VerifyABMsgSig(s,a,n)}async function C(e){if(o(e.alg))throw new Error("CozeKey.Thumbprint: alg is empty.");if(f(e.alg)!="ECDSA"&&e.alg!="Ed25519")throw new Error("CozeKey.Thumbprint: unsupported alg.");if(o(e.x))throw new Error("CozeKey.Thumbprint: x is empty.");if(f(e.alg)=="ECDSA"&&o(e.y))throw new Error("CozeKey.Thumbprint: y is empty.");let r={};f(e.alg)=="ECDSA"&&(r=V),f(e.alg)=="EdDSA"&&(r=U);let t=await c(e.alg);return T(e,t,r)}async function Z(e){try{if(o(e.d))throw"Private Coze key is missing private component 'd'";return await H(e)}catch(r){}return!1}async function H(e){let r=["alg","iat","tmb","x"];for(let a of r)if(!(a in e))throw new Error("CozeKey.Correct: No '"+a+"' in Coze key");if(e.iat>Math.round(Date.now()/1e3))throw new Error("CozeKey.Correct: cannot have iat greater than present time");if(e.alg=="Ed25519"&&e.x.length<64)throw new Error("CozeKey.Correct: x is too short.  Has length: "+e.x.length);if(f(e.alg)=="ECDSA"){let a=E(c(e.alg))*2;if(e.x.length<a)throw new Error("CozeKey.Correct: x is too short.  Has length: "+e.x.length);if(e.y.length<a)throw new Error("CozeKey.Correct: y is too short.  Has length: "+e.y.length)}let t=await C(e);if(t!=e.tmb)throw new Error("CozeKey.Correct: tmb does not match: "+t);if(!o(e.d)){let a="Test Signing",n=await i.FromCozeKey(e),s=await u(a),p=await i.SignBuffer(n,s),_=await i.FromCozeKeyToPublic(e);if(await i.VerifyABMsgSig(_,s,p)!==!0)throw new Error("CozeKey.Correct: private key invalid.")}return!0}async function L(e){var r={};if(r.alg=e.alg,e.iat>9007199254740991)throw"Coze.Normal: `iat` too large";if(r.iat=e.iat,o(e.kid)||(r.kid=e.kid.substring(0,50)),r.x=e.x,f(e.alg)=="ECDSA"&&(r.y=e.y),!H(r))throw new Error("CozeKey.Normal: Coze key not correct");return r}async function B(e){let r={};switch(r.alg=e.alg,r.iat=e.iat,o(e.kid)||(r.kid=e.kid),r.x=e.x,f(r.alg)){case"ECDSA":r.y=e.y;break;case"EdDSA":break;default:throw new Error("CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):"+r.alg)}return r.tmb=await C(r),r=await S(r),r}async function q(e,r){if(o(e))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");o(e.tmb)&&(e.tmb=await CZK.Thumbprint(e));var t={};t.head={},o(r)||(t.head.msg=r),t.head.rvk=Math.round(Date.now()/1e3),t.head.typ="cyphr.me/key/revoke";let a=e.rvk;return delete e.rvk,t=await d(t,e),a!==void 0&&(e.rvk=a),t}function b(e){return o(e.rvk)?!1:parseInt(e.rvk)>0||e.rvk===!0||e.rvk.toLowerCase()==="true"}"use strict";var Q=["alg","iat","tmb","typ"],W=["alg","iat","msg","tmb","typ"];async function X(e,r,t){return e=await j(e,r,t),z(e,r)}async function d(e,r,t){let a={};return a.head=await j(e.head,r,t),a.sig=await z(a.head,r),a}async function j(e,r,t){if(o(r))throw new Error("Coze: Key not set. ");if(b(r))throw new Error("Coze: Cannot sign with revoked key.");return e.alg=r.alg,e.tmb=await C(r),e.iat=Math.round(Date.now()/1e3),S(e,t)}async function z(e,r){return i.SignBufferToHex(await i.FromCozeKey(r),await u(JSON.stringify(e)))}async function Y(e,r,t){return i.VerifyABMsgSig(await i.FromCozeKeyToPublic(r),await u(await m(e)),await l(t))}async function v(e,r,t){let a=await D(e,r,t);return i.VerifyABMsgSig(await i.FromCozeKeyToPublic(a.key),await u(await m(a.head,a.can)),await l(a.sig))}async function $(e,r){if(!Array.isArray(e))return v(e,r);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedObjs:[]};let a=[...e];for(let n=0;n<a.length;n++){let s=a[n];o(s.cy)||(s=s.cy),o(s.key)&&s.head.tmb==r.tmb&&(s.key=r),await v(s)?t.VerifiedCount++:(t.FailedCount++,t.FailedObjs.push(a))}return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function D(e,r,t){if(Array.isArray(e))throw new Error("Coze.GetCyParts: Cy cannot be array.");let a={};typeof e=="string"?a=JSON.parse(e):a={...e},o(a.cy)||(a=a.cy);var n={};if(n.head=a.head,o(n.head))throw new Error("Coze.GetCyParts: A head is not set.");if(o(r)?n.key=a.key:n.key=await B(r),o(n.key))throw new Error("Coze.GetCyParts: A public key is not set.");if(o(t)||(n.sig=t),o(a.sig)||(n.sig=a.sig),o(n.sig))throw new Error("Coze.GetCyParts: A sig is not set.");if(o(n.head.tmb)?o(n.key.tmb)||(n.tmb=n.key.tmb):n.tmb=n.head.tmb,n.tmb!=n.key.tmb)throw new Error("Coze.GetCyParts: `head.tmb` does not match key's `tmb`.");o(a.can)?n.can=await x(n.head):n.can=a.can,n.cad=await y(await A(a.head,c(a.head.alg),a.can));let s='{"cad":"'+n.cad+'","sig":"'+n.sig+'"}',p=await crypto.subtle.digest(c(n.head.alg),await u(s));return n.cyd=await y(p),n}function o(e){return typeof e=="function"?!1:e===Object(e)?Object.keys(e).length===0:!P(e)}function P(e){return!(e===!1||e==="false"||e===void 0||e==="undefined"||e===""||e===0||e==="0"||e===null||e==="null"||e==="NaN"||Number.isNaN(e)||e===Object(e))}"use strict";async function S(e,r){let t=[];typeof r=="object"&&(t=Object.keys(r)),!r||r.length===0?t=Object.keys(e):t=r,t.sort();let a={};for(let n of t)a[n]=e[n];return a}async function m(e,r){return JSON.stringify(await S(e,r))}function x(e){let r=Object.keys(e);return r.sort(),r}async function A(e,r,t){typeof e=="string"&&(e=JSON.parse(e));let a=await m(e,t);o(r)&&(r="SHA-256");let n=await u(a);return n=await crypto.subtle.digest(r,n),n}async function T(e,r,t){let a=await A(e,r,t);return await y(a)}export{y as ArrayBufferToHex,A as CH,T as CHH,S as Canon,m as Canons,H as Correct,i as CryptoKey,w as Curve,V as ECDSATmbCanon,U as EdDSATmbCanon,k as Family,x as GenCanon,f as Genus,D as GetCyParts,c as HashAlg,E as HashSize,Q as HeadCanon,l as HexToArrayBuffer,b as IsRevoked,W as MsgCanon,I as NewCozeKey,L as Normal,J as Params,q as Revoke,u as SToArrayBuffer,N as SigSize,X as Sign,d as SignCy,C as Thumbprint,B as ToPublicCozeKey,K as Use,Z as Valid,Y as Verify,v as VerifyCy,$ as VerifyCyArray,R as VerifyMsg,P as isBool,o as isEmpty};
//# sourceMappingURL=coze.min.js.map
