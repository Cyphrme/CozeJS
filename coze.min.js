function T(r){let e={Name:r,B64:{}};e.Genus=y(r),e.Family=P(r),e.Hash=u(r),e.HashSize=N(r),e.B64.HashSize=Math.ceil(4*e.HashSize/3);try{e.Curve=m(r),e.Use=j(r),e.SigSize=V(r),e.XSize=g(r),e.DSize=U(r),e.B64.SigSize=Math.ceil(4*e.SigSize/3),e.B64.XSize=Math.ceil(4*e.XSize/3),e.B64.DSize=Math.ceil(4*e.DSize/3)}catch{}return e}function y(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed25519ph":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function P(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function u(r){switch(r){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":case"Ed25519ph":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function N(r){let e=u(r);switch(e!=r&&(r=e),r){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function V(r){switch(r){case"ES224":return 56;case"ES256":case"Ed25519":case"Ed25519ph":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function g(r){switch(r){case"Ed25519":case"Ed25519ph":return 32;case"ES224":return 56;case"Ed448":return 57;case"ES256":return 64;case"ES384":return 96;case"ES512":return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function U(r){switch(r){case"ES224":return 28;case"ES256":case"Ed25519":case"Ed25519ph":return 32;case"ES384":return 48;case"Ed448":return 57;case"ES512":return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function m(r){switch(r){case"ES224":return"P-224";case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":case"Ed25519ph":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function j(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"sig";default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var i={New:async function(r){if(a(r)&&(r="ES256"),y(r)!=="ECDSA"||r=="ES224"||r=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm:"+r);return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:m(r)},!0,["sign","verify"])},FromCozeKey:async function(r,e){if(y(r.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var t={};t.use="sig",t.crv=m(r.alg),t.kty="EC";let n=g(r.alg)/2,s=await w(r.x),o=s.slice(0,n),S=s.slice(n);if(t.x=await c(o),t.y=await c(S),a(r.d)||e)var p="verify";else p="sign",t.d=r.d;var A=await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv},!0,[p]);return A},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let e=await window.crypto.subtle.exportKey("jwk",r);var t={};t.alg=await i.algFromCrv(e.crv);let n=w(e.x),s=w(e.y);var o=new Uint8Array([...n,...s]);return t.x=c(o.buffer),e.hasOwnProperty("d")&&(t.d=e.d),t.tmb=await l(t),t},SignBuffer:async function(r,e){let t=await i.GetSignHashAlgoFromCryptoKey(r);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:t}},r,e)},SignBufferB64:async function(r,e){return await c(await i.SignBuffer(r,e))},SignString:async function(r,e){return await i.SignBufferB64(r,await f(e))},VerifyArrayBuffer:async function(r,e,t){return await i.ToPublic(r),await window.crypto.subtle.verify({name:"ECDSA",hash:{name:await i.GetSignHashAlgoFromCryptoKey(r)}},r,t,e)},VerifyMsg:async function(r,e,t){return i.VerifyArrayBuffer(r,await f(e),await z(t))},GetSignHashAlgoFromCryptoKey:async function(r){return u(await i.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case"P-224":var e="ES224";break;case"P-256":e="ES256";break;case"P-384":e="ES384";break;case"P-521":e="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return e}};var O=["alg","x"];async function _(r){if(a(r)&&(r="ES256"),y(r)=="ECDSA")var e=await i.New(r);else throw new Error("CozeKey.NewCozeKey: only ECDSA algs are currently supported.");let t=await i.ToCozeKey(e.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await l(t),t.kid="My Cyphr.me Key.",t}async function l(r){if(a(r.alg)||a(r.x))throw new Error("CozeKey.Thumbprint: alg or x is empty.");return C(r,await u(r.alg),O)}async function J(r){if(a(r.d))return console.error("Coze key missing `d`"),!1;try{let e="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",t=await E(e,r);return await b(e,r,t)}catch(e){console.error(e)}return!1}async function Z(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(a(r.alg))return console.error("Correct: Alg must be set"),!1;let e=T(r.alg),t=a(r.tmb),n=a(r.x),s=a(r.d);if(t&&n&&s)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(n&&s)return t||r.tmb.length!==e.B64.HashSize?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!n&&r.x.length!==e.B64.XSize)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!t&&!n){let o=await l(r);if(r.tmb!==o)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!s&&!n){let o=await i.FromCozeKey(r),S=await f("Test Signing"),p=await i.SignBuffer(o,S),A=await i.FromCozeKey(r,!0);if(!await i.VerifyArrayBuffer(A,S,p))return console.error("Correct: private key invalid."),!1}return!0}async function W(r,e){if(a(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var t={};t.pay={},a(e)||(t.pay.msg=e),t.pay.rvk=Math.round(Date.now()/1e3);let n=r.rvk;return delete r.rvk,t=await k(t,r),n!==void 0?r.rvk=n:r.rvk=t.pay.rvk,t}function v(r){return!(a(r.rvk)||!(parseInt(r.rvk)>0))}var Y=["alg","iat","tmb","typ"];async function E(r,e){return i.SignBufferB64(await i.FromCozeKey(e),await f(r))}async function k(r,e,t){if(v(e))throw new Error("Coze: Cannot sign with revoked key.");if(a(r.pay.alg)&&(r.pay.alg=e.alg),a(r.pay.tmb)&&(r.pay.tmb=await l(e)),r.pay.alg!==e.alg)throw new Error("SignCoze: Coze key alg mismatch with coze.pay.alg.");if(r.pay.tmb!==e.tmb)throw new Error("SignCoze: Coze key tmb mismatch with coze.pay.tmb.");return r.pay.iat=Math.round(Date.now()/1e3),a(t)||(r.pay=await h(r.pay,t)),r.sig=await E(await JSON.stringify(r.pay),e),r}async function q(r,e,t){if(v(e))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!a(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!a(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return a(t)||(r.pay=await h(r.pay,t)),r.sig=await E(await JSON.stringify(r.pay),e),r}async function b(r,e,t){return i.VerifyMsg(await i.FromCozeKey(e,!0),r,t)}async function D(r,e){if(!a(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("Coze: Coze key alg mismatch with coze.pay.alg.");if(!a(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("Coze: Coze key tmb mismatch with coze.pay.tmb.");return b(JSON.stringify(r.pay),e,r.sig)}async function L(r,e){if(!Array.isArray(r))return D(r,e);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCoze:[]};let n=[...r];for(let s=0;s<n.length;s++){let o=n[s];a(o.coze)||(o=o.coze),await D(o,e)?t.VerifiedCount++:(t.FailedCount++,t.FailedCoze.push(n))}return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function $(r,e){return a(r.pay.alg)?e=u(e):e=u(r.pay.alg),r.can=await F(r.pay),r.cad=await C(r.pay,e),r.czd=await C({cad:r.cad,sig:r.sig},e),r}async function f(r){var e=new TextEncoder;return e.encode(r).buffer}function z(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0)).buffer}function w(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0))}function c(r){var e=String.fromCharCode.apply(null,new Uint8Array(r));return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function a(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!G(r)}function G(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function F(r){return Object.keys(r)}async function h(r,e){if(a(e))return;let t={};for(let n of e)t[n]=r[n];return t}async function M(r,e){return JSON.stringify(await h(r,e))}async function R(r,e,t){if(a(e))throw"Hash is not given";return typeof r=="string"&&(r=JSON.parse(r)),await crypto.subtle.digest(e,await f(await M(r,t)))}async function C(r,e,t){return await c(await R(r,e,t))}export{c as ArrayBufferTo64ut,z as B64uToArrayBuffer,w as B64utToUint8Array,F as Canon,h as Canonical,R as CanonicalHash,C as CanonicalHash64,M as CanonicalS,Z as Correct,i as CryptoKey,m as Curve,U as DSize,P as Family,y as Genus,u as HashAlg,N as HashSize,v as IsRevoked,$ as Meta,_ as NewCozeKey,T as Params,Y as PayCanon,W as Revoke,f as SToArrayBuffer,V as SigSize,E as Sign,k as SignCoze,q as SignCozeRaw,l as Thumbprint,O as TmbCanon,j as Use,J as Valid,b as Verify,D as VerifyCoze,L as VerifyCozeArray,g as XSize,G as isBool,a as isEmpty};
//# sourceMappingURL=coze.min.js.map
