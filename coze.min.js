var t={UnknownAlg:"UnknownAlg",ES224:"ES224",ES256:"ES256",ES384:"ES384",ES512:"ES512",Ed25519:"Ed25519",Ed25519ph:"Ed25519ph",Ed448:"Ed448",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512",SHA3224:"SHA3-224",SHA3256:"SHA3-256",SHA3384:"SHA3-384",SHA3512:"SHA3-512",SHAKE128:"SHAKE128",SHAKE256:"SHAKE256"},d={EC:"EC",SHA:"SHA",RSA:"RSA"},o={ECDSA:"ECDSA",EdDSA:"EdDSA",SHA2:"SHA2",SHA3:"SHA3"},u={P224:"P-224",P256:"P-256",P384:"P-384",P521:"P-521",Curve25519:"Curve25519",Curve448:"Curve448"},H={Sig:"sig",Enc:"enc",Hsh:"hsh"};function P(r){let e={};e.Name=r,e.Genus=F(r),e.Family=X(r),e.Use=J(r),e.Hash=c(r),e.HashSize=Z(r),e.HashSizeB64=Math.ceil(4*e.HashSize/3);try{e.XSize=T(r),e.XSizeB64=Math.ceil(4*e.XSize/3),e.DSize=_(r),e.DSizeB64=Math.ceil(4*e.DSize/3),e.Curve=v(r),e.SigSize=C(r),e.SigSizeB64=Math.ceil(4*e.SigSize/3)}catch{}return e}function F(r){switch(r){case t.ES224:case t.ES256:case t.ES384:case t.ES512:return o.ECDSA;case t.Ed25519:case t.Ed25519ph:case t.Ed448:return o.EdDSA;case t.SHA224:case t.SHA256:case t.SHA384:case t.SHA512:return o.SHA2;case t.SHA3224:case t.SHA3256:case t.SHA3384:case t.SHA3512:case t.SHAKE128:case t.SHAKE256:return o.SHA3;default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function X(r){switch(r){case t.ES224:case t.ES256:case t.ES384:case t.ES512:case t.Ed25519:case t.Ed25519ph:case t.Ed448:return d.EC;case t.SHA224:case t.SHA256:case t.SHA384:case t.SHA512:case t.SHA3224:case t.SHA3256:case t.SHA3384:case t.SHA3512:case t.SHAKE128:case t.SHAKE256:return d.SHA;default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function c(r){switch(r){case t.ES224:case t.SHA224:return t.SHA224;case t.SHA256:case t.ES256:return t.SHA256;case t.SHA384:case t.ES384:return t.SHA384;case t.SHA512:case t.ES512:case t.Ed25519:case t.Ed25519ph:return t.SHA512;case t.SHAKE128:return t.SHAKE128;case t.SHAKE256:case t.Ed448:return t.SHAKE256;case t.SHA3224:return t.SHA3224;case t.SHA3256:return t.SHA3256;case t.SHA3384:return t.SHA3384;case t.SHA3512:return t.SHA3512;default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function Z(r){switch(c(r)){case t.SHA224:case t.SHA3224:return 28;case t.SHA256:case t.SHA3256:case t.SHAKE128:return 32;case t.SHA384:case t.SHA3384:return 48;case t.SHA512:case t.SHA3512:case t.SHAKE256:return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function C(r){switch(r){case t.ES224:return 56;case t.ES256:case t.Ed25519:case t.Ed25519ph:return 64;case t.ES384:return 96;case t.Ed448:return 114;case t.ES512:return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function T(r){switch(r){case t.Ed25519:case t.Ed25519ph:return 32;case t.ES224:return 56;case t.Ed448:return 57;case t.ES256:return 64;case t.ES384:return 96;case t.ES512:return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function _(r){switch(r){case t.ES224:return 28;case t.ES256:case t.Ed25519:case t.Ed25519ph:return 32;case t.ES384:return 48;case t.Ed448:return 57;case t.ES512:return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function v(r){switch(r){default:throw new Error("alg.Curve: unsupported algorithm: "+r);case t.ES224:return u.P224;case t.ES256:return u.P256;case t.ES384:return u.P384;case t.ES512:return u.P521;case t.Ed25519:case t.Ed25519ph:return u.Curve25519;case t.Ed448:return u.Curve448}}function J(r){switch(F(r)){default:throw new Error("alg.Use: unsupported algorithm: "+r);case o.EdDSA:case o.ECDSA:return H.Sig;case o.SHA2:case o.SHA3:return H.Hsh}}var E={ES224:BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D"),ES256:BigInt("0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551"),ES384:BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973"),ES512:BigInt("0x1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409")},W={ES224:E.ES224>>BigInt(1),ES256:E.ES256>>BigInt(1),ES384:E.ES384>>BigInt(1),ES512:E.ES512>>BigInt(1)};function I(r){switch(r){default:throw new Error("CurveOrder: unsupported curve: "+r);case"ES224":case"ES256":case"ES384":case"ES512":return E[r]}}function z(r){switch(r){default:throw new Error("CurveHalfOrder: unsupported curve: "+r);case"ES224":case"ES256":case"ES384":case"ES512":return W[r]}}var s={New:async function(r){switch(i(r)&&(r=t.ES256),r){case t.ES256:case t.ES384:case t.ES512:return await window.crypto.subtle.generateKey({name:o.ECDSA,namedCurve:v(r)},!0,["sign","verify"]);default:throw new Error("CryptoKey.New: Unsupported key algorithm:"+r)}},FromCozeKey:async function(r,e){if(F(r.alg)!=o.ECDSA)throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var a={};a.use=H.Sig,a.crv=v(r.alg),a.kty=d.EC;let n=T(r.alg)/2,f=await w(r.x);if(a.x=await l(f.slice(0,n)),a.y=await l(f.slice(n)),i(r.d)||e)var S="verify";else S="sign",a.d=r.d;return await crypto.subtle.importKey("jwk",a,{name:o.ECDSA,namedCurve:a.crv},!0,[S])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let e=await window.crypto.subtle.exportKey("jwk",r);var a={};a.alg=await s.algFromCrv(e.crv);let n=w(e.x),f=w(e.y);var S=new Uint8Array([...n,...f]);return a.x=l(S.buffer),e.hasOwnProperty("d")&&(a.d=e.d),a.tmb=await y(a),a},SignBuffer:async function(r,e){let a=await s.algFromCrv(r.algorithm.namedCurve),n=await window.crypto.subtle.sign({name:o.ECDSA,hash:{name:c(a)}},r,e);return n=N(a,n),n},SignBufferB64:async function(r,e){return await l(await s.SignBuffer(r,e))},SignString:async function(r,e){return await s.SignBufferB64(r,await A(e))},VerifyArrayBuffer:async function(r,e,a,n){return await Y(r,n)?(await s.ToPublic(e),await window.crypto.subtle.verify({name:o.ECDSA,hash:{name:await s.GetSignHashAlgoFromCryptoKey(e)}},e,n,a)):!1},VerifyMsg:async function(r,e,a,n){return s.VerifyArrayBuffer(r,e,await A(a),await D(n))},GetSignHashAlgoFromCryptoKey:async function(r){return c(await s.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case u.P224:var e=t.ES224;break;case u.P256:e=t.ES256;break;case u.P384:e=t.ES384;break;case u.P521:e=t.ES512;break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return e}};function U(r,e){if(typeof e!="bigint")throw new Error("IsLowS: s is not of type bigint");return z(r)>e}function Q(r,e){if(typeof e!="bigint")throw new Error("toLowS: s is not of type bigint");return U(r,e)?e:I(r)-e}async function sr(r,e){let a=await D(e),n=await N(r,a);return l(n)}async function Y(r,e){let a=await q(r,e);return U(r,a)}function q(r,e){let a=C(r)/2,n=e.slice(a);return O(n)}async function N(r,e){let a=C(r)/2,n=e.slice(0,a),f=e.slice(a),S=O(f),m=Q(r,S),h=$(C(r)/2,m);var g=new Uint8Array(n.byteLength+h.byteLength);return g.set(new Uint8Array(n),0),g.set(new Uint8Array(h),n.byteLength),e=g.buffer,e}function O(r){let e=0n,a=new Uint8Array(r);for(let n=0;n<a.length;n++)e=(e<<8n)+BigInt(a[n]);return e}function $(r,e){let a=new ArrayBuffer(r),n=new DataView(a);do r--,n.setUint8(r,Number(e&BigInt(255))),e>>=8n;while(r>0);return a}var rr=["alg","x"];async function ur(r){if(i(r)&&(r=t.ES256),F(r)==o.ECDSA)var e=await s.New(r);else throw new Error("Coze.NewKey: only ECDSA algs are currently supported.");let a=await s.ToCozeKey(e.privateKey);return a.iat=Math.floor(Date.now()/1e3),a.tmb=await y(a),a.kid="My Cyphr.me Key.",a}async function y(r){if(i(r.alg)||i(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return p(r,await c(r.alg),rr)}async function fr(r){if(i(r.d))return console.error("Coze key missing `d`"),!1;try{let e="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",a=await B(e,r);return k(e,r,a)}catch{return!1}}async function Sr(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(i(r.alg))return console.error("Correct: Alg must be set"),!1;let e=P(r.alg),a=i(r.tmb),n=i(r.x),f=i(r.d);if(a&&n&&f)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(n&&f)return a||r.tmb.length!==e.HashSizeB64?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!n&&r.x.length!==e.XSizeB64)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!a&&!n){let S=await y(r);if(r.tmb!==S)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!f&&!n){let S=await s.FromCozeKey(r),m=await A("Test Signing"),h=await s.SignBuffer(S,m),g=await s.FromCozeKey(r,!0);if(!await s.VerifyArrayBuffer(r.alg,g,m,h))return console.error("Correct: private key invalid."),!1}return!0}async function cr(r,e){if(i(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var a={};a.pay={},i(e)||(a.pay.msg=e),a.pay.rvk=Math.round(Date.now()/1e3);let n=r.rvk;return delete r.rvk,a=await M(a,r),n!==void 0?r.rvk=n:r.rvk=a.pay.rvk,a}function x(r){return!(i(r.rvk)||!(parseInt(r.rvk)>0))}var lr=["alg","iat","tmb","typ"];async function M(r,e,a){if(x(e))throw new Error("SignCoze: Cannot sign with revoked key.");return r.pay.alg=e.alg,r.pay.tmb=await y(e),r.pay.iat=Math.round(Date.now()/1e3),i(a)||(r.pay=await b(r.pay,a)),r.sig=await B(JSON.stringify(r.pay),e),r}async function B(r,e){return s.SignBufferB64(await s.FromCozeKey(e),await A(r))}async function Ar(r,e,a){if(x(e))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!i(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!i(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return i(a)||(r.pay=await b(r.pay,a)),r.sig=await B(JSON.stringify(r.pay),e),r}async function Fr(r,e){if(!i(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("VerifyCoze: Coze key alg mismatch with coze.pay.alg.");if(!i(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("VerifyCoze: Coze key tmb mismatch with coze.pay.tmb.");return k(JSON.stringify(r.pay),e,r.sig)}async function k(r,e,a){return s.VerifyMsg(e.alg,await s.FromCozeKey(e,!0),r,a)}async function yr(r,e){if(i(r.pay.alg))a=c(e);else var a=c(r.pay.alg);return r.can=await L(r.pay),r.cad=await p(r.pay,a),i(r.sig)||(r.czd=await p({cad:r.cad,sig:r.sig},a)),r}async function A(r){return new TextEncoder().encode(r).buffer}function D(r){return w(r).buffer}function w(r){if(r=r.replace(/-/g,"+").replace(/_/g,"/"),btoa(atob(r)).replace(/=/g,"")!==r)throw new Error("Non-canonical base64 string");return Uint8Array.from(atob(r),a=>a.charCodeAt(0))}function l(r){return btoa(String.fromCharCode.apply(null,new Uint8Array(r))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function i(r){return typeof r=="function"?!1:Array.isArray(r)&&r.length==0?!0:r===Object(r)?Object.keys(r).length===0:!er(r)}function er(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function L(r){return Object.keys(r)}async function b(r,e){if(i(e))return r;let a={};for(let n of e)a[n]=r[n];return a}async function tr(r,e){return JSON.stringify(await b(r,e))}async function ar(r,e,a){if(i(e))throw new Error("Hash is not given");return await crypto.subtle.digest(e,await A(await tr(r,a)))}async function p(r,e,a){return await l(await ar(r,e,a))}export{t as Algs,l as ArrayBufferTo64ut,w as B64ToUint8Array,D as B64uToArrayBuffer,L as Canon,b as Canonical,ar as CanonicalHash,p as CanonicalHash64,tr as CanonicalS,Sr as Correct,s as CryptoKey,v as Curve,z as CurveHalfOrder,I as CurveOrder,u as Curves,_ as DSize,d as FamAlgs,X as Family,o as GenAlgs,F as Genus,c as HashAlg,Z as HashSize,x as IsRevoked,Y as IsSigLowS,yr as Meta,ur as NewKey,P as Params,lr as PayCanon,cr as Revoke,A as SToArrayBuffer,C as SigSize,sr as SigToLowS,M as Sign,Ar as SignCozeRaw,B as SignPay,y as Thumbprint,rr as TmbCanon,J as Use,H as Uses,fr as Valid,Fr as Verify,k as VerifyPay,T as XSize,i as isEmpty};
//# sourceMappingURL=coze.min.js.map
