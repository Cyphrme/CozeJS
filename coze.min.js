function R(e){let r={Name:e};r.Genus=y(e),r.Family=N(e),r.Hash=u(e),r.HashSize=A(e);try{r.Curve=w(e),r.Use=j(e),r.SigSize=O(e),r.XSize=d(e),r.DSize=V(e)}catch{}return r}function y(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed25519ph":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("alg.Genus: unsupported algorithm: "+e)}}function N(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("alg.Family:  unsupported algorithm: "+e)}}function u(e){switch(e){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":case"Ed25519ph":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("alg.HashAlg:  unsupported algorithm: "+e)}}function A(e){let r=u(e);switch(r!=e&&(e=r),e){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+e)}}function O(e){switch(e){case"ES224":return 56;case"ES256":case"Ed25519":case"Ed25519ph":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+e)}}function d(e){switch(e){case"Ed25519":case"Ed25519ph":return 32;case"ES224":return 56;case"Ed448":return 57;case"ES256":return 64;case"ES384":return 96;case"ES512":return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+e)}}function V(e){switch(e){case"ES224":return 28;case"ES256":case"Ed25519":case"Ed25519ph":return 32;case"ES384":return 48;case"Ed448":return 57;case"ES512":return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+e)}}function w(e){switch(e){case"ES224":return"P-224";case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":case"Ed25519ph":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("alg.Curve: unsupported algorithm: "+e)}}function j(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"sig";default:throw new Error("alg.Use: unsupported algorithm: "+e)}}var i={New:async function(e){if(n(e)&&(e="ES256"),y(e)!=="ECDSA"||e=="ES224"||e=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm:"+e);return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:w(e)},!0,["sign","verify"])},FromCozeKey:async function(e,r){if(y(e.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+e.alg);var t={};t.use="sig",t.crv=w(e.alg),t.kty="EC";let a=d(e.alg)/2,o=await p(e.x),s=o.slice(0,a),C=o.slice(a);if(t.x=await f(s),t.y=await f(C),n(e.d)||r)var S="verify";else S="sign",t.d=e.d;var h=await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv},!0,[S]);return h},ToPublic:async function(e){delete e.d,e.key_ops=["verify"]},ToCozeKey:async function(e){let r=await window.crypto.subtle.exportKey("jwk",e);var t={};t.alg=await i.algFromCrv(r.crv);let a=p(r.x),o=p(r.y);var s=new Uint8Array([...a,...o]);return t.x=f(s.buffer),r.hasOwnProperty("d")&&(t.d=r.d),t.tmb=await l(t),t},SignBuffer:async function(e,r){let t=await i.GetSignHashAlgoFromCryptoKey(e);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:t}},e,r)},SignBufferB64:async function(e,r){return await f(await i.SignBuffer(e,r))},SignString:async function(e,r){return await i.SignBufferB64(e,await c(r))},VerifyArrayBuffer:async function(e,r,t){await i.ToPublic(e);let a=await i.GetSignHashAlgoFromCryptoKey(e);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:a}},e,t,r)},VerifyMsg:async function(e,r,t){let a=await c(r),o=await k(t);return i.VerifyArrayBuffer(e,a,o)},GetSignHashAlgoFromCryptoKey:async function(e){return u(await i.algFromCrv(e.algorithm.namedCurve))},algFromCrv:async function(e){switch(e){case"P-224":var r="ES224";break;case"P-256":r="ES256";break;case"P-384":r="ES384";break;case"P-521":r="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return r}};var U=["alg","x"];async function W(e){if(n(e)&&(e="ES256"),y(e)=="ECDSA")var r=await i.New(e);else throw new Error("CozeKey.NewCozeKey: only ECDSA algs are currently supported.");let t=await i.ToCozeKey(r.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await l(t),t.kid="My Cyphr.me Key.",t}async function l(e){if(n(e.alg)||n(e.x))throw new Error("CozeKey.Thumbprint: alg or x  is empty.");return D(e,await u(e.alg),U)}async function X(e){if(n(e.d))return console.error("Coze key missing `d`"),!1;try{let r="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",t=await H(r,e);return await K(r,e,t)}catch(r){console.error(r)}return!1}async function Z(e){let r=["alg","tmb"];if(n(e)||typeof e!="object",Object.keys(e).length>=2&&!n(e.alg)&&!n(e.tmb)&&(n(e.x)||n(e.iat)))return!0;let t=IsTmbOnly(cozeKey);t||(console.debug("not a tmb only key"),r.push(["iat","x"]));for(let o of r)if(!(o in cozeKey))throw new Error("CozeKey.Correct: No '"+o+"' in Coze key");if(cozeKey.alg=="Ed25519"&&cozeKey.x.length<64)throw new Error("CozeKey.Correct: x is too short.  Has length: "+cozeKey.x.length);if(t)return!0;if(cozeKey.iat>Math.round(Date.now()/1e3))throw new Error("CozeKey.Correct: cannot have iat greater than present time");if(y(cozeKey.alg)=="ECDSA"){let o=A(u(cozeKey.alg))*2;if(cozeKey.x.length<o)throw new Error("CozeKey.Correct: x is too short.  Has length: "+cozeKey.x.length);if(cozeKey.y.length<o)throw new Error("CozeKey.Correct: y is too short.  Has length: "+cozeKey.y.length)}let a=await l(cozeKey);if(a!=cozeKey.tmb)throw new Error("CozeKey.Correct: tmb does not match: "+a);if(!n(cozeKey.d)){let o="Test Signing",s=await i.FromCozeKey(cozeKey),C=await c(o),S=await i.SignBuffer(s,C),h=await i.FromCozeKey(cozeKey,!0);if(await i.VerifyArrayBuffer(h,C,S)!==!0)throw new Error("CozeKey.Correct: private key invalid.")}return!0}async function Q(e){let r={};switch(r.alg=e.alg,r.iat=e.iat,n(e.kid)||(r.kid=e.kid),r.x=e.x,y(r.alg)){case"ECDSA":r.y=e.y;break;case"EdDSA":break;default:throw new Error("CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):"+r.alg)}return r.tmb=await l(r),r=await m(r),r}async function q(e,r){if(n(e))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var t={};t.pay={},n(r)||(t.pay.msg=r),t.pay.rvk=Math.round(Date.now()/1e3);let a=e.rvk;return delete e.rvk,t=await x(t,e),a!==void 0?e.rvk=a:e.rvk=t.pay.rvk,t}function B(e){return!(n(e.rvk)||!(parseInt(e.rvk)>0))}var Y=["alg","iat","tmb","typ"];async function H(e,r){let t=await i.FromCozeKey(r);return i.SignBufferB64(t,await c(e))}async function x(e,r,t){if(B(r))throw new Error("Coze: Cannot sign with revoked key.");e.pay.alg=r.alg,e.pay.iat=Math.round(Date.now()/1e3),e.pay.tmb=await l(r),n(t)||(e.pay=await z(e.pay,t));let a=await JSON.stringify(e.pay);return console.log(a),e.sig=await H(a,r),e}async function K(e,r,t){let a=await i.FromCozeKey(r,!0);return i.VerifyMsg(a,e,t)}async function P(e,r){if(e.pay.tmb!==r.tmb)throw new Error("Coze.VerifyCoze: pay.tmb does not match key.tmb.");let t=await JSON.stringify(e.pay);return K(t,r,e.sig)}async function L(e,r){if(!Array.isArray(e))return P(e,r);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCoze:[]};let a=[...e];for(let o=0;o<a.length;o++){let s=a[o];n(s.coze)||(s=s.coze),await P(s,r)?t.VerifiedCount++:(t.FailedCount++,t.FailedCoze.push(a))}return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function $(e){e.can=await m(e.pay),e.cad=await f(await b(e.pay,u(e.pay.alg)));let r=await c('{"cad":"'+e.cad+'","sig":"'+e.sig+'"}');return e.czd=await f(await crypto.subtle.digest(u(e.pay.alg),r)),e}async function c(e){var r=new TextEncoder;return r.encode(e).buffer}function k(e){return Uint8Array.from(atob(e.replace(/-/g,"+").replace(/_/g,"/")),r=>r.charCodeAt(0)).buffer}function p(e){return Uint8Array.from(atob(e.replace(/-/g,"+").replace(/_/g,"/")),r=>r.charCodeAt(0))}function f(e){var r=String.fromCharCode.apply(null,new Uint8Array(e));return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function n(e){return typeof e=="function"?!1:e===Object(e)?Object.keys(e).length===0:!G(e)}function G(e){return!(e===!1||e==="false"||e===void 0||e==="undefined"||e===""||e===0||e==="0"||e===null||e==="null"||e==="NaN"||Number.isNaN(e)||e===Object(e))}function m(e){return Object.keys(e)}async function z(e,r){let t=[];typeof r=="object"&&(t=Object.keys(r)),!r||r.length===0?t=Object.keys(e):t=r;let a={};for(let o of t)a[o]=e[o];return a}async function M(e,r){return JSON.stringify(await z(e,r))}async function b(e,r,t){n(r)&&(r="SHA-256"),typeof e=="string"&&(e=JSON.parse(e));let a=await c(await M(e,t));return await crypto.subtle.digest(r,a)}async function D(e,r,t){let a=await b(e,r,t);return await f(a)}export{f as ArrayBufferTo64ut,k as B64uToArrayBuffer,p as B64utToUint8Array,m as Canon,z as Canonical,b as CanonicalHash,D as CanonicalHash64,M as CanonicalS,Z as Correct,i as CryptoKey,w as Curve,V as DSize,N as Family,y as Genus,u as HashAlg,A as HashSize,B as IsRevoked,$ as Meta,W as NewCozeKey,R as Params,Y as PayCanon,q as Revoke,c as SToArrayBuffer,O as SigSize,H as Sign,x as SignCoze,l as Thumbprint,U as TmbCanon,Q as ToPublicCozeKey,j as Use,X as Valid,K as Verify,P as VerifyCoze,L as VerifyCozeArray,d as XSize,G as isBool,n as isEmpty};
//# sourceMappingURL=coze.min.js.map
