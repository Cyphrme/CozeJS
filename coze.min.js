function H(r){let e={Name:r,B64:{}};e.Genus=c(r),e.Family=P(r),e.Hash=u(r),e.HashSize=N(r),e.B64.HashSize=Math.ceil(4*e.HashSize/3),e.Use=j(r);try{e.SigSize=V(r),e.XSize=A(r),e.DSize=U(r),e.Curve=p(r),e.B64.SigSize=Math.ceil(4*e.SigSize/3),e.B64.XSize=Math.ceil(4*e.XSize/3),e.B64.DSize=Math.ceil(4*e.DSize/3)}catch{}return e}function c(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed25519ph":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function P(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function u(r){switch(r){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":case"Ed25519ph":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function N(r){switch(u(r)){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function V(r){switch(r){case"ES224":return 56;case"ES256":case"Ed25519":case"Ed25519ph":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function A(r){switch(r){case"Ed25519":case"Ed25519ph":return 32;case"ES224":return 56;case"Ed448":return 57;case"ES256":return 64;case"ES384":return 96;case"ES512":return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function U(r){switch(r){case"ES224":return 28;case"ES256":case"Ed25519":case"Ed25519ph":return 32;case"ES384":return 48;case"Ed448":return 57;case"ES512":return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function p(r){switch(r){case"ES224":return"P-224";case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":case"Ed25519ph":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function j(r){switch(c(r)){case"EdDSA":case"ECDSA":return"sig";case"SHA2":case"SHA3":return"dig";default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var n={New:async function(r){if(a(r)&&(r="ES256"),c(r)!=="ECDSA"||r=="ES224"||r=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm:"+r);return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:p(r)},!0,["sign","verify"])},FromCozeKey:async function(r,e){if(c(r.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var t={};t.use="sig",t.crv=p(r.alg),t.kty="EC";let i=A(r.alg)/2,s=await C(r.x);if(t.x=await y(s.slice(0,i)),t.y=await y(s.slice(i)),a(r.d)||e)var o="verify";else o="sign",t.d=r.d;return await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv},!0,[o])},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let e=await window.crypto.subtle.exportKey("jwk",r);var t={};t.alg=await n.algFromCrv(e.crv);let i=C(e.x),s=C(e.y);var o=new Uint8Array([...i,...s]);return t.x=y(o.buffer),e.hasOwnProperty("d")&&(t.d=e.d),t.tmb=await l(t),t},SignBuffer:async function(r,e){return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:await n.GetSignHashAlgoFromCryptoKey(r)}},r,e)},SignBufferB64:async function(r,e){return await y(await n.SignBuffer(r,e))},SignString:async function(r,e){return await n.SignBufferB64(r,await f(e))},VerifyArrayBuffer:async function(r,e,t){return await n.ToPublic(r),await window.crypto.subtle.verify({name:"ECDSA",hash:{name:await n.GetSignHashAlgoFromCryptoKey(r)}},r,t,e)},VerifyMsg:async function(r,e,t){return n.VerifyArrayBuffer(r,await f(e),await T(t))},GetSignHashAlgoFromCryptoKey:async function(r){return u(await n.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case"P-224":var e="ES224";break;case"P-256":e="ES256";break;case"P-384":e="ES384";break;case"P-521":e="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return e}};var G=["alg","x"];async function _(r){if(a(r)&&(r="ES256"),c(r)=="ECDSA")var e=await n.New(r);else throw new Error("Coze.NewKey: only ECDSA algs are currently supported.");let t=await n.ToCozeKey(e.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await l(t),t.kid="My Cyphr.me Key.",t}async function l(r){if(a(r.alg)||a(r.x))throw new Error("Coze.Thumbprint: alg or x is empty.");return S(r,await u(r.alg),G)}async function J(r){if(a(r.d))return console.error("Coze key missing `d`"),!1;try{let e="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",t=await w(e,r);return g(e,r,t)}catch(e){return console.log("Valid:"+e),!1}}async function W(r){if(typeof r!="object")return console.error("Correct: CozeKey must be passed in as an object."),!1;if(a(r.alg))return console.error("Correct: Alg must be set"),!1;let e=H(r.alg),t=a(r.tmb),i=a(r.x),s=a(r.d);if(t&&i&&s)return console.error("Correct: At least one of [x, tmb, d] must be set"),!1;if(i&&s)return t||r.tmb.length!==e.B64.HashSize?(console.error("Correct: Incorrect `tmb` size: ",r.tmb.length),!1):!0;if(!i&&r.x.length!==e.B64.XSize)return console.error("Correct: Incorrect x size: ",r.x.length),!1;if(!t&&!i){let o=await l(r);if(r.tmb!==o)return console.error("Correct: Incorrect given `tmb`: ",r.tmb),!1}if(!s&&!i){let o=await n.FromCozeKey(r),d=await f("Test Signing"),D=await n.SignBuffer(o,d),F=await n.FromCozeKey(r,!0);if(!await n.VerifyArrayBuffer(F,d,D))return console.error("Correct: private key invalid."),!1}return!0}async function Q(r,e){if(a(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var t={};t.pay={},a(e)||(t.pay.msg=e),t.pay.rvk=Math.round(Date.now()/1e3);let i=r.rvk;return delete r.rvk,t=await K(t,r),i!==void 0?r.rvk=i:r.rvk=t.pay.rvk,t}function h(r){return!(a(r.rvk)||!(parseInt(r.rvk)>0))}var Y=["alg","iat","tmb","typ"];async function w(r,e){return n.SignBufferB64(await n.FromCozeKey(e),await f(r))}async function K(r,e,t){if(h(e))throw new Error("Coze: Cannot sign with revoked key.");if(a(r.pay.alg)&&(r.pay.alg=e.alg),a(r.pay.tmb)&&(r.pay.tmb=await l(e)),r.pay.alg!==e.alg)throw new Error("SignCoze: Coze key alg mismatch with coze.pay.alg.");if(r.pay.tmb!==e.tmb)throw new Error("SignCoze: Coze key tmb mismatch with coze.pay.tmb.");return r.pay.iat=Math.round(Date.now()/1e3),a(t)||(r.pay=await m(r.pay,t)),r.sig=await w(await JSON.stringify(r.pay),e),r}async function q(r,e,t){if(h(e))throw new Error("SignCozeRaw: Cannot sign with revoked key.");if(!a(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("SignCozeRaw: Coze key alg mismatch with coze.pay.alg.");if(!a(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.");return a(t)||(r.pay=await m(r.pay,t)),r.sig=await w(await JSON.stringify(r.pay),e),r}async function g(r,e,t){return n.VerifyMsg(await n.FromCozeKey(e,!0),r,t)}async function x(r,e){if(!a(r.pay.alg)&&r.pay.alg!==e.alg)throw new Error("Coze: Coze key alg mismatch with coze.pay.alg.");if(!a(r.pay.tmb)&&r.pay.tmb!==e.tmb)throw new Error("Coze: Coze key tmb mismatch with coze.pay.tmb.");return g(JSON.stringify(r.pay),e,r.sig)}async function L(r,e){if(!Array.isArray(r))return x(r,e);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCoze:[]};let i=[...r];for(let s of i)a(s.coze)||(s=s.coze),await x(s,e)?t.VerifiedCount++:(t.FailedCount++,t.FailedCoze.push(s));return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function $(r,e){return a(r.pay.alg)?e=u(e):e=u(r.pay.alg),r.can=await z(r.pay),r.cad=await S(r.pay,e),console.debug({...r}),r.czd=await S({cad:r.cad,sig:r.sig},e),console.debug({...r}),r}async function f(r){var e=new TextEncoder;return e.encode(r).buffer}function T(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0)).buffer}function C(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0))}function y(r){var e=String.fromCharCode.apply(null,new Uint8Array(r));return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function a(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!M(r)}function M(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function z(r){return Object.keys(r)}async function m(r,e){if(a(e))return r;let t={};for(let i of e)t[i]=r[i];return t}async function O(r,e){return JSON.stringify(await m(r,e))}async function R(r,e,t){if(a(e))throw new Error("Hash is not given");return await crypto.subtle.digest(e,await f(await O(r,t)))}async function S(r,e,t){return await y(await R(r,e,t))}export{y as ArrayBufferTo64ut,T as B64uToArrayBuffer,C as B64utToUint8Array,z as Canon,m as Canonical,R as CanonicalHash,S as CanonicalHash64,O as CanonicalS,W as Correct,n as CryptoKey,p as Curve,U as DSize,P as Family,c as Genus,u as HashAlg,N as HashSize,h as IsRevoked,$ as Meta,_ as NewKey,H as Params,Y as PayCanon,Q as Revoke,f as SToArrayBuffer,V as SigSize,w as Sign,K as SignCoze,q as SignCozeRaw,l as Thumbprint,G as TmbCanon,j as Use,J as Valid,g as Verify,x as VerifyCoze,L as VerifyCozeArray,A as XSize,M as isBool,a as isEmpty};
//# sourceMappingURL=coze.min.js.map
