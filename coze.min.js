async function u(r){var e=new TextEncoder;return e.encode(r).buffer}function s(r){var e=String.fromCharCode.apply(null,new Uint8Array(r));return P(F(btoa(e)))}function h(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0)).buffer}function C(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0))}function F(r){return r.replace(/\+/g,"-").replace(/\//g,"_")}function P(r){return r.replace(/=/g,"")}function X(r){let e={Name:r};e.Genus=y(r),e.Family=O(r),e.Hash=c(r),e.HashSize=d(r);try{e.Curve=m(r),e.Use=I(r),e.SigSize=j(r),e.XSize=g(r),e.DSize=G(r)}catch{}return e}function y(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed25519ph":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function O(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function c(r){switch(r){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":case"Ed25519ph":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function d(r){let e=c(r);switch(e!=r&&(r=e),r){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function j(r){switch(r){case"ES224":return 56;case"ES256":case"Ed25519":case"Ed25519ph":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function g(r){switch(r){case"Ed25519":case"Ed25519ph":return 32;case"ES224":return 56;case"Ed448":return 57;case"ES256":return 64;case"ES384":return 96;case"ES512":return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function G(r){switch(r){case"ES224":return 28;case"ES256":case"Ed25519":case"Ed25519ph":return 32;case"ES384":return 48;case"Ed448":return 57;case"ES512":return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function m(r){switch(r){case"ES224":return"P-224";case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function I(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"sig";default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var o={New:async function(r){if(n(r)&&(r="ES256"),y(r)!=="ECDSA"||r=="ES224"||r=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm:"+r);return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:m(r)},!0,["sign","verify"])},FromCozeKey:async function(r,e){if(y(r.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var t={};t.use="sig",t.crv=m(r.alg),t.kty="EC";let a=g(r.alg)/2,i=await C(r.x),f=i.slice(0,a),S=i.slice(a);if(t.x=await s(f),t.y=await s(S),n(r.d)||e)var p="verify";else p="sign",t.d=r.d;var E=await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv},!0,[p]);return E},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let e=await window.crypto.subtle.exportKey("jwk",r);var t={};t.alg=await o.algFromCrv(e.crv);let a=C(e.x),i=C(e.y);var f=new Uint8Array([...a,...i]);return t.x=s(f.buffer),e.hasOwnProperty("d")&&(t.d=e.d),t.tmb=await l(t),t},SignBuffer:async function(r,e){let t=await o.GetSignHashAlgoFromCryptoKey(r);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:t}},r,e)},SignBufferB64:async function(r,e){return await s(await o.SignBuffer(r,e))},SignString:async function(r,e){return await o.SignBufferB64(r,await u(e))},VerifyArrayBuffer:async function(r,e,t){await o.ToPublic(r);let a=await o.GetSignHashAlgoFromCryptoKey(r);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:a}},r,t,e)},VerifyMsg:async function(r,e,t){let a=await u(e),i=await h(t);return o.VerifyArrayBuffer(r,a,i)},GetSignHashAlgoFromCryptoKey:async function(r){return c(await o.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case"P-224":var e="ES224";break;case"P-256":e="ES256";break;case"P-384":e="ES384";break;case"P-521":e="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return e}};var R=["alg","x"];async function Q(r){if(n(r)&&(r="ES256"),y(r)=="ECDSA")var e=await o.New(r);else throw new Error("CozeKey.NewCozeKey: only ECDSA algs are currently supported.");let t=await o.ToCozeKey(e.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await l(t),t.kid="My Cyphr.me Key.",t}async function l(r){if(n(r.alg)||n(r.x))throw new Error("CozeKey.Thumbprint: alg or x  is empty.");return K(r,await c(r.alg),R)}async function q(r){if(n(r.d))return console.error("Coze key missing `d`"),!1;try{let e="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",t=await B(e,r);return await b(e,r,t)}catch(e){console.error(e)}return!1}async function Y(r){let e=["alg","tmb"];if(n(ck)||typeof ck!="object",Object.keys(ck).length>=2&&!n(ck.alg)&&!n(ck.tmb)&&(n(ck.x)||n(ck.iat)))return!0;let t=IsTmbOnly(r);t||(console.debug("not a tmb only key"),e.push(["iat","x"]));for(let i of e)if(!(i in r))throw new Error("CozeKey.Correct: No '"+i+"' in Coze key");if(r.alg=="Ed25519"&&r.x.length<64)throw new Error("CozeKey.Correct: x is too short.  Has length: "+r.x.length);if(t)return!0;if(r.iat>Math.round(Date.now()/1e3))throw new Error("CozeKey.Correct: cannot have iat greater than present time");if(y(r.alg)=="ECDSA"){let i=d(c(r.alg))*2;if(r.x.length<i)throw new Error("CozeKey.Correct: x is too short.  Has length: "+r.x.length);if(r.y.length<i)throw new Error("CozeKey.Correct: y is too short.  Has length: "+r.y.length)}let a=await l(r);if(a!=r.tmb)throw new Error("CozeKey.Correct: tmb does not match: "+a);if(!n(r.d)){let i="Test Signing",f=await o.FromCozeKey(r),S=await u(i),p=await o.SignBuffer(f,S),E=await o.FromCozeKey(r,!0);if(await o.VerifyArrayBuffer(E,S,p)!==!0)throw new Error("CozeKey.Correct: private key invalid.")}return!0}async function L(r){let e={};switch(e.alg=r.alg,e.iat=r.iat,n(r.kid)||(e.kid=r.kid),e.x=r.x,y(e.alg)){case"ECDSA":e.y=r.y;break;case"EdDSA":break;default:throw new Error("CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):"+e.alg)}return e.tmb=await l(e),e=await A(e),e}async function $(r,e){if(n(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var t={};t.pay={},n(e)||(t.pay.msg=e),t.pay.rvk=Math.round(Date.now()/1e3);let a=r.rvk;return delete r.rvk,t=await V(t,r),a!==void 0?r.rvk=a:r.rvk=t.pay.rvk,t}function N(r){return!(n(r.rvk)||!(parseInt(r.rvk)>0))}var rr=["alg","iat","tmb","typ"];async function B(r,e){let t=await o.FromCozeKey(e);return o.SignBufferB64(t,await u(r))}async function V(r,e,t){if(N(e))throw new Error("Coze: Cannot sign with revoked key.");r.pay.alg=e.alg,r.pay.iat=Math.round(Date.now()/1e3),r.pay.tmb=await l(e),n(t)||(r.pay=await T(r.pay,t));let a=await JSON.stringify(r.pay);return console.log(a),r.sig=await B(a,e),r}async function b(r,e,t){let a=await o.FromCozeKey(e,!0);return o.VerifyMsg(a,r,t)}async function U(r,e){if(r.pay.tmb!==e.tmb)throw new Error("Coze.VerifyCoze: pay.tmb does not match key.tmb.");let t=await JSON.stringify(r.pay);return b(t,e,r.sig)}async function er(r,e){if(!Array.isArray(r))return U(r,e);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCoze:[]};let a=[...r];for(let i=0;i<a.length;i++){let f=a[i];n(f.coze)||(f=f.coze),await U(f,e)?t.VerifiedCount++:(t.FailedCount++,t.FailedCoze.push(a))}return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function tr(r){r.can=await A(r.pay),r.cad=await s(await v(r.pay,c(r.pay.alg)));let e=await u('{"cad":"'+r.cad+'","sig":"'+r.sig+'"}');return r.czd=await s(await crypto.subtle.digest(c(r.pay.alg),e)),r}function n(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!_(r)}function _(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function A(r){return Object.keys(r)}async function T(r,e){let t=[];typeof e=="object"&&(t=Object.keys(e)),!e||e.length===0?t=Object.keys(r):t=e;let a={};for(let i of t)a[i]=r[i];return a}async function J(r,e){return JSON.stringify(await T(r,e))}async function v(r,e,t){n(e)&&(e="SHA-256"),typeof r=="string"&&(r=JSON.parse(r));let a=await u(await J(r,t));return await crypto.subtle.digest(e,a)}async function K(r,e,t){let a=await v(r,e,t);return await s(a)}export{s as ArrayBufferTo64ut,h as B64utToArrayBuffer,C as B64utToUint8Array,A as Canon,v as CanonHash,K as CanonHash64,T as Canonical,J as CanonicalS,Y as Correct,o as CryptoKey,m as Curve,G as DSize,O as Family,y as Genus,c as HashAlg,d as HashSize,N as IsRevoked,tr as Meta,Q as NewCozeKey,X as Params,rr as PayCanon,$ as Revoke,u as SToArrayBuffer,j as SigSize,B as Sign,V as SignCoze,l as Thumbprint,R as TmbCanon,L as ToPublicCozeKey,I as Use,q as Valid,b as Verify,U as VerifyCoze,er as VerifyCozeArray,g as XSize,_ as isBool,n as isEmpty};
//# sourceMappingURL=coze.min.js.map
