function R(r){let e={Name:r};e.Genus=y(r),e.Family=N(r),e.Hash=u(r),e.HashSize=A(r);try{e.Curve=w(r),e.Use=j(r),e.SigSize=O(r),e.XSize=d(r),e.DSize=V(r)}catch{}return e}function y(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed25519ph":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("alg.Genus: unsupported algorithm: "+r)}}function N(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("alg.Family:  unsupported algorithm: "+r)}}function u(r){switch(r){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":case"Ed25519ph":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("alg.HashAlg:  unsupported algorithm: "+r)}}function A(r){let e=u(r);switch(e!=r&&(r=e),r){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("alg.HashSize: unsupported algorithm: "+r)}}function O(r){switch(r){case"ES224":return 56;case"ES256":case"Ed25519":case"Ed25519ph":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("alg.SigSize: unsupported algorithm: "+r)}}function d(r){switch(r){case"Ed25519":case"Ed25519ph":return 32;case"ES224":return 56;case"Ed448":return 57;case"ES256":return 64;case"ES384":return 96;case"ES512":return 132;default:throw new Error("alg.XSize: unsupported algorithm: "+r)}}function V(r){switch(r){case"ES224":return 28;case"ES256":case"Ed25519":case"Ed25519ph":return 32;case"ES384":return 48;case"Ed448":return 57;case"ES512":return 66;default:throw new Error("alg.DSize: unsupported algorithm: "+r)}}function w(r){switch(r){case"ES224":return"P-224";case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("alg.Curve: unsupported algorithm: "+r)}}function j(r){switch(r){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed25519ph":case"Ed448":return"sig";default:throw new Error("alg.Use: unsupported algorithm: "+r)}}var o={New:async function(r){if(n(r)&&(r="ES256"),y(r)!=="ECDSA"||r=="ES224"||r=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm:"+r);return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:w(r)},!0,["sign","verify"])},FromCozeKey:async function(r,e){if(y(r.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+r.alg);var t={};t.use="sig",t.crv=w(r.alg),t.kty="EC";let a=d(r.alg)/2,i=await p(r.x),s=i.slice(0,a),C=i.slice(a);if(t.x=await c(s),t.y=await c(C),n(r.d)||e)var S="verify";else S="sign",t.d=r.d;var h=await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv},!0,[S]);return h},ToPublic:async function(r){delete r.d,r.key_ops=["verify"]},ToCozeKey:async function(r){let e=await window.crypto.subtle.exportKey("jwk",r);var t={};t.alg=await o.algFromCrv(e.crv);let a=p(e.x),i=p(e.y);var s=new Uint8Array([...a,...i]);return t.x=c(s.buffer),e.hasOwnProperty("d")&&(t.d=e.d),t.tmb=await l(t),t},SignBuffer:async function(r,e){let t=await o.GetSignHashAlgoFromCryptoKey(r);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:t}},r,e)},SignBufferB64:async function(r,e){return await c(await o.SignBuffer(r,e))},SignString:async function(r,e){return await o.SignBufferB64(r,await f(e))},VerifyArrayBuffer:async function(r,e,t){await o.ToPublic(r);let a=await o.GetSignHashAlgoFromCryptoKey(r);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:a}},r,t,e)},VerifyMsg:async function(r,e,t){let a=await f(e),i=await x(t);return o.VerifyArrayBuffer(r,a,i)},GetSignHashAlgoFromCryptoKey:async function(r){return u(await o.algFromCrv(r.algorithm.namedCurve))},algFromCrv:async function(r){switch(r){case"P-224":var e="ES224";break;case"P-256":e="ES256";break;case"P-384":e="ES384";break;case"P-521":e="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return e}};var U=["alg","x"];async function W(r){if(n(r)&&(r="ES256"),y(r)=="ECDSA")var e=await o.New(r);else throw new Error("CozeKey.NewCozeKey: only ECDSA algs are currently supported.");let t=await o.ToCozeKey(e.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await l(t),t.kid="My Cyphr.me Key.",t}async function l(r){if(n(r.alg)||n(r.x))throw new Error("CozeKey.Thumbprint: alg or x  is empty.");return z(r,await u(r.alg),U)}async function X(r){if(n(r.d))return console.error("Coze key missing `d`"),!1;try{let e="7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q",t=await H(e,r);return await k(e,r,t)}catch(e){console.error(e)}return!1}async function Z(r){let e=["alg","tmb"];if(n(ck)||typeof ck!="object",Object.keys(ck).length>=2&&!n(ck.alg)&&!n(ck.tmb)&&(n(ck.x)||n(ck.iat)))return!0;let t=IsTmbOnly(r);t||(console.debug("not a tmb only key"),e.push(["iat","x"]));for(let i of e)if(!(i in r))throw new Error("CozeKey.Correct: No '"+i+"' in Coze key");if(r.alg=="Ed25519"&&r.x.length<64)throw new Error("CozeKey.Correct: x is too short.  Has length: "+r.x.length);if(t)return!0;if(r.iat>Math.round(Date.now()/1e3))throw new Error("CozeKey.Correct: cannot have iat greater than present time");if(y(r.alg)=="ECDSA"){let i=A(u(r.alg))*2;if(r.x.length<i)throw new Error("CozeKey.Correct: x is too short.  Has length: "+r.x.length);if(r.y.length<i)throw new Error("CozeKey.Correct: y is too short.  Has length: "+r.y.length)}let a=await l(r);if(a!=r.tmb)throw new Error("CozeKey.Correct: tmb does not match: "+a);if(!n(r.d)){let i="Test Signing",s=await o.FromCozeKey(r),C=await f(i),S=await o.SignBuffer(s,C),h=await o.FromCozeKey(r,!0);if(await o.VerifyArrayBuffer(h,C,S)!==!0)throw new Error("CozeKey.Correct: private key invalid.")}return!0}async function Q(r){let e={};switch(e.alg=r.alg,e.iat=r.iat,n(r.kid)||(e.kid=r.kid),e.x=r.x,y(e.alg)){case"ECDSA":e.y=r.y;break;case"EdDSA":break;default:throw new Error("CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):"+e.alg)}return e.tmb=await l(e),e=await m(e),e}async function q(r,e){if(n(r))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");var t={};t.pay={},n(e)||(t.pay.msg=e),t.pay.rvk=Math.round(Date.now()/1e3);let a=r.rvk;return delete r.rvk,t=await D(t,r),a!==void 0?r.rvk=a:r.rvk=t.pay.rvk,t}function K(r){return!(n(r.rvk)||!(parseInt(r.rvk)>0))}var Y=["alg","iat","tmb","typ"];async function H(r,e){let t=await o.FromCozeKey(e);return o.SignBufferB64(t,await f(r))}async function D(r,e,t){if(K(e))throw new Error("Coze: Cannot sign with revoked key.");r.pay.alg=e.alg,r.pay.iat=Math.round(Date.now()/1e3),r.pay.tmb=await l(e),n(t)||(r.pay=await b(r.pay,t));let a=await JSON.stringify(r.pay);return console.log(a),r.sig=await H(a,e),r}async function k(r,e,t){let a=await o.FromCozeKey(e,!0);return o.VerifyMsg(a,r,t)}async function P(r,e){if(r.pay.tmb!==e.tmb)throw new Error("Coze.VerifyCoze: pay.tmb does not match key.tmb.");let t=await JSON.stringify(r.pay);return k(t,e,r.sig)}async function L(r,e){if(!Array.isArray(r))return P(r,e);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedCoze:[]};let a=[...r];for(let i=0;i<a.length;i++){let s=a[i];n(s.coze)||(s=s.coze),await P(s,e)?t.VerifiedCount++:(t.FailedCount++,t.FailedCoze.push(a))}return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function $(r){r.can=await m(r.pay),r.cad=await c(await v(r.pay,u(r.pay.alg)));let e=await f('{"cad":"'+r.cad+'","sig":"'+r.sig+'"}');return r.czd=await c(await crypto.subtle.digest(u(r.pay.alg),e)),r}async function f(r){var e=new TextEncoder;return e.encode(r).buffer}function x(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0)).buffer}function p(r){return Uint8Array.from(atob(r.replace(/-/g,"+").replace(/_/g,"/")),e=>e.charCodeAt(0))}function c(r){var e=String.fromCharCode.apply(null,new Uint8Array(r));return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function n(r){return typeof r=="function"?!1:r===Object(r)?Object.keys(r).length===0:!G(r)}function G(r){return!(r===!1||r==="false"||r===void 0||r==="undefined"||r===""||r===0||r==="0"||r===null||r==="null"||r==="NaN"||Number.isNaN(r)||r===Object(r))}function m(r){return Object.keys(r)}async function b(r,e){let t=[];typeof e=="object"&&(t=Object.keys(e)),!e||e.length===0?t=Object.keys(r):t=e;let a={};for(let i of t)a[i]=r[i];return a}async function M(r,e){return JSON.stringify(await b(r,e))}async function v(r,e,t){n(e)&&(e="SHA-256"),typeof r=="string"&&(r=JSON.parse(r));let a=await f(await M(r,t));return await crypto.subtle.digest(e,a)}async function z(r,e,t){let a=await v(r,e,t);return await c(a)}export{c as ArrayBufferTo64ut,x as B64uToArrayBuffer,p as B64utToUint8Array,m as Canon,b as Canonical,v as CanonicalHash,z as CanonicalHash64,M as CanonicalS,Z as Correct,o as CryptoKey,w as Curve,V as DSize,N as Family,y as Genus,u as HashAlg,A as HashSize,K as IsRevoked,$ as Meta,W as NewCozeKey,R as Params,Y as PayCanon,q as Revoke,f as SToArrayBuffer,O as SigSize,H as Sign,D as SignCoze,l as Thumbprint,U as TmbCanon,Q as ToPublicCozeKey,j as Use,X as Valid,k as Verify,P as VerifyCoze,L as VerifyCozeArray,d as XSize,G as isBool,n as isEmpty};
//# sourceMappingURL=coze.min.js.map
