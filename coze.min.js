async function s(e){var r=new TextEncoder;return r.encode(e).buffer}async function C(e){if(e===void 0)return new Uint8Array().buffer;if(e.length%2!==0)throw new RangeError("HexToArrayBuffer: Hex is not even.");for(var r=new Uint8Array(e.length/2),t=0;t<e.length;t+=2)r[t/2]=parseInt(e.substring(t,t+2),16);return r.buffer}async function c(e){return[...new Uint8Array(e)].map(r=>r.toString(16).padStart(2,"0")).join("").toUpperCase()}function m(e){let r=z(e),t=atob(r),a="";for(let n=0;n<t.length;n++){let u=t.charCodeAt(n).toString(16).toUpperCase();a+=u.length===2?u:"0"+u}return a}async function p(e){let r=await C(e);return await O(r)}function z(e){return e.replace(/-/g,"+").replace(/_/g,"/")}function O(e){var r=String.fromCharCode.apply(null,new Uint8Array(e));return M(U(btoa(r)))}function U(e){return e.replace(/\+/g,"-").replace(/\//g,"_")}function M(e){return e.replace(/=/g,"")}function Y(e){let r={Name:e};r.Genus=f(e),r.Family=j(e),r.Hash=y(e),r.HashSize=E(e);try{r.Curve=g(e)}catch{}try{r.Use=I(e),r.SigSize=_(e)}catch{}return r}function f(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":return"ECDSA";case"Ed25519":case"Ed448":return"EdDSA";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":return"SHA2";case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA3";default:throw new Error("coze_enum.Genus: unsupported algorithm for genus")}}function j(e){switch(e){case"ES224":case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed448":return"EC";case"SHA-224":case"SHA-256":case"SHA-384":case"SHA-512":case"SHA3-224":case"SHA3-256":case"SHA3-384":case"SHA3-512":case"SHAKE128":case"SHAKE256":return"SHA";default:throw new Error("coze_enum.Family: unsupported algorithm for family")}}function y(e){switch(e){case"SHA-224":case"ES224":return"SHA-224";case"SHA-256":case"ES256":return"SHA-256";case"SHA-384":case"ES384":return"SHA-384";case"SHA-512":case"ES512":case"Ed25519":return"SHA-512";case"SHAKE128":return"SHAKE128";case"SHAKE256":case"Ed448":return"SHAKE256";case"SHA3-224":return"SHA3-224";case"SHA3-256":return"SHA3-256";case"SHA3-384":return"SHA3-384";case"SHA3-512":return"SHA3-512";default:throw new Error("coze_enum.HashAlg: unsupported algorithm for HashAlg")}}function E(e){let r=y(e);switch(r!=e&&(e=r),e){case"SHA-224":case"SHA3-224":return 28;case"SHA-256":case"SHA3-256":case"SHAKE128":return 32;case"SHA-384":case"SHA3-384":return 48;case"SHA-512":case"SHA3-512":case"SHAKE256":return 64;default:throw new Error("coze_enum.HashSize: unsupported algorithm for hash size")}}function _(e){switch(e){case"ES224":return 56;case"ES256":case"Ed25519":return 64;case"ES384":return 96;case"Ed448":return 114;case"ES512":return 132;default:throw new Error("coze_enum.SigSize: unsupported algorithm for sig size")}}function g(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";case"Ed25519":return"Curve25519";case"Ed448":return"Curve448";default:throw new Error("coze_enum.Curve: unsupported algorithm for curve")}}function I(e){switch(e){case"ES256":case"ES384":case"ES512":case"Ed25519":case"Ed448":return"sig";default:throw new Error("coze_enum.Use: unsupported algorithm for use")}}var o={New:async function(e){if(i(e)&&(e="ES256"),f(e)!=="ECDSA"||e=="ES224"||e=="ES192")throw new Error("CryptoKey.New: Unsupported key algorithm.");return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:g(e)},!0,["sign","verify"])},FromCozeKey:async function(e){if(f(e.alg)!="ECDSA")throw new Error("CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: "+e.alg);var r={};if(r.use="sig",r.x=await p(e.x),r.y=await p(e.y),r.crv=g(e.alg),r.kty="EC",i(e.d))var t="verify";else t="sign",r.d=await p(e.d);var a=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv},!0,[t]);return a},FromCozeKeyToPublic:async function(e){let r={...e};return delete r.d,o.FromCozeKey(r)},ToPublic:async function(e){let r={...e};return delete r.d,r.key_ops=["verify"],r},ToCozeKey:async function(e){let r=await window.crypto.subtle.exportKey("jwk",e);var t={};if(r.kty!="EC")throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.");switch(r.crv){case"P-256":t.alg="ES256";break;case"P-384":t.alg="ES384";break;case"P-521":t.alg="ES512";break;default:throw new Error("CryptoKey.ToCozeKey: Unsupported key algorithm.")}return t.x=m(r.x),r.hasOwnProperty("d")&&(t.d=m(r.d)),r.hasOwnProperty("y")&&(t.y=m(r.y)),t.tmb=await l(t),t},SignBuffer:async function(e,r){let t=await o.GetSignHashAlgoFromCryptoKey(e);return await window.crypto.subtle.sign({name:"ECDSA",hash:{name:t}},e,r)},SignBufferToHex:async function(e,r){let t=await o.SignBuffer(e,r);return await c(t)},SignString:async function(e,r){let t=await s(r);return await o.SignBufferToHex(e,t)},VerifyABMsgSig:async function(e,r,t){let a=await o.GetSignHashAlgoFromCryptoKey(e);return await window.crypto.subtle.verify({name:"ECDSA",hash:{name:a}},e,t,r)},VerifyMsgHexSig:async function(e,r,t){return t=await C(t),r=await s(r),o.VerifyABMsgSig(e,r,t)},GetSignHashAlgoFromCryptoKey:async function(e){let r=await o.ToCozeKey(e);return await y(r.alg)}};var R=["alg","x","y"],Z=["alg","x"];async function re(e){if(i(e)&&(e="ES256"),f(e)=="ECDSA")var r=await o.New(e);else throw new Error("CozeKey.NewCozeKey: only ECDSA algs are currently supported.");let t=await o.ToCozeKey(r.privateKey);return t.iat=Math.floor(Date.now()/1e3),t.tmb=await l(t),t.kid="My Cyphr.me Key.",t}async function te(e,r,t){let a=await s(r),n=await s(t),u=await o.FromCozeKeyToPublic(e);return await o.VerifyABMsgSig(u,a,n)}async function l(e){if(i(e.alg))throw new Error("CozeKey.Thumbprint: alg is empty.");if(f(e.alg)!="ECDSA"&&e.alg!="Ed25519")throw new Error("CozeKey.Thumbprint: unsupported alg.");if(i(e.x))throw new Error("CozeKey.Thumbprint: x is empty.");if(f(e.alg)=="ECDSA"&&i(e.y))throw new Error("CozeKey.Thumbprint: y is empty.");let r={};f(e.alg)=="ECDSA"&&(r=R),f(e.alg)=="EdDSA"&&(r=Z);let t=await y(e.alg);return k(e,t,r)}async function ae(e){try{if(i(e.d))throw"Private Coze key is missing private component 'd'";return await J(e)}catch{}return!1}async function J(e){let r=["alg","tmb"],t=q(e);t||(console.debug("not a tmb only key"),r.push(["iat","x"]));for(let n of r)if(!(n in e))throw new Error("CozeKey.Correct: No '"+n+"' in Coze key");if(e.alg=="Ed25519"&&e.x.length<64)throw new Error("CozeKey.Correct: x is too short.  Has length: "+e.x.length);if(t)return!0;if(e.iat>Math.round(Date.now()/1e3))throw new Error("CozeKey.Correct: cannot have iat greater than present time");if(f(e.alg)=="ECDSA"){let n=E(y(e.alg))*2;if(e.x.length<n)throw new Error("CozeKey.Correct: x is too short.  Has length: "+e.x.length);if(e.y.length<n)throw new Error("CozeKey.Correct: y is too short.  Has length: "+e.y.length)}let a=await l(e);if(a!=e.tmb)throw new Error("CozeKey.Correct: tmb does not match: "+a);if(!i(e.d)){let n="Test Signing",u=await o.FromCozeKey(e),S=await s(n),G=await o.SignBuffer(u,S),F=await o.FromCozeKeyToPublic(e);if(await o.VerifyABMsgSig(F,S,G)!==!0)throw new Error("CozeKey.Correct: private key invalid.")}return!0}async function H(e){let r={};switch(r.alg=e.alg,r.iat=e.iat,i(e.kid)||(r.kid=e.kid),r.x=e.x,f(r.alg)){case"ECDSA":r.y=e.y;break;case"EdDSA":break;default:throw new Error("CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):"+r.alg)}return r.tmb=await l(r),r=await w(r),r}async function ne(e,r){if(i(e))throw new Error("CozeKey.Revoke: Private key not set.  Cannot sign message");i(e.tmb)&&(e.tmb=await CZK.Thumbprint(e));var t={};t.head={},i(r)||(t.head.msg=r),t.head.rvk=Math.round(Date.now()/1e3),t.head.typ="cyphr.me/key/revoke";let a=e.rvk;return delete e.rvk,t=await x(t,e),a!==void 0&&(e.rvk=a),t}function v(e){return i(e.rvk)?!1:parseInt(e.rvk)>0||e.rvk===!0||e.rvk.toLowerCase()==="true"}function q(e){if(i(e)||typeof e!="object")throw new Error("must pass a valid Coze Key object");return!!(Object.keys(e).length>=2&&!i(e.alg)&&!i(e.tmb)&&(i(e.x)||i(e.iat)))}var ie=["alg","iat","tmb","typ"],oe=["alg","iat","msg","tmb","typ"];async function se(e,r,t){return e=await N(e,r,t),V(e,r)}async function x(e,r,t){let a={};return a.head=await N(e.head,r,t),a.sig=await V(a.head,r),a}async function N(e,r,t){if(i(r))throw new Error("Coze: Key not set. ");if(v(r))throw new Error("Coze: Cannot sign with revoked key.");return e.alg=r.alg,e.tmb=await l(r),e.iat=Math.round(Date.now()/1e3),w(e,t)}async function V(e,r){return o.SignBufferToHex(await o.FromCozeKey(r),await s(JSON.stringify(e)))}async function ue(e,r,t){return o.VerifyABMsgSig(await o.FromCozeKeyToPublic(r),await s(await d(e)),await C(t))}async function P(e,r,t){let a=await Q(e,r,t);if(a.head.tmb!==a.key.tmb)throw new Error("Coze.VerifyCy: head.tmb does not match key.tmb.");return o.VerifyABMsgSig(await o.FromCozeKeyToPublic(a.key),await s(await d(a.head,a.can)),await C(a.sig))}async function fe(e,r){if(!Array.isArray(e))return P(e,r);var t={VerifiedAll:!1,VerifiedCount:0,FailedCount:0,FailedObjs:[]};let a=[...e];for(let n=0;n<a.length;n++){let u=a[n];i(u.cy)||(u=u.cy),await P(u,r)?t.VerifiedCount++:(t.FailedCount++,t.FailedObjs.push(a))}return t.FailedCount==0&&(t.VerifiedAll=!0),t}async function Q(e,r,t){if(Array.isArray(e))throw new Error("Coze.GetCyParts: Cy cannot be array.");let a={};typeof e=="string"?a=JSON.parse(e):a={...e},i(a.cy)||(a=a.cy);var n={};if(n.head=a.head,i(n.head))throw new Error("Coze.GetCyParts: A head is not set.");if(i(r)?n.key=await H(a.key):n.key=await H(r),i(n.key))throw new Error("Coze.GetCyParts: A public key is not set.");if(n.head.tmb!==n.key.tmb)throw new Error("Coze.GetCyParts: `head.tmb` does not match `key.tmb`.");if(i(t)?n.sig=a.sig:n.sig=t,i(n.sig))throw new Error("Coze.GetCyParts: A sig is not set.");i(a.can)?n.can=await D(n.head):n.can=a.can,n.cad=await c(await T(a.head,y(a.head.alg),a.can));let u='{"cad":"'+n.cad+'","sig":"'+n.sig+'"}',S=await crypto.subtle.digest(y(n.head.alg),await s(u));return n.cyd=await c(S),n}function i(e){return typeof e=="function"?!1:e===Object(e)?Object.keys(e).length===0:!W(e)}function W(e){return!(e===!1||e==="false"||e===void 0||e==="undefined"||e===""||e===0||e==="0"||e===null||e==="null"||e==="NaN"||Number.isNaN(e)||e===Object(e))}async function w(e,r){let t=[];typeof r=="object"&&(t=Object.keys(r)),!r||r.length===0?t=Object.keys(e):t=r,t.sort();let a={};for(let n of t)a[n]=e[n];return a}async function d(e,r){return JSON.stringify(await w(e,r))}function D(e){let r=Object.keys(e);return r.sort(),r}async function T(e,r,t){typeof e=="string"&&(e=JSON.parse(e));let a=await d(e,t);i(r)&&(r="SHA-256");let n=await s(a);return n=await crypto.subtle.digest(r,n),n}async function k(e,r,t){let a=await T(e,r,t);return await c(a)}export{c as ArrayBufferToHex,T as CH,k as CHH,w as Canon,d as Canons,J as Correct,o as CryptoKey,g as Curve,R as ECDSATmbCanon,Z as EdDSATmbCanon,j as Family,D as GenCanon,f as Genus,Q as GetCyParts,y as HashAlg,E as HashSize,ie as HeadCanon,C as HexToArrayBuffer,v as IsRevoked,q as IsTmbOnly,oe as MsgCanon,re as NewCozeKey,Y as Params,ne as Revoke,s as SToArrayBuffer,_ as SigSize,se as Sign,x as SignCy,l as Thumbprint,H as ToPublicCozeKey,I as Use,ae as Valid,ue as Verify,P as VerifyCy,fe as VerifyCyArray,te as VerifyMsg,W as isBool,i as isEmpty};
//# sourceMappingURL=coze.min.js.map
