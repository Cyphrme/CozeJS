{
  "version": 3,
  "sources": ["base_convert.js", "alg.js", "cryptokey.js", "cozekey.js", "coze.js", "canon.js"],
  "sourcesContent": ["// base_convert.js is taken from https://github.com/zamicol/BaseConverter and\n// Cyphr.me's `base_convert.js`.\n//\n// Since base conversion is tightly coupled to Coze, instead of importing an\n// external project/repo, this file is copied directly into this project.\n// However, most of these functions are not exported into the Coze module since\n// Coze isn't about base conversion.  See `join.js` for selected exported\n// functions that are useful when interacting with Coze.   \n//\n// If you need general base conversion, see Cyphr.me's `base_convert.js` or\n// `convert.zamicol.com`.  \n\"use strict\";\n\n// Needed in Coze:\nexport {\n\tArrayBufferTo64ut,\n\tB64utToArrayBuffer,\n\tB64utToUint8Array,\n\tSToArrayBuffer,\n}\n\n/**\n * @typedef {import('./coze.js').Hex}  Hex\n * \n * Unsafe base64 truncated isn't a thing.  If needed, use b64ut instead. \n * @typedef {String} ub64     - Unsafe base 64.  Includes padding. \n * @typedef {String} b64u     - base 64 url.  Includes padding. \n * @typedef {String} b64ut    - base 64 url truncated.  Excludes padding. \n * @typedef {String} Base64   - Cyphr.me Base64.  \n **/\n\n/**\n * Converts a string to an ArrayBuffer.   \n *\n * @param  {string}        String.\n * @return {ArrayBuffer}\n */\nasync function SToArrayBuffer(string) {\n\tvar enc = new TextEncoder(); // Suppose to be always in UTF-8\n\tlet uint8array = enc.encode(string);\n\tlet ab = uint8array.buffer;\n\n\t// Alternatively: (untested) \n\t// var len = string.length;\n\t// var bytes = new Uint8Array(len);\n\t// for (var i = 0; i < len; i++) {\n\t// \tbytes[i] = string.charCodeAt(i);\n\t// }\n\t// let b = await bytes.buffer;\n\n\treturn ab;\n}\n\n/**\n * Converts an ArrayBuffer to a UTF-8 string.   \n *\n * @param  {string} string\n * @return {string}\n */\nasync function ArrayBufferToS(ab) {\n\tvar enc = new TextDecoder(\"utf-8\");\n\tlet s = await enc.decode(ab);\n\treturn s;\n}\n\n/**\n * HexToArrayBuffer converts string Hex to ArrayBuffer. \n * \n * @param   {Hex}          Hex   String Hex. \n * @returns {ArrayBuffer}        ArrayBuffer. \n */\nasync function HexToArrayBuffer(hex) {\n\tif (hex === undefined) { // undefined is different from 0 since 0 == \"AA\"\n\t\treturn new Uint8Array().buffer;\n\t}\n\n\tif ((hex.length % 2) !== 0) {\n\t\tthrow new RangeError('HexToArrayBuffer: Hex is not even.')\n\t}\n\n\tvar a = new Uint8Array(hex.length / 2)\n\tfor (var i = 0; i < hex.length; i += 2) {\n\t\ta[i / 2] = parseInt(hex.substring(i, i + 2), 16)\n\t}\n\n\treturn a.buffer\n};\n\n/**\n * ArrayBufferToHex accepts an ArrayBuffer and returns  Hex.\n * Taken from https://stackoverflow.com/a/50767210/1923095\n * \n * @param   {ArrayBuffer} buffer       ArrayBuffer.\n * @returns {Hex}          hex         String. Hex representation.\n */\nasync function ArrayBufferToHex(buffer) {\n\treturn [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, \"0\")).join('').toUpperCase();\n\n\t// Alternatively:\n\t// let hashArray = Array.from(new Uint8Array(digest)); // convert buffer to byte array\n\t// let hexHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n\n\n////////////////////////////////////////////////////\n////////////////////////////////////////////////////\n// RFC 4648 \"base64\"s\n////////////////////////////////////////////////////\n////////////////////////////////////////////////////\n// Encodings have two features:\n// 1. An alphabet.\n// 2. A conversion method.  \n//\n// RFC 4648 \"base64\" is a bucket convert encoding method with a specific alphabet.  \n// \n// There are several base 64's that we use in two classes:\n//   1. Unsafe base64.  We call it `ub64`.\n//   2. URL Safe base64 (base64 url).  We call it `b64u` or `base64url`.\n//   3. base64 url safe truncated.  We call it `b64ut`. Padding character \"=\"\n//      removed.  \n//   4. Unsafe base64 truncated isn't a thing.  Why?  Use b64ut instead.  \n//   5. Base64, with an upper case \"B\", has a different alphabet and uses the\n//      iterative divide by radix conversion method and is not a bucket\n//      conversion method.  (Cyphr.me defined, not RFC 4648 defined.)  NOT IN\n//      THIS file. \n//\n// NOTE: RFC 4648 uses the lower case \"base64\" to refer to it's encoding method.\n// The casing and spacing is important!  The generic \"base 64\" with a space is\n// used to refer to any encoding system that has a 64 character alphabet.  \n//\n// Why do we need work with the \"Unsafe Base 64\" (ub64)?\n//\n// JOSE's b64ut is truncated with padding removed.  Javascript's `atob` is the\n// only efficient way in Javascript to work with some of these methods even\n// though it's not used directly for JOSE.  The only way to access CryptoKey in\n// Javascript is via JOSE keys.  See notes on CryptoKey.  \n\n\n/**\n * B64ToHex is \"RFC 4648 base64 URL Safe Truncated\" to Hex.  \n * \n * @param   {b64ut} b64ut   String. b64ut.\n * @returns {Hex}           String. Hex.  \n */\nfunction B64ToHex(b64ut) {\n\tlet ub64 = URISafeToUnsafe(b64ut)\n\tconst raw = atob(ub64);\n\tlet result = '';\n\tfor (let i = 0; i < raw.length; i++) {\n\t\tconst hex = raw.charCodeAt(i).toString(16).toUpperCase();\n\t\tresult += (hex.length === 2 ? hex : '0' + hex);\n\t}\n\treturn result;\n}\n\n/**\n * HexTob64ut is hHx to \"RFC 4648 base64 URL Safe Truncated\".  \n * \n * @param   {Hex}    hex    String. Hex.\n * @returns {b64ut}         String. b64ut.\n */\nasync function HexTob64ut(hex) {\n\tlet ab = await HexToArrayBuffer(hex);\n\tlet b64ut = await ArrayBufferTo64ut(ab);\n\treturn b64ut;\n}\n\n/**\n * URISafeToUnsafe base64 url truncated to unsafe base64 (NOT JOSE compatible)\n * // TODO add padding back. \n * \n * @param   {b64ut} b64ut String. RFC 4648 base64 url safe truncated.\n * @returns {ub64}        String. RFC 4648 unsafe base64.\n */\nfunction URISafeToUnsafe(ub64) {\n\t// Replace + and / with - and _\n\treturn ub64.replace(/-/g, '+').replace(/_/g, '/');\n}\n\n/**\n * ArrayBufferTo64ut Array buffer to base64url.\n * \n * @param   {ArrayBuffer} buffer  ArrayBuffer. Arbitrary bytes. UTF-16 is Javascript native.\n * @returns {b64ut}               String. b64ut encoded string.\n */\nfunction ArrayBufferTo64ut(buffer) {\n\tvar string = String.fromCharCode.apply(null, new Uint8Array(buffer));\n\treturn base64t(URIUnsafeToSafe(btoa(string)));\n}\n\n/**\n * B64utToArrayBuffer takes a b64ut string and decodes it back into a string.\n * \n * @param   {B64} string \n * @returns {ArrayBuffer}\n */\n function B64utToArrayBuffer(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0)).buffer;\n};\n\n\n\n/**\n * B64utToUint8Array takes a b64ut string and decodes it back into a string.\n * \n * @param   {B64} string \n * @returns {ArrayBuffer}\n */\n function B64utToUint8Array(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));\n};\n\n/**\n * URIUnsafeToSafe converts any URI unsafe string to URI safe.  \n * \n * @param   {string} ub64t \n * @returns {string} b64ut \n */\nfunction URIUnsafeToSafe(ub64) {\n\treturn ub64.replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n/**\n * base64t removes base64 padding if applicable.   \n * \n * @param   {string} base64 \n * @returns {string} base64t\n */\nfunction base64t(base64) {\n\treturn base64.replace(/=/g, '');\n}", "\"use strict\";\n\nexport {\n\tParams,\n\tCurve,\n\tFamily,\n\tGenus,\n\tHashAlg,\n\tHashSize,\n\tSigSize,\n\tXSize,\n\tDSize,\n\tUse,\n}\n\n// See notes on the Go implementation of Coze for more on Alg, Genus, Family,\n// HashAlg, CurveAlg, and  Use.\n\n/** \n* @typedef  {String} Alg     - Algorithm             e.g. \"ES256\" \n* @typedef  {String} Genus   - Genus.                e.g. \"SHA2\", \"ECDSA\".\n* @typedef  {String} Family  - Family.               e.g. \"SHA\", \"EC\".\n* @typedef  {String} Hash    - Hashing algorithm.    e.g. \"SHA-256\".\n* @typedef  {String} Curve   - Elliptic curve.       e.g. \"P-256\".\n* @typedef  {String} Use     - Algorithm use.        e.g. \"sig\" or \"enc\"\n/*\n\n/** \n* Params holds all relevant values for an `alg`. If values are not applicable\n  for a particular `alg`, values may be populated with the zero value, e.g.\n  for the hash alg \"SHA-256\" Curve's value is 0.\n* @typedef  {Object}  Params\n* @property {string}  Name      - Alg string Name.\n* @property {Genus}   Genus     - Genus                              e.g. \"SHA2\", \"ECDSA\".\n* @property {Family}  Family    - Family                             e.g. \"SHA\", \"EC\".\n* @property {Hash}    Hash      - Hash is the hashing algorithm.     e.g. \"SHA-256\".\n* @property {Number}  HashSize  - Size in bytes of the digest.       e.g. 32 for \"SHA-256\".\n* @property {Number}  SigSize   - Size in bytes of the signature.    e.g. 64 for \"ES256\".\n* @property {Number}  XSize     - Size in bytes of `x`.              e.g. \"64\" for ES256\n* @property {Number}  DSize     - Size in bytes of `d`.              e.g. \"32\" for ES256\n* @property {Curve}   Curve     - Curve is the elliptic curve.       e.g. \"P-256\".\n* @property {Use}     Use       - Algorithm use.                     e.g. \"sig\".\n/*\n\n/**\n * Param reports all relevant values for a given `alg`.\n * @param {string} alg  String. Alg is the string representation of a coze.Alg\n * @returns {Params}    Params object with populated values for relevant fields\n*/\nfunction Params(alg) {\n\t/** @type {Params} */\n\tlet p = {\n\t\tName: alg\n\t};\n\tp.Genus = Genus(alg);\n\tp.Family = Family(alg);\n\tp.Hash = HashAlg(alg);\n\tp.HashSize = HashSize(alg);\n\n\t// SigAlg parameters\n\ttry {\n\t\tp.Curve = Curve(alg);\n\t\tp.Use = Use(alg);\n\t\tp.SigSize = SigSize(alg);\n\t\tp.XSize = XSize(alg);\n\t\tp.DSize = DSize(alg);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\treturn p;\n}\n\n/**\n * Genus returns the genus for an alg (ECDSA, EdDSA, SHA-2, SHA-3).\n * See notes on the Go implementation of Coze for more on genus.\n * @param   {Alg}     alg \n * @returns {Use}\n * @throws error\n */\nfunction Genus(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\t\treturn \"ECDSA\";\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"EdDSA\";\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA-512\":\n\t\t\treturn \"SHA2\";\n\t\tcase \"SHA3-224\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHA3-384\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE128\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn \"SHA3\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Genus: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Family returns the family for an alg (EC and SHA).\n * See notes on the Go implementation of Coze for more on family.\n * @param   {Alg}     alg \n * @returns {Family}\n * @throws error\n */\nfunction Family(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"EC\";\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA-512\":\n\t\tcase \"SHA3-224\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHA3-384\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE128\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn \"SHA\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Family:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Hash returns the hashing algorithm for the given algorithm.  A hash alg can\n * return itself. \n * See notes on the Go implementation of Coze for more.\n * @param   {Alg}   alg \n * @returns {Hash}  Hash Alg as a string, e.g. \"SHA-256\".\n * @throws  error\n */\nfunction HashAlg(alg) {\n\tswitch (alg) {\n\t\tcase \"SHA-224\":\n\t\tcase \"ES224\":\n\t\t\treturn \"SHA-224\";\n\t\tcase \"SHA-256\":\n\t\tcase \"ES256\":\n\t\t\treturn \"SHA-256\";\n\t\tcase \"SHA-384\":\n\t\tcase \"ES384\":\n\t\t\treturn \"SHA-384\";\n\t\tcase \"SHA-512\":\n\t\tcase \"ES512\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn \"SHA-512\";\n\t\tcase \"SHAKE128\":\n\t\t\treturn \"SHAKE128\";\n\t\tcase \"SHAKE256\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"SHAKE256\";\n\t\tcase \"SHA3-224\":\n\t\t\treturn \"SHA3-224\";\n\t\tcase \"SHA3-256\":\n\t\t\treturn \"SHA3-256\";\n\t\tcase \"SHA3-384\":\n\t\t\treturn \"SHA3-384\";\n\t\tcase \"SHA3-512\":\n\t\t\treturn \"SHA3-512\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashAlg:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * HashSize returns the hashing algorithm for the given algorithm.  \n * \n * SHAKE128 has 128 bits of pre-collision resistance and a capacity of 256,\n * although it has arbitrary output size. SHAKE256 has 256 bits of pre-collision\n * resistance and a capacity of 512, although it has arbitrary output size.\n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg - alg string\n * @returns {Number}  size of the hash alg in bytes.  (e.g. 32)\n * @throws error\n */\nfunction HashSize(alg) {\n\t// If given alg that is not a hash, attempt to retrieve the hash alg\n\tlet ha = HashAlg(alg);\n\tif (ha != alg) {\n\t\talg = ha;\n\t}\n\tswitch (alg) {\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA3-224\":\n\t\t\treturn 28;\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHAKE128\":\n\t\t\treturn 32;\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA3-384\":\n\t\t\treturn 48;\n\t\tcase \"SHA-512\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn 64;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * SigSize returns the signature size for the given algorithm.  \n * \n * Curve P-521 uses 521 bits.  This is then padded up the the nearest byte (528)\n * for R and S. 132 = (528*2)/8\n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}      alg - Sig alg string, e.g. \"ES256\"\n * @returns {Number}   size of the sig alg in bytes.  (e.g. 64)\n * @throws             error\n */\nfunction SigSize(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn 56\n\t\tcase \"ES256\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn 64\n\t\tcase \"ES384\":\n\t\t\treturn 96\n\t\tcase \"Ed448\":\n\t\t\treturn 114\n\t\tcase \"ES512\":\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.SigSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n\n\n/**\n * XSize returns the signature size for the given algorithm.  \n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528) for R and S. (528*2)/8 = 132.\n *\n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg - Sig alg string, e.g. \"ES256\"\n * @returns {Number}  size of the sig alg in bytes.  (e.g. 64)\n * @throws error\n */\nfunction XSize(alg) {\n\tswitch (alg) {\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn 32\n\t\tcase \"ES224\":\n\t\t\treturn 56\n\t\tcase \"Ed448\":\n\t\t\treturn 57\n\t\tcase \"ES256\":\n\t\t\treturn 64\n\t\tcase \"ES384\":\n\t\t\treturn 96\n\t\tcase \"ES512\":\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.XSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n\n/**\n * DSize returns the signature size for the given algorithm.  \n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528). (528)/8 = 66.\n *\n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg - Sig alg string, e.g. \"ES256\"\n * @returns {Number}  size of the sig alg in bytes.  (e.g. 64)\n * @throws error\n */\nfunction DSize(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn 28\n\t\tcase \"ES256\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn 32\n\t\tcase \"ES384\":\n\t\t\treturn 48\n\t\tcase \"Ed448\":\n\t\t\treturn 57\n\t\tcase \"ES512\":\n\t\t\treturn 66\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.DSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Curve returns the curve algorithm for the given algorithm.  \n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}    alg \n * @returns {Curve}  The curve alg as a string, e.g. \"SHA-256\".\n * @throws error\n */\nfunction Curve(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn \"P-224\";\n\t\tcase \"ES256\":\n\t\t\treturn \"P-256\";\n\t\tcase \"ES384\":\n\t\t\treturn \"P-384\";\n\t\tcase \"ES512\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\treturn \"P-521\";\n\t\tcase \"Ed25519\":\n\t\t\treturn \"Curve25519\";\n\t\tcase \"Ed448\":\n\t\t\treturn \"Curve448\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Curve: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Use returns the use for the given algorithm.  Only \"sig\" or \"enc\" are\n * currently valid, and Coze currently only uses \"sig\".\n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg \n * @returns {Use}     The string \"sig\" or \"enc\"\n * @throws error\n */\nfunction Use(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"sig\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Use: unsupported algorithm: \" + alg);\n\t}\n}", "\"use strict\";\n\nimport * as BSCNV from './base_convert.js';\nimport * as Alg from './alg.js';\nimport * as CozeKey from './cozekey.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tCryptoKey,\n};\n\nvar CryptoKey = {\n\t/**\n\t * New returns a ECDSA CryptoKeyPair. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKeyPair\n\t * @param  {Alg}           [alg=ES256] - Alg of the key to generate.  (e.g. \"ES256\")\n\t * @return {CryptoKeyPair}             - CryptoKeyPair\n\t * @throws \n\t */\n\tNew: async function(alg) {\n\t\tif (isEmpty(alg)) {\n\t\t\talg = \"ES256\"\n\t\t}\n\t\t// Javascript only supports ECDSA, and doesn't support ES192 or ES224.  See\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams\n\t\tif (Alg.Genus(alg) !== \"ECDSA\" || alg == \"ES224\" || alg == \"ES192\") {\n\t\t\tthrow new Error(\"CryptoKey.New: Unsupported key algorithm:\" + alg);\n\t\t}\n\n\t\tlet keyPair = await window.crypto.subtle.generateKey({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: Alg.Curve(alg)\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[\"sign\", \"verify\"]\n\t\t);\n\t\treturn keyPair;\n\t},\n\n\n\t/**\n\t * FromCozeKey takes a Coze Key and returns a Javascript CryptoKey.  Only\n\t * supports ECDSA since Crypto.subtle only supports ECDSA. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key \n\t * @param   {CozeKey}    cozeKey     Coze key.\n\t * @param   {Boolean}    [public=false]    Return only a public key.\n\t * @returns {CryptoKey}              Javascript CryptoKey\n\t * @throws\n\t */\n\tFromCozeKey: async function(cozeKey, onlyPublic) {\n\t\tif (Alg.Genus(cozeKey.alg) != \"ECDSA\") {\n\t\t\tthrow new Error(\"CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: \" + cozeKey.alg);\n\t\t}\n\n\t\t// Create a new JWK that can be used to create and \"import\" a CryptoKey\n\t\tvar jwk = {};\n\t\tjwk.use = \"sig\";\n\t\tjwk.crv = Alg.Curve(cozeKey.alg);\n\t\tjwk.kty = \"EC\";\n\n\t\tlet half = Alg.XSize(cozeKey.alg) / 2;\n\t\tlet xyab = await BSCNV.B64utToUint8Array(cozeKey.x);\n\t\tlet xab = xyab.slice(0, half)\n\t\tlet yab = xyab.slice(half)\n\t\tjwk.x = await BSCNV.ArrayBufferTo64ut(xab);\n\t\tjwk.y = await BSCNV.ArrayBufferTo64ut(yab);\n\t\t\n\t\t// Public CryptoKey \"crypto.subtle.importKey\" needs key use to be \"verify\"\n\t\t// even though this doesn't exist in JWK RFC or IANA registry. (2021/05/12)\n\t\t// Gawd help us.  Private CryptoKey needs key `use` to be \"sign\".\n\t\tif (isEmpty(cozeKey.d) || onlyPublic) {\n\t\t\tvar signOrVerify = \"verify\";\n\t\t} else {\n\t\t\tsignOrVerify = \"sign\";\n\t\t\tjwk.d = cozeKey.d;\n\t\t}\n\n\t\tvar cryptoKey = await crypto.subtle.importKey(\n\t\t\t\"jwk\",\n\t\t\tjwk, {\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: jwk.crv,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[signOrVerify]\n\t\t);\n\n\t\treturn cryptoKey;\n\t},\n\n\n\t/**\n\t * ToPublic accepts a Javascript CryptoKey and returns a public\n\t * Javascript CryptoKey.  \n\t *\n\t * @param   {CryptoKey} cryptoKey   CryptoKey\n\t * @returns {CryptoKey}             Public Javascript CryptoKey\n\t */\n\tToPublic: async function(cryptoKey) {\n\t\tdelete cryptoKey.d; // Remove private `d` from the key.  \n\t\t// Only [\"verify\"] is a valid `key_ops` value for a public CryptoKey.\n\t\t// `key_ops` must be an array.\n\t\tcryptoKey.key_ops = [\"verify\"];\n\t},\n\n\t/**\n CryptoKeyToCozeKey returns a Coze Key from Javascript's \"CryptoKey\" type.\n (https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) Coze keys are\n similiar to JOSE JWK's but has a few significant differences. See the Coze docs\n for more on these differences.  \n\n - Coze Byte-to-string values are always b64ut, \"RFC 4648 base64 URI Safe\n    Truncated\".\n - Coze keys also use the field `alg` to denote everything about the key:\n    it's use, hashing algorithm, curve, family, signature size, private\n    component size, public component size, etc...\n - A Coze key's Thumbprint's hashing algorithm must always be in alignment\n    with the alg.  This is unlike JOSE which appears to use SHA-256 even for\n    keys that don't use that algorithm.  \n \n This function currently only supports ECDSA (ES256. ES384, ES512) as\n crypto.subtle only supports these ECDSA algorithms. From Cryptokey, `exported`\n key output should is in the following form.  \n\n{\n\t\"crv\": \"P-256\",\n\t\"d\": \"GwJgQIcbB29IfWO46QZwansE5XVVOg_CfafcpGk3K9I\",\n\t\"key_ops\": [\n\t\t\"sign\",\n\t\t\"verify\"\n\t],\n\t\"kty\": \"EC\",\n\t\"x\": \"bMgUwXPLFR5WPERFIdUR8f6J9znFlM4fL-TaYr7YNSo\",\n\t\"y\": \"vuU0bE-JafF1zEW_MbL-oaO0eGltDeMHIfc_bxkdCHU\",\n\t\"use\": \"sig\"\n}\n\t\t\nSome aspects of the Javascript exported key are in conflict with JOSE.  The\n`delete`s below are for reference of how out of alignment the Javascript\nrepresentation is from JOSE.  If for some reason a JOSE representation is\nrequired, the deletes are suggested.  \n\n`delete exported.key_ops;`\n\nAccording to RFC 7517 Section 4.3, \"use\" is mutually exclusive with\nkey_ops. \n\n`delete exported[\"ext\"];`\n\n`ext` is define by the Web Cryptography API and does not appear in the\ncore JOSE RFC's.  It stands for \"extractable\".  Since the key is already\n\"extracted\" we don't care, and we're not going to burden downstream with\nit.  However, this may need to be added again later if the key is further\nmanipulated by SubtleCrypto. \n\nCoze does not use \"crv\", \"kty\", or \"use\" and instead relies solely on\n\"alg\". Since alg is not given, it's assumed from `crv` while `kty`is\nignored.\n\nWhy are we exporting to JWK?\n\n1. There's no access to the key fields without exporting.  (The\n\t\tbrowser hides the information from Javascript.)\n2. The exporting formats are limited.  \n3. Can't export to \"raw\" because \"raw\" appears to only work on public\n\t\tkeys.  This may be a private key. \n\t * @param   {CryptoKey}   cryptoKey \n\t * @returns {CozeKey}     Coze key.\n\t * @throws \n\t */\n\tToCozeKey: async function(cryptoKey) {\n\t\tlet exported = await window.crypto.subtle.exportKey(\n\t\t\t\"jwk\",\n\t\t\tcryptoKey\n\t\t);\n\n\t\tvar czk = {};\n\t\tczk.alg = await CryptoKey.algFromCrv(exported.crv);\n\t\t// Concatenate x and y, but concatenation is done at the byte level, so:\n\t\t// unencode, concatenated, and encoded. \n\t\tlet xui8 = BSCNV.B64utToUint8Array(exported.x);\n\t\tlet yui8 = BSCNV.B64utToUint8Array(exported.y);\n\t\tvar xyui8 = new Uint8Array([\n\t\t\t...xui8,\n\t\t\t...yui8,\n\t\t]);\n\t\tczk.x = BSCNV.ArrayBufferTo64ut(xyui8.buffer);\n\n\t\t// Only private ECDSA keys have `d`.\n\t\tif (exported.hasOwnProperty('d')) {\n\t\t\tczk.d = exported.d;\n\t\t}\n\n\t\tczk.tmb = await CozeKey.Thumbprint(czk);\n\t\t// console.log(\"exported: \" + JSON.stringify(exported), \"Coze Key: \" + JSON.stringify(czk)); // Debugging\n\t\treturn czk;\n\t},\n\n\t/**\n\t * Uses a Javascript `CryptoKey` to sign a array buffer.  Returns array buffer\n\t * bytes.  \n\t *\n\t * The signing algorithm's hashing algorithm is used for the digest of the\n\t * payload.  \n\t * \n\t * Coze uses UTF-8 bytes for strings.  \n\t *\n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n\t * \n\t * @param   {CryptoKey}      cryptoKey          \n\t * @param   {ArrayBuffer}    payloadBuffer     \n\t * @returns {ArrayBuffer}    ArrayBuffer of sig\n\t */\n\tSignBuffer: async function(cryptoKey, arrayBuffer) {\n\t\tlet hashAlg = await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey);\n\n\t\tlet signature = await window.crypto.subtle.sign({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: hashAlg\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tarrayBuffer\n\t\t);\n\n\t\treturn signature; // Array Buffer\n\t},\n\n\t/**\n\t * SignBufferB64 signs a buffer with a CryptoKey and returns Hex. The input is\n\t * hashed before it's signed.\n\t *\n\t * @param   {CryptoKey}   cryptoKey       Private CryptoKey\n\t * @param   {ArrayBuffer} arrayBuffer     ArrayBuffer to sign. \n\t * @returns {string}      B64             B64\n\t */\n\tSignBufferB64: async function(cryptoKey, arrayBuffer) {\n\t\treturn await BSCNV.ArrayBufferTo64ut(await CryptoKey.SignBuffer(cryptoKey, arrayBuffer));\n\t},\n\n\t/**\n\t * SignString signs a string and returns Hex of\n\t *  the signature.  Coze uses UTF8 bytes for strings.  \n\t * @param {CryptoKey} cryptoKey      CryptoKey. Private key used for signing.\n\t * @param {string}    utf8           String. String to sign. \n\t * @returns {string}  hex.           String. Hex as string.\n\t */\n\tSignString: async function(cryptoKey, utf8) {\n\t\treturn await CryptoKey.SignBufferB64(cryptoKey, await BSCNV.SToArrayBuffer(utf8));\n\t},\n\n\t/**\n\t * VerifyArrayBuffer verifies an ArrayBuffer msg with an ArrayBuffer sig and\n\t * Javascript CryptoKey.\n\t * @param   {CryptoKey}   cryptoKey           Javascript CryptoKey.\n\t * @param   {ArrayBuffer} sig                 ArrayBuffer. Signature.\n\t * @param   {ArrayBuffer} msg                 ArrayBuffer. Message.\n\t * @returns {boolean}                         Boolean. Verified or not.\n\t */\n\tVerifyArrayBuffer: async function(cryptoKey, msg, sig) {\n\t\t// Guarantee key is not private to appease Javascript:\t\t\n\t\tawait CryptoKey.ToPublic(cryptoKey);\n\t\tlet hash = await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey);\n\t\t// console.log(cryptoKey, sig, msg, hash);\n\t\treturn await window.crypto.subtle.verify({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: hash\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tsig,\n\t\t\tmsg);\n\t},\n\n\t/**\n\t * VerifyMsg uses a public key to verify a string msg with a b64ut sig.\n\t * \n\t * @param   {CryptoKey}  cryptoKey         Javascript CryptoKey. \n\t * @param   {string}     msg               String that was signed.  \n\t * @param   {Sig}        sig               B64 signature.  \n\t * @returns {boolean}                      Boolean. If signature is valid.  \n\t */\n\tVerifyMsg: async function(cryptoKey, msg, sig) {\n\t\tlet msgab = await BSCNV.SToArrayBuffer(msg);\n\t\tlet sigab = await BSCNV.B64utToArrayBuffer(sig);\n\t\treturn CryptoKey.VerifyArrayBuffer(cryptoKey, msgab, sigab);\n\t},\n\n\t/**\n\t * GetSignHashAlgoFromCryptoKey gets the signing hashing algorithm from the\n\t * CryptoKey.  \n\t *\n\t * Javascript's CryptoKey explicitly requires a signing hashing algorithm, but\n\t * the CryptoKey itself may not explicitly contain that information. For\n\t * example, a ES256 key will have the curve (P-256) and the general key type\n\t * (ECDSA), but the hashing algo is not explicitly stated (SHA-256), nor is\n\t * the algorithm explicitly stated (ES256)\n\t *\n\t * However, for some CryptoKeys, the hashing algorithm is explicitly stated.\n\t * For example, \"RsaHashedKeyGenParams\" has the field \"hash\" which explicitly\n\t * denotes what hashing algorithm was used.  As of 2021/05/26,\n\t * \"EcKeyGenParams\" has no such field, so it must be assumed that certain\n\t * hashing algorithms are paired with certain curves.  \n\t *\n\t * The purpose of this function is to return the correct hashing digest for\n\t * all CryptoKeys regardless of their form.  \n\t * @param   {CryptoKey} CryptoKey          \n\t * @returns {String}    Hash       String. Name of hashing algorithm e.g. \"SHA-256\".\n\t */\n\tGetSignHashAlgoFromCryptoKey: async function(cryptoKey) {\n\t\t// let exported = await window.crypto.subtle.exportKey(\n\t\t// \t\"jwk\",\n\t\t// \tcryptoKey\n\t\t// );\n\t\t// console.log(cryptoKey.algorithm.namedCurve);\n\t\treturn Alg.HashAlg(await CryptoKey.algFromCrv(cryptoKey.algorithm.namedCurve));\n\t},\n\n\n\talgFromCrv: async function(crv) {\n\t\tswitch (crv) {\n\t\t\tcase \"P-224\":\n\t\t\t\tvar alg = \"ES224\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-256\":\n\t\t\t\talg = \"ES256\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-384\":\n\t\t\t\talg = \"ES384\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-521\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\t\talg = \"ES512\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\t\treturn alg;\n\t}\n}; // End CryptoKey", "\"use strict\";\n\nimport * as CTK from './cryptokey.js';\nimport * as Coze from './coze.js';\nimport * as Can from './canon.js';\nimport * as BSCNV from './base_convert.js';\nimport * as Enum from './alg.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tNewCozeKey,\n\tToPublicCozeKey,\n\tCorrect,\n\tValid,\n\tThumbprint,\n\tRevoke,\n\tIsRevoked,\n\n\tTmbCanon,\n}\n\n\n/**\n@typedef {import('./coze.js').Hex}  Hex\n@typedef {import('./coze.js').Alg}  Alg\n@typedef {import('./coze.js').Use}  Use\n@typedef {import('./coze.js').Sig}  Sig\n@typedef {import('./coze.js').Time} Time\n\nCoze key\n@typedef  {Object} CozeKey\n@property {Alg}    alg - Cryptographic signing or encryption algorithm - e.g. \"ES256\"\n@property {String} kid - Human readable, non programmatic, key identifier - e.g. \"Test Key\"\n@property {Time}   iat - Unix time key was created. e.g. 1624472390\n@property {Hex}    tmb - Key thumbprint e.g. \"0148F4CD9093C9CBE3E8BF78D3E6C9B824F11DD2F29E2B1A630DD1CE1E176CDD\"\n@property {Hex}    [d] - ECDSA private \"d\" component in Hex.  Required for ECDSA private Coze keys.  e.g. \"30C76C9EC4286DADEB0E1EBFF546A1B4A57DB4571412F953E053FB689D286C3C\"\n@property {Hex}    [x] - ECDSA public \"x\" component in Hex.  Required for ECDSA public Coze keys.    e.g. \"827ECBA80BE7421DD71A6C2819ABC1D988450EBB802B972AE22292FA0D538B6B\"\n@property {Hex}    [y] - ECDSA public \"y\" component in Hex.  Required for ECDSA public Coze keys.    e.g. \"8D45880FC2C9FD1DBBF28ED4CB973CD8D1CB4F93F422B1B90AC1DA4ED13CA9EC\"\n\n@typedef  {CozeKey} PrivateCozeKey - A Coze key containing any private components.  \n@typedef  {CozeKey} PublicCozeKey  - A Coze key containing no private components and required public components.  \n */\n\n// Coze key Thumbprint Canons.\nconst TmbCanon = [\"alg\", \"x\"];\n\n/**\n * NewCozeKey returns a new Coze key. \n * \n * @param   {Alg}     [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n * @returns {CozeKey}             - Coze key in Javascript object format\n */\nasync function NewCozeKey(alg) {\n\tif (isEmpty(alg)) {\n\t\talg = \"ES256\"\n\t}\n\tif (Enum.Genus(alg) == \"ECDSA\") {\n\t\tvar keyPair = await CTK.CryptoKey.New(alg);\n\t} else {\n\t\tthrow new Error(\"CozeKey.NewCozeKey: only ECDSA algs are currently supported.\");\n\t}\n\n\tlet CozeKey = await CTK.CryptoKey.ToCozeKey(keyPair.privateKey)\n\n\tCozeKey.iat = Math.floor(Date.now() / 1000); // To get Unix from js, divide by 1000.  \n\tCozeKey.tmb = await Thumbprint(CozeKey);\n\tCozeKey.kid = \"My Cyphr.me Key.\";\n\n\treturn CozeKey;\n}\n\n/**\n * Thumbprint generates Coze key thumbprint. \n *\n * @param   {CozeKey} cozeKey - Javascript object Coze key. \n * @returns {tmb}             - B64 thumbprint.\n * @throws \n */\nasync function Thumbprint(cozeKey) {\n\tif (isEmpty(cozeKey.alg) || isEmpty(cozeKey.x)) {\n\t\tthrow new Error(\"CozeKey.Thumbprint: alg or x  is empty.\");\n\t}\n\treturn Can.CanonHash64(cozeKey, await Enum.HashAlg(cozeKey.alg), TmbCanon);\n};\n\n/**\n * Valid validates a private Coze key.  See notes on `Correct`.\n *\n * @param   {CozeKey}    privateCozeKey  Private Coze key. \n * @returns {boolean}                    Valid.   \n */\nasync function Valid(privateCozeKey) {\n\tif (isEmpty(privateCozeKey.d)) {\n\t\tconsole.error(\"Coze key missing `d`\");\n\t\treturn false;\n\t}\n\ttry {\n\t\tlet msg = `7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q`;\n\t\tlet sig = await Coze.Sign(msg, privateCozeKey);\n\t\treturn await Coze.Verify(msg, privateCozeKey, sig);\n\t} catch (e) {\n\t\tconsole.error(e);\n\t}\n\treturn false;\n}\n\n/**\n * Correct checks for the correct construction of a Coze key.  Always returns\n * true if no error.\n\n * Correct:\n * 1. Ensures required headers exist.\n * 2. Checks if the length of public components are correct.\n * 3. If the key is private (containing private components) generates and verifies a\n *    signature, thus verifying the private key.\n *\n * Correct may return \"true\" on cryptographically invalid public keys since\n * public keys cannot (necessarily) be validated without verifying a signed\n * message. Use function \"Verify\" for public keys with a signed message.  Use\n * function \"Correct\" to check for the correct construction of a public key.  \n * \n * @param   {CozeKey}    cozeKey  Object. Coze key. \n * @returns {boolean}             Boolean. Always returns true unless error.   \n * @throws                        \n */\nasync function Correct(cozeKey) {\n\tlet required = [\n\t\t'alg',\n\t\t'tmb',\n\t]\n\n\tif (isEmpty(ck) || typeof ck !== \"object\") {\n\t\tfalse;\n\t}\n\tif (Object.keys(ck).length >= 2 && !isEmpty(ck.alg) && !isEmpty(ck.tmb) && (isEmpty(ck.x) || isEmpty(ck.iat))) {\n\t\treturn true;\n\t}\n\t// return false;\n\n\n\tlet tmbOnly = IsTmbOnly(cozeKey);\n\tif (!tmbOnly) {\n\t\tconsole.debug('not a tmb only key');\n\t\trequired.push([\"iat\", \"x\"]);\n\t}\n\n\tfor (let element of required) {\n\t\tif (!(element in cozeKey)) {\n\t\t\tthrow new Error(\"CozeKey.Correct: No '\" + element + \"' in Coze key\");\n\t\t}\n\t}\n\n\tif (cozeKey.alg == \"Ed25519\") {\n\t\tif (cozeKey.x.length < 64) { // Ed25519's public key is 32 bytes (64 in Hex)\n\t\t\tthrow new Error(\"CozeKey.Correct: x is too short.  Has length: \" + cozeKey.x.length);\n\t\t}\n\t}\n\n\tif (tmbOnly) {\n\t\treturn true;\n\t}\n\n\t// Sanity check - No keys from the future allowed.\n\tif (cozeKey.iat > Math.round((Date.now() / 1000))) {\n\t\tthrow new Error(\"CozeKey.Correct: cannot have iat greater than present time\");\n\t}\n\n\tif (Enum.Genus(cozeKey.alg) == \"ECDSA\") {\n\t\t// Hex is twice the size of bytes.  \n\t\tlet size = (Enum.HashSize(Enum.HashAlg(cozeKey.alg))) * 2;\n\t\tif (cozeKey.x.length < size) {\n\t\t\tthrow new Error(\"CozeKey.Correct: x is too short.  Has length: \" + cozeKey.x.length);\n\t\t}\n\t\tif (cozeKey.y.length < size) { // y is required for ECDSA\n\t\t\tthrow new Error(\"CozeKey.Correct: y is too short.  Has length: \" + cozeKey.y.length);\n\t\t}\n\t}\n\n\t// Recalculate the tmb and compare\n\tlet tmb = await Thumbprint(cozeKey);\n\tif (tmb != cozeKey.tmb) {\n\t\tthrow new Error(\"CozeKey.Correct: tmb does not match: \" + tmb);\n\t}\n\n\t// If private key, validate by signing and verifying.\n\tif (!isEmpty(cozeKey.d)) {\n\t\t// console.log(\"Signing for private key. \");\n\t\tlet mld = \"Test Signing\";\n\t\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(cozeKey);\n\t\tlet mldBuffer = await BSCNV.SToArrayBuffer(mld)\n\t\tlet sig = await CTK.CryptoKey.SignBuffer(cryptoKey, mldBuffer);\n\t\tlet pubKey = await CTK.CryptoKey.FromCozeKey(cozeKey, true);\n\t\tlet result = await CTK.CryptoKey.VerifyArrayBuffer(pubKey, mldBuffer, sig);\n\n\t\tif (result !== true) {\n\t\t\tthrow new Error(\"CozeKey.Correct: private key invalid.\");\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * ToPublicCozeKey takes a public or private Coze key and returns a normalized\n * public Coze key. Since this takes a \"public or private\" Coze key, this\n * function can act as \"public key sanitization\".\n *\n * Only supports ECDSA/EdDSA at the moment.  \n * \n * @param   {CozeKey} cozeKey  - Javascript object Coze key (public or private). \n * @returns {PublicCozeKey}    - Coze key that contains no private components.  \n * @throws\n */\nasync function ToPublicCozeKey(cozeKey) {\n\tlet nck = {};\n\tnck.alg = cozeKey.alg;\n\tnck.iat = cozeKey.iat;\n\tif (!isEmpty(cozeKey.kid)) {\n\t\tnck.kid = cozeKey.kid;\n\t}\n\tnck.x = cozeKey.x;\n\n\tswitch (Enum.Genus(nck.alg)) {\n\t\tcase \"ECDSA\":\n\t\t\tnck.y = cozeKey.y;\n\t\t\tbreak;\n\t\tcase \"EdDSA\":\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):\" + nck.alg);\n\t}\n\n\tnck.tmb = await Thumbprint(nck);\n\n\t// Return object in order.  \n\tnck = await Can.Canon(nck);\n\treturn nck;\n}\n\n\n/**\n * Revoke generates a self revoke message and sets the input key as revoked.  \n *\n * @param   {CozeKey}   cozeKey            Private Coze key.\n * @param   {String}    [msg]              Optional, human readable non programmatic reason for revoking the key.\n * @returns {coze}                         coze returned from signing the message.\n * @throws  error                          if cryptoKeyPrivate is nil or invalid.\n */\nasync function Revoke(cozeKey, msg) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"CozeKey.Revoke: Private key not set.  Cannot sign message\");\n\t}\n\n\tvar coze = {};\n\tcoze.pay = {};\n\tif (!isEmpty(msg)) { // Optional revoke message. \n\t\tcoze.pay.msg = msg;\n\t}\n\tcoze.pay.rvk = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\t// SignCoze does not allow revoked keys to sign messages.  Temporarily remove\n\t// key.revoke and then set back afterward, otherwise set key with new revoke. \n\tlet prevRvk = cozeKey.rvk;\n\tdelete cozeKey.rvk;\n\tcoze = await Coze.SignCoze(coze, cozeKey);\n\tif (prevRvk !== undefined) {\n\t\tcozeKey.rvk = prevRvk;\n\t}else{\n\t\tcozeKey.rvk = coze.pay.rvk;\n\t}\n\n\treturn coze\n};\n\n/**\n * IsRevoked returns true if a key or a coze is marked as revoked. `rvk` should\n * be an integer Unix timestamp, however this function also checks for the\n * string \"true\" as well as the bool `true`.\n *\n * Messages self-revoking keys must have `rvk` with an integer value greater\n * than 0.  \n *\n * @param   {CozeKey|Coze}   cozeKey  Coze key or coze          \n * @param   {String}         [msg]    Optional reason for revoking the key.    \n * @returns {boolean}                 Revoked or not. \n */\nfunction IsRevoked(cozeKey) {\n\tif (isEmpty(cozeKey.rvk) || !(parseInt(cozeKey.rvk) > 0 )) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as Can from './canon.js'; // import as \"Can\" since func \"Canon\" will conflict in `coze.join.js`. \nimport * as Enum from './alg.js';\nimport * as CZK from './cozekey.js';\nimport * as CTK from './cryptokey.js';\nimport * as BSCNV from './base_convert.js';\n\nexport {\n\tSign,\n\tSignCoze,\n\tVerify,\n\tVerifyCoze,\n\tVerifyCozeArray,\n\tMeta,\n\tPayCanon,\n\n\t// Helpers\n\tisEmpty,\n\tisBool,\n}\n\n/**\n@typedef {import('./cozekey.js').CozeKey} CozeKey\n@typedef {import('./alg.js').Alg}     Alg\n@typedef {import('./canon.js').Canon} Canon\n\nBasic Coze Types\n@typedef  {String} B64       - Coze b64ut (RFC 4648 base64 url truncated)\n@typedef  {String} Message   - A not-hashed message to be signed. \n@typedef  {B64}    Digest    - A digest in b64ut.\n@typedef  {B64}    Sig       - The signature.   \n@typedef  {Number} Time      - The Unix time.\n\nPay contains the standard `Coze.Pay` fields.  \n@typedef  {Object} Pay  \n@property {Alg}    alg  - Algorithm -           e.g. \"ES256\".\n@property {Time}   iat  - Unix time of signing. e.g. 1623132000.\n@property {Hex}    tmb  - Signing thumbprint    e.g. cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk\n@property {String} typ  - Type.                 e.g. \"cyphr.me/msg/create\".\n\nCoze is a signed coze object.  See docs for more about `coze`.\n@typedef  {Object}  Coze    \n@property {Pay}     pay    - The `pay`.  See Pay.  \n@property {Sig}     sig    - The Hex signature.  \n@property {B64}     [cad]  - Canonical digest of `pay`.     e.g. LSgWE4vEfyxJZUTFaRaB2JdEclORdZcm4UVH9D8vVto\n@property {Array}   [can]  - The canon fields of pay.       e.g.  [\"alg\", \"iat\", \"msg\", \"tmb\", \"typ\"]\n@property {B64}     [czd]  - Coze digest.\n@property {CozeKey} [key]  - Coze Key used to sign `coze`.  \n\nVerifiedArray - Used when verifying array of cozies.  \n@typedef  {Object}  VerifiedArray\n@property {boolean} VerifiedAll   - Indicates if whole array was verified.  False on error or if anything was not verified.\n@property {number}  VerifiedCount - Number of objects verified.  \n@property {number}  FailedCount   - Number of objects that failed verification.  \n@property {Coze[]}  FailedCoze    - Objects that failed verification.\n*/\n\n// PayCanon is the standard coze.pay fields.\nconst PayCanon = [\"alg\", \"iat\", \"tmb\", \"typ\"];\n\n/**\n * Sign signs message with private Coze key and returns b64ut sig.\n * @param   {String}        message    message object/string.\n * @param   {CozeKey}       cozeKey    Private coze key.        \n * @returns {B64}                      b64ut `sig`.  Empty on invalid. \n * @throws  error                      invalid key/parse error.  \n */\nasync function Sign(message, cozeKey) {\n\tlet cryptokey = await CTK.CryptoKey.FromCozeKey(cozeKey);\n\treturn CTK.CryptoKey.SignBufferB64(\n\t\tcryptokey,\n\t\tawait BSCNV.SToArrayBuffer(message)\n\t);\n}\n\n/**\n * SignCoze signs in place coze.pay with a private Coze key. Returns the same,\n * but updated, coze.\n * \n * `pay` will be updated with values for:\n * 1. `alg` based on key.\n * 2. `iat` to now.\n * 3. `tmb` recalculated from key.\n *\n * @param   {Coze}      coze       Object coze or string coze\n * @param   {CozeKey}   cozeKey    A private coze key.        \n * @param   {Array}     [canon]    Array for canonical keys. [Optional]\n * @returns {coze}                 The same coze as input.\n * @throws  error                  invalid key/parse error.  \n */\nasync function SignCoze(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"Coze: Cannot sign with revoked key.\");\n\t}\n\n\tcoze.pay.alg = cozeKey.alg;\n\tcoze.pay.iat = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\tcoze.pay.tmb = await CZK.Thumbprint(cozeKey);\n\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\tlet pay = await JSON.stringify(coze.pay);\n\tconsole.log(pay);\n\tcoze.sig = await Sign(pay, cozeKey);\n\treturn coze;\n}\n\n\n\n\n/**\n * Verify verifies a `pay` with `sig` and returns a boolean.\n *\n * @param  {String}   message    Message\n * @param  {CozeKey}  cozekey    Coze key for message validation. \n * @param  {Sig}      sig        Signature.   \n * @return {boolean}             invalid key/parse error. \n * @throws error\n */\nasync function Verify(message, cozekey, sig) {\n\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(cozekey, true);\n\t// console.log(message, cozekey, sig, cryptoKey);\n\treturn CTK.CryptoKey.VerifyMsg(\n\t\tcryptoKey,\n\t\tmessage,\n\t\tsig,\n\t);\n};\n\n/**\n * VerifyCoze returns a boolean.  Parameter `coze` must have `coze.pay` and\n * optionally `coze.sig` and `coze.key`.\n *\n * If parameters `pubkey` or `sig` are set they will respectively overwrite\n * `coze.key` and `coze.sig`.\n * @param  {Coze}     coze         `coze` with optional `key` and/or `sig` set.  \n * @param  {CozeKey}  [cozeKey]    CozeKey to use to validate the coze message. \n * @param  {Sig}      [sig]        String.  Hex sig.   \n * @return {boolean}               Valid or not\n * @throws error\n */\nasync function VerifyCoze(coze, cozeKey) {\n\tif (coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"Coze.VerifyCoze: pay.tmb does not match key.tmb.\");\n\t}\n\tlet pay = await JSON.stringify(coze.pay);\n\treturn Verify(pay, cozeKey, coze.sig);\n}\n\n\n\n\n\n/**\n * VerifyCozeArray verifies an array of `coze`s and returns a single \"VerifiedArray\" object.\n *\n * @param  {coze[]}           coze       - Javascript object.  Coze Javascript Object or string.   \n * @param  {CozeKey}        [pubkey] - Javascript object.  CozeKey.   \n * @return {VerifiedArray}\n * @throws error\n */\nasync function VerifyCozeArray(coze, CozeKeyPublic) {\n\tif (!Array.isArray(coze)) {\n\t\treturn VerifyCoze(coze, CozeKeyPublic)\n\t}\n\n\t/** @type {VerifiedArray} verifiedObj */\n\tvar verifiedObj = {\n\t\tVerifiedAll: false,\n\t\tVerifiedCount: 0,\n\t\tFailedCount: 0,\n\t\tFailedCoze: [],\n\t};\n\n\tlet copy = [...coze]; // Copy so original isn't modified. \n\n\tfor (let i = 0; i < copy.length; i++) {\n\t\tlet c = copy[i];\n\t\tif (!isEmpty(c.coze)) { // \"coze\" encapsulated?\n\t\t\tc = c.coze;\n\t\t}\n\n\t\tlet valid = await VerifyCoze(c, CozeKeyPublic);\n\t\tif (valid) {\n\t\t\tverifiedObj.VerifiedCount++;\n\t\t} else {\n\t\t\tverifiedObj.FailedCount++;\n\t\t\tverifiedObj.FailedCoze.push(copy);\n\t\t}\n\t}\n\n\tif (verifiedObj.FailedCount == 0) {\n\t\tverifiedObj.VerifiedAll = true;\n\t}\n\n\treturn verifiedObj;\n};\n\n\n\n\n\n/**\nMeta recalculates [can, cad, czd], for a given `coze`. Coze.Pay,\nCoze.Pay.Alg, and Coze.Sig must be set.  Meta does no cryptographic\nverification.\n *\n * The input `coze` must always have the field `pay` set.\n *\n * Input variable `coze` may or may not be encapsulated in a `coze` JSON name.\n * If the field `coze` does not appear in the first level of input `coze` object\n * it is assume that parameter `coze` is a coze object.\n *\n * The input must also have `coze.key` or parameter \"pubkey\" and `coze.sig` or\n * parameter \"sig\".  If both the parameter and the respective coze component is\n * populated (`coze.key` and `pubkey` or `coze.sig` and `sig`) the parameters\n * (pubkey, sig) will overwrite coze components (`coze.key`, `coze.sig`).  If\n * neither are given an error is thrown. \n *\n * @param  {coze} coze               coze.   \n * @throws {Error}                   JSON parse exception or other Error.  \n * @return {Meta}                    {pay, key, iat, can, cad, czd, tmb, sig}\n * \n */\nasync function Meta(coze) {\n\t// console.log(coze, pubkey, sig); // debugging\n\t// Old, probably move to the sign verify page.\n\t// \tif (Array.isArray(coze)) { // Don't attempt for arrays.\n\t// \t\tthrow new Error(\"Coze.Meta: Coze cannot be array.\");\n\t// \t}\n\t// \tlet c = {};\n\t// \tif (typeof coze == \"string\") {\n\t// \t\tc = JSON.parse(coze); // May throw error\n\t// \t} else {\n\t// \t\tc = {\n\t// \t\t\t...coze\n\t// \t\t}; // Copy of original.\n\t// \t}\n\n\t// \t// Is `coze` \"coze\" encapsulated?  If so, unencapsulate.\n\t// \tif (!isEmpty(c.coze)) {\n\t// \t\tc = c.coze;\n\t// \t}\n\n\t// \t/** @type {Meta} meta */\n\t// \tvar meta = {};\n\t// \tmeta.pay = c.pay;\n\t// \tif (isEmpty(meta.pay)) {\n\t// \t\tthrow new Error(\"Coze.Meta: A pay is not set.\");\n\t// \t}\n\n\t// \t// If set, pubkey overwrites key. \n\t// \tif (!isEmpty(pubkey)) {\n\t// \t\tmeta.key = await CZK.ToPublicCozeKey(pubkey); // sanitizes and recalcs tmb\n\t// \t} else {\n\t// \t\tmeta.key = await CZK.ToPublicCozeKey(c.key); // sanitizes and recalcs tmb\n\t// \t}\n\t// \tif (isEmpty(meta.key)) {\n\t// \t\tthrow new Error(\"Coze.Meta: A public key is not set.\");\n\t// \t}\n\t// console.log(meta.pay.tmb !== meta.key.tmb);\n\n\t// \tif (meta.pay.tmb !== meta.key.tmb) {\n\t// \t\tthrow new Error(\"Coze.Meta: `pay.tmb` does not match `key.tmb`.\");\n\t// \t}\n\n\t// \tif (!isEmpty(sig)) {\n\t// \t\tmeta.sig = sig;\n\t// \t} else {\n\t// \t\tmeta.sig = c.sig;\n\t// \t}\n\t// \tif (isEmpty(meta.sig)) {\n\t// \t\tthrow new Error(\"Coze.Meta: A sig is not set.\");\n\t// \t}\n\n\n\tcoze.can = await Can.Canon(coze.pay);\n\n\t// TODO serialize don't call cannon hash\n\t// Calculate cad\n\tcoze.cad = await BSCNV.ArrayBufferTo64ut(await Can.CanonHash(coze.pay, Enum.HashAlg(coze.pay.alg)));\n\n\t// Calculate czd\n\tlet czdIn = await BSCNV.SToArrayBuffer('{\"cad\":\"' + coze.cad + '\",\"sig\":\"' + coze.sig + '\"}');\n\tcoze.czd = await BSCNV.ArrayBufferTo64ut(await crypto.subtle.digest(Enum.HashAlg(coze.pay.alg), czdIn));\n\treturn coze;\n}\n\n\n\n///////////////////////////////////\n// Helpers\n///////////////////////////////////\n\n/**\n * isEmpty is a helper function to determine if thing is empty. \n * \n * Objects are empty if they have no keys. (Returns len === 0 of object keys.)\n *\n * Functions are considered always not empty. \n * \n * NaN returns true.  (NaN === NaN is always false, as NaN is never equal to\n * anything. NaN is the only JavaScript value unequal to itself.)\n *\n * Don't use on HTMl elements. For HTML elements, use the !== equality check\n * (element !== null).\n *\n * Cannot use CryptoKey with this function since (len === 0) always. \n *\n * @param   {any}     thing    Thing you wish was empty.  \n * @returns {boolean}          Boolean.  \n */\nfunction isEmpty(thing) {\n\tif (typeof thing === 'function') {\n\t\treturn false;\n\t}\n\n\tif (thing === Object(thing)) {\n\t\tif (Object.keys(thing).length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!isBool(thing)) {\n\t\treturn true;\n\t}\n\treturn false\n};\n\n\n/**\n * Helper function to determine boolean.  \n *\n * Javascript, instead of considering everything false except a few key words,\n * decided everything is true instead of a few key words.  Why?  Because\n * Javascript.  This function inverts that assumption, so that everything can be\n * considered false unless true. \n *\n * @param   {any}      bool   Thing that you wish was a boolean.  \n * @returns {boolean}         An actual boolean.  \n */\nfunction isBool(bool) {\n\tif (\n\t\tbool === false ||\n\t\tbool === \"false\" ||\n\t\tbool === undefined ||\n\t\tbool === \"undefined\" ||\n\t\tbool === \"\" ||\n\t\tbool === 0 ||\n\t\tbool === \"0\" ||\n\t\tbool === null ||\n\t\tbool === \"null\" ||\n\t\tbool === \"NaN\" ||\n\t\tNumber.isNaN(bool) ||\n\t\tbool === Object(bool) // isObject\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as BSCNV from './base_convert.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tCanon,\n\tCanonical,\n\tCanonicalS,\n\tCanonHash,\n\tCanonHash64,\n}\n\n/**\n * @typedef  {Array|Object} Canon - An array or object representing a canon.  If object, only the first level keys are used as canon.  \n */\n\n\n/**\n * Canon returns the canon from first level object keys.  \n * \n * @param   {Object}          obj      Object to create the canon from.   \n * @returns {Array<String>}            Array. \n */\nfunction Canon(obj) {\n\treturn Object.keys(obj);\n}\n\n/**\n * // TODO logic for optional canon.\n * Canon canonicalizes the first level of \"object\" into the form of \"can\". If\n * \"can\" is empty, the canon is generated from \"object\"'s first level fields.\n *\n * If input \"can\" is an object the first level object keys will be used as the\n * canon.\n * \n * @param   {Object}         object    Object to be canonicalized.   \n * @param   {Array|Object}   [can]     Array|Object. Array|Object canon. \n * @returns {Object}                   Object. Canonicalized object.\n */\nasync function Canonical(object, can) {\n\tlet c = [];\n\tif (typeof can === 'object') {\n\t\tc = Object.keys(can);\n\t}\n\n\t// Is canon empty?  Use current object keys. \n\tif (!can || can.length === 0) {\n\t\tc = Object.keys(object);\n\t} else {\n\t\tc = can;\n\t}\n\n\tlet obj = {};\n\tfor (const e of c) {\n\t\tobj[e] = object[e];\n\t}\n\n\treturn obj\n};\n\n/**\n * Canonical canonicalizes obj and returns a JSON string. \n *\n * @param   {Object}   obj         Object being canonicalized.\n * @param   {Array}    [canon]     Array.  Optional canon.[Optional]\n * @returns {string}               String.\n */\nasync function CanonicalS(obj, can) {\n\treturn JSON.stringify(await Canonical(obj, can));\n};\n\n/**\n * CanonHash, returns hashes.  See docs on Canons.\n *\n * @param   {Object|String} input              Object being canonicalized.\n * @param   {HashAlg}       [digest=SHA-256]   String. Must be SubtleCrypto.digest() compatible.  (i.e. 'SHA-256') [Optional]\n * @param   {Canon}         [canon]            Array. for canonical keys. [Optional]\n * @returns {ArrayBuffer}                      ArrayBuffer. of the digest.  \n */\nasync function CanonHash(input, digest, can) {\n\tif (isEmpty(digest)) {\n\t\tdigest = 'SHA-256';\n\t}\n\tif (typeof input == \"string\") {\n\t\tinput = JSON.parse(input);\n\t}\n\n\tlet ab = await BSCNV.SToArrayBuffer(await CanonicalS(input, can))\n\treturn await crypto.subtle.digest(digest, ab);\n}\n\n/**\n * CanonHash64 returns the b64ut of the digest.  See docs on Canonical.\n *\n * @param {Object|String} obj           Object being canonicalized.\n * @param {String}        [digest]      Subtle crypto compatible digest that's being used.  (i.e. 'SHA-256') [Optional]\n * @param {Array}         [canon]       Array for canonical keys. [Optional]\n * @param {String}                      Hex (string) of the digest.  \n */\nasync function CanonHash64(obj, digest, can) {\n\tlet ab = await CanonHash(obj, digest, can);\n\treturn await BSCNV.ArrayBufferTo64ut(ab);\n}"],
  "mappings": "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",
  "names": []
}
