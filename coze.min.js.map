{
  "version": 3,
  "sources": ["base_convert.js", "coze_enum.js", "cryptokey.js", "coze_key.js", "coze.js", "canon.js"],
  "sourcesContent": ["// base_convert.js is taken from https://github.com/zamicol/BaseConverter and\n// Cyphr.me's `base_convert.js`.\n//\n// Since base conversion is tightly coupled to Coze, instead of importing an\n// external project/repo, this file is copied directly into this project.\n// However, most of these functions are not exported into the Coze module since\n// Coze isn't about base conversion.  See `join.js` for selected exported\n// functions that are useful when interacting with Coze.   \n//\n// If you need general base conversion, see Cyphr.me's `base_convert.js` or\n// `convert.zamicol.com`.  \n\"use strict\";\n\n// Needed in Coze:\nexport {\n\t// Hex\n\tArrayBufferToHex,\n\tHexToArrayBuffer,\n\tSToArrayBuffer,\n\n\t// RFC base 64s\n\tHexTob64ut,\n\tB64ToHex,\n}\n\n/**\n * @typedef {import('./coze.js').Hex}  Hex\n * \n * Unsafe base64 truncated isn't a thing.  If needed, use b64ut instead. \n * @typedef {String} ub64     - Unsafe base 64.  Includes padding. \n * @typedef {String} b64u     - base 64 url.  Includes padding. \n * @typedef {String} b64ut    - base 64 url truncated.  Excludes padding. \n * @typedef {String} Base64   - Cyphr.me Base64.  \n **/\n\n/**\n * Converts a string to an ArrayBuffer.   \n *\n * @param  {string}        String.\n * @return {ArrayBuffer}\n */\nasync function SToArrayBuffer(string) {\n\tvar enc = new TextEncoder(); // Suppose to be always in UTF-8\n\tlet uint8array = enc.encode(string);\n\tlet ab = uint8array.buffer;\n\n\t// Alternatively: (untested) \n\t// var len = string.length;\n\t// var bytes = new Uint8Array(len);\n\t// for (var i = 0; i < len; i++) {\n\t// \tbytes[i] = string.charCodeAt(i);\n\t// }\n\t// let b = await bytes.buffer;\n\n\treturn ab;\n}\n\n/**\n * Converts an ArrayBuffer to a UTF-8 string.   \n *\n * @param  {string} string\n * @return {string}\n */\nasync function ArrayBufferToS(ab) {\n\tvar enc = new TextDecoder(\"utf-8\");\n\tlet s = await enc.decode(ab);\n\treturn s;\n}\n\n/**\n * HexToArrayBuffer converts string Hex to ArrayBuffer. \n * \n * @param   {Hex}          Hex   String Hex. \n * @returns {ArrayBuffer}        ArrayBuffer. \n */\nasync function HexToArrayBuffer(hex) {\n\tif (hex === undefined) { // undefined is different from 0 since 0 == \"AA\"\n\t\treturn new Uint8Array().buffer;\n\t}\n\n\tif ((hex.length % 2) !== 0) {\n\t\tthrow new RangeError('HexToArrayBuffer: Hex is not even.')\n\t}\n\n\tvar a = new Uint8Array(hex.length / 2)\n\tfor (var i = 0; i < hex.length; i += 2) {\n\t\ta[i / 2] = parseInt(hex.substring(i, i + 2), 16)\n\t}\n\n\treturn a.buffer\n};\n\n/**\n * ArrayBufferToHex accepts an ArrayBuffer and returns  Hex.\n * Taken from https://stackoverflow.com/a/50767210/1923095\n * \n * @param   {ArrayBuffer} buffer       ArrayBuffer.\n * @returns {Hex}          hex         String. Hex representation.\n */\nasync function ArrayBufferToHex(buffer) {\n\treturn [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, \"0\")).join('').toUpperCase();\n\n\t// Alternatively:\n\t// let hashArray = Array.from(new Uint8Array(digest)); // convert buffer to byte array\n\t// let hexHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n\n\n////////////////////////////////////////////////////\n////////////////////////////////////////////////////\n// RFC 4648 \"base64\"s\n////////////////////////////////////////////////////\n////////////////////////////////////////////////////\n// Encodings have two features:\n// 1. An alphabet.\n// 2. A conversion method.  \n//\n// RFC 4648 \"base64\" is a bucket convert encoding method with a specific alphabet.  \n// \n// There are several base 64's that we use in two classes:\n//   1. Unsafe base64.  We call it `ub64`.\n//   2. URL Safe base64 (base64 url).  We call it `b64u` or `base64url`.\n//   3. base64 url safe truncated.  We call it `b64ut`. Padding character \"=\"\n//      removed.  \n//   4. Unsafe base64 truncated isn't a thing.  Why?  Use b64ut instead.  \n//   5. Base64, with an upper case \"B\", has a different alphabet and uses the\n//      iterative divide by radix conversion method and is not a bucket\n//      conversion method.  (Cyphr.me defined, not RFC 4648 defined.)  NOT IN\n//      THIS file. \n//\n// NOTE: RFC 4648 uses the lower case \"base64\" to refer to it's encoding method.\n// The casing and spacing is important!  The generic \"base 64\" with a space is\n// used to refer to any encoding system that has a 64 character alphabet.  \n//\n// Why do we need work with the \"Unsafe Base 64\" (ub64)?\n//\n// JOSE's b64ut is truncated with padding removed.  Javascript's `atob` is the\n// only efficient way in Javascript to work with some of these methods even\n// though it's not used directly for JOSE.  The only way to access CryptoKey in\n// Javascript is via JOSE keys.  See notes on CryptoKey.  \n\n\n/**\n * B64ToHex is \"RFC 4648 base64 URL Safe Truncated\" to Hex.  \n * \n * @param   {b64ut} b64ut   String. b64ut.\n * @returns {Hex}           String. Hex.  \n */\nfunction B64ToHex(b64ut) {\n\tlet ub64 = URISafeToUnsafe(b64ut)\n\tconst raw = atob(ub64);\n\tlet result = '';\n\tfor (let i = 0; i < raw.length; i++) {\n\t\tconst hex = raw.charCodeAt(i).toString(16).toUpperCase();\n\t\tresult += (hex.length === 2 ? hex : '0' + hex);\n\t}\n\treturn result;\n}\n\n/**\n * HexTob64ut is hHx to \"RFC 4648 base64 URL Safe Truncated\".  \n * \n * @param   {Hex}    hex    String. Hex.\n * @returns {b64ut}         String. b64ut.\n */\nasync function HexTob64ut(hex) {\n\tlet ab = await HexToArrayBuffer(hex);\n\tlet b64ut = await ArrayBufferTo64ut(ab);\n\treturn b64ut;\n}\n\n/**\n * URISafeToUnsafe base64 url truncated to unsafe base64 (NOT JOSE compatible)\n * // TODO add padding back. \n * \n * @param   {b64ut} b64ut String. RFC 4648 base64 url safe truncated.\n * @returns {ub64}        String. RFC 4648 unsafe base64.\n */\nfunction URISafeToUnsafe(ub64) {\n\t// Replace + and / with - and _\n\treturn ub64.replace(/-/g, '+').replace(/_/g, '/');\n}\n\n/**\n * ArrayBufferTo64ut Array buffer to base64url.\n * \n * @param   {ArrayBuffer} buffer  ArrayBuffer. Arbitrary bytes. UTF-16 is Javascript native.\n * @returns {b64ut}               String. b64ut encoded string.\n */\nfunction ArrayBufferTo64ut(buffer) {\n\tvar string = String.fromCharCode.apply(null, new Uint8Array(buffer));\n\treturn base64t(URIUnsafeToSafe(btoa(string)));\n}\n\n/**\n * URIUnsafeToSafe converts any URI unsafe string to URI safe.  \n * \n * @param   {string} ub64t \n * @returns {string} b64ut \n */\nfunction URIUnsafeToSafe(ub64) {\n\treturn ub64.replace(/\\+/g, '-').replace(/\\//g, '_');\n};\n\n/**\n * base64t removes base64 padding if applicable.   \n * \n * @param   {string} base64 \n * @returns {string} base64t\n */\nfunction base64t(base64) {\n\treturn base64.replace(/=/g, '');\n}", "\"use strict\";\n\nexport {\n\tParams,\n\tCurve,\n\tFamily,\n\tGenus,\n\tHashAlg,\n\tHashSize,\n\tSigSize,\n\tUse,\n}\n\n// See notes on the Go implementation of Coze for more on Alg, Genus, Family,\n// HashAlg, CurveAlg, and  Use.\n\n/** \n* @typedef  {String} Alg     - Coze.Alg.  Alg is the algorithm string, e.g. \"ES256\" \n* @typedef  {String} Genus   - Genus is the genus string,              e.g. \"SHA2\", \"ECDSA\".\n* @typedef  {String} Family  - Family is the family string,            e.g. \"SHA\", \"EC\".\n* @typedef  {String} Hash    - Hash is the hashing algorithm string.   e.g. \"SHA-256\".\n* @typedef  {String} Curve   - Curve is the elliptic curve string,     e.g. \"P-256\".\n* @typedef  {String} Use     - Use is the algorithm use string,        e.g. \"sig\" or \"enc\"\n/*\n\n/** \n* Params holds all relevant values for an `alg`. If values are not applicable\n  for a particular `alg`, values may be populated with the zero value, e.g.\n  for the hash alg \"SHA-256\" Curve's value is 0.\n* @typedef  {Object}  Params\n* @property {string}  Name      - Name is the string representation of alg\n* @property {Genus}   Genus     - Genus is the genus string,                    e.g. \"SHA2\", \"ECDSA\".\n* @property {Family}  Family    - Family is the family string,                  e.g. \"SHA\", \"EC\".\n* @property {Hash}    Hash      - Hash is the hashing algorithm string.         e.g. \"SHA-256\".\n* @property {number}  HashSize  - HashSize is the size/length of the digest.    e.g. 32 for \"SHA-256\".\n* @property {number}  SigSize   - SigSize is the size/length of the signature.  e.g. 64 for \"ES256\".\n* @property {Curve}   Curve     - Curve is the elliptic curve string,           e.g. \"P-256\".\n* @property {Use}     Use       - Use is the algorithm use string,\n/*\n\n/**\n * Params reports all relevant values for a given `alg`.\n * @param {string} alg  String. Alg is the string representation of a coze.Alg\n * @returns {Params}    Params object with populated values for relevant fields\n*/\n function Params(alg) {\n\t/** @type {Params} */\n\tlet p = {Name:alg};\n\tp.Genus = Genus(alg);\n\tp.Family = Family(alg);\n\tp.Hash = HashAlg(alg);\n\tp.HashSize = HashSize(alg);\n\n\ttry {\n\t\tp.Curve = Curve(alg);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\ttry {\n\t\tp.Use = Use(alg);\n\t\tp.SigSize = SigSize(alg);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\treturn p;\n}\n\n/**\n * Genus returns the genus for an alg (ECDSA, EdDSA, SHA-2, SHA-3).\n * See notes on the Go implementation of Coze for more on genus.\n * @param   {Alg}     alg \n * @returns {Use}\n * @throws error\n */\nfunction Genus(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\t\treturn \"ECDSA\";\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"EdDSA\";\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA-512\":\n\t\t\treturn \"SHA2\";\n\t\tcase \"SHA3-224\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHA3-384\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE128\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn \"SHA3\";\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.Genus: unsupported algorithm for genus\");\n\t}\n}\n\n/**\n * Family returns the family for an alg (EC and SHA).\n * See notes on the Go implementation of Coze for more on family.\n * @param   {Alg}     alg \n * @returns {Family}\n * @throws error\n */\nfunction Family(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"EC\";\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA-512\":\n\t\tcase \"SHA3-224\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHA3-384\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE128\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn \"SHA\";\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.Family: unsupported algorithm for family\");\n\t}\n}\n\n/**\n * Hash returns the hashing algorithm for the given algorithm.  \n * See notes on the Go implementation of Coze for more.\n * @param   {Alg}   alg \n * @returns {Hash}  Hash Alg as a string, e.g. \"SHA-256\".\n * @throws error\n */\nfunction HashAlg(alg) {\n\tswitch (alg) {\n\t\tcase \"SHA-224\":\n\t\tcase \"ES224\":\n\t\t\treturn \"SHA-224\";\n\t\tcase \"SHA-256\":\n\t\tcase \"ES256\":\n\t\t\treturn \"SHA-256\";\n\t\tcase \"SHA-384\":\n\t\tcase \"ES384\":\n\t\t\treturn \"SHA-384\";\n\t\tcase \"SHA-512\":\n\t\tcase \"ES512\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\tcase \"Ed25519\":\n\t\t\treturn \"SHA-512\";\n\t\tcase \"SHAKE128\":\n\t\t\treturn \"SHAKE128\";\n\t\tcase \"SHAKE256\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"SHAKE256\";\n\t\tcase \"SHA3-224\":\n\t\t\treturn \"SHA3-224\";\n\t\tcase \"SHA3-256\":\n\t\t\treturn \"SHA3-256\";\n\t\tcase \"SHA3-384\":\n\t\t\treturn \"SHA3-384\";\n\t\tcase \"SHA3-512\":\n\t\t\treturn \"SHA3-512\";\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.HashAlg: unsupported algorithm for HashAlg\");\n\t}\n}\n\n/**\n * HashSize returns the hashing algorithm for the given algorithm.  \n * \n * SHAKE128 has 128 bits of pre-collision resistance and a capacity of 256,\n * although it has arbitrary output size. SHAKE256 has 256 bits of pre-collision\n * resistance and a capacity of 512, although it has arbitrary output size.\n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg - alg string\n * @returns {Number}  size of the hash alg in bytes.  (e.g. 32)\n * @throws error\n */\nfunction HashSize(alg) {\n\t// If given alg that is not a hash, attempt to retrieve the hash alg\n\tlet ha = HashAlg(alg);\n\tif (ha != alg) {\n\t\talg = ha;\n\t}\n\tswitch (alg) {\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA3-224\":\n\t\t\treturn 28;\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHAKE128\":\n\t\t\treturn 32;\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA3-384\":\n\t\t\treturn 48;\n\t\tcase \"SHA-512\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn 64;\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.HashSize: unsupported algorithm for hash size\");\n\t}\n}\n\n/**\n * SigSize returns the signature size for the given algorithm.  \n * \n * Curve P-521 uses 521 bits.  This is then padded up the the nearest byte (528)\n * for R and S. 132 = (528*2)/8\n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg - Sig alg string, e.g. \"ES256\"\n * @returns {Number}  size of the sig alg in bytes.  (e.g. 64)\n * @throws error\n */\n function SigSize(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn 56\n\t\tcase \"ES256\":\n\t\tcase \"Ed25519\":\n\t\t\treturn 64\n\t\tcase \"ES384\":\n\t\t\treturn 96\n\t\tcase \"Ed448\":\n\t\t\treturn 114\n\t\tcase \"ES512\":\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.SigSize: unsupported algorithm for sig size\");\n\t}\n}\n\n/**\n * Curve returns the curve algorithm for the given algorithm.  \n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}    alg \n * @returns {Curve}  The curve alg as a string, e.g. \"SHA-256\".\n * @throws error\n */\nfunction Curve(alg) {\n\tswitch (alg) {\n\t\tcase \"ES256\":\n\t\t\treturn \"P-256\";\n\t\tcase \"ES384\":\n\t\t\treturn \"P-384\";\n\t\tcase \"ES512\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\treturn \"P-521\";\n\t\tcase \"Ed25519\":\n\t\t\treturn \"Curve25519\";\n\t\tcase \"Ed448\":\n\t\t\treturn \"Curve448\";\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.Curve: unsupported algorithm for curve\");\n\t}\n}\n\n/**\n * Use returns the use for the given algorithm.  Only \"sig\" or \"enc\" are\n * currently valid, and Coze currently only uses \"sig\".\n * \n * See notes on the Go implementation of Coze for more\n * @param   {Alg}     alg \n * @returns {Use}     The string \"sig\" or \"enc\"\n * @throws error\n */\nfunction Use(alg) {\n\tswitch (alg) {\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"sig\";\n\t\tdefault:\n\t\t\tthrow new Error(\"coze_enum.Use: unsupported algorithm for use\");\n\t}\n}", "\"use strict\";\n\nimport * as BSCNV from './base_convert.js';\nimport * as Enum from './coze_enum.js';\nimport * as CozeKey from './coze_key.js';\nimport {isEmpty} from './coze.js';\n\nexport {\n\tCryptoKey,\n};\n\nvar CryptoKey = {\n\t/**\n\t * New returns a ECDSA CryptoKeyPair.\n\t * \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKeyPair\n\t *\n\t * @param  {Alg}           [alg=ES256] - Alg of the key to generate.  (e.g. \"ES256\")\n\t * @return {CryptoKeyPair}             - CryptoKeyPair\n\t * @throws \n\t */\n\tNew: async function(alg) {\n\t\tif (isEmpty(alg)) {\n\t\t\talg = \"ES256\"\n\t\t}\n\n\t\t// Javascript only supports ECDSA, and apparently doesn't support ES192 or\n\t\t// ES224.  See https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams\n\t\tif (Enum.Genus(alg) !== \"ECDSA\" || alg == \"ES224\" || alg == \"ES192\") {\n\t\t\tthrow new Error(\"CryptoKey.New: Unsupported key algorithm.\");\n\t\t}\n\n\t\t//generateKey returns a CryptoKeyPair\n\t\tlet keyPair = await window.crypto.subtle.generateKey({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: Enum.Curve(alg)\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[\"sign\", \"verify\"]\n\t\t);\n\t\treturn keyPair;\n\t},\n\n\n\t/**\n\t * ToCryptoKey takes a Coze Key and returns a Javascript CryptoKey.  Only\n\t * supports ECDSA since Crypto.subtle only supports ECDSA. \n\t * \n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key \n\t *\n\t * @param   {CozeKey}    cozeKey     Javascript object Coze key. \n\t * @returns {CryptoKey}              Javascript CryptoKey\n\t * @throws\n\t */\n\tFromCozeKey: async function(cozeKey) {\n\t\tif (Enum.Genus(cozeKey.alg) != \"ECDSA\") {\n\t\t\tthrow new Error(\"CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: \" + cozeKey.alg);\n\t\t}\n\n\t\t// Create a new JWK that can be used to create and \"import\" a CryptoKey\n\t\tvar jwk = {};\n\t\tjwk.use = \"sig\";\n\t\t//jwk.key_ops = [\"sign\", \"verify\"]; // Don't appear to need this anymore in Chrome.  \n\t\tjwk.x = await BSCNV.HexTob64ut(cozeKey.x);\n\t\tjwk.y = await BSCNV.HexTob64ut(cozeKey.y);\n\t\tjwk.crv = Enum.Curve(cozeKey.alg);\n\t\tjwk.kty = \"EC\";\n\n\t\t// Public CryptoKey \"crypto.subtle.importKey\" needs key use to be \"verify\"\n\t\t// even though this doesn't exist in JWK RFC or IANA registry. (2021/05/12)\n\t\t// Gawd help us.  Private CryptoKey needs key `use` to be \"sign\".\n\t\tif (isEmpty(cozeKey.d)) {\n\t\t\tvar signOrVerify = \"verify\";\n\t\t} else {\n\t\t\tsignOrVerify = \"sign\";\n\t\t\tjwk.d = await BSCNV.HexTob64ut(cozeKey.d);\n\t\t}\n\n\t\tvar cryptoKey = await crypto.subtle.importKey(\n\t\t\t\"jwk\",\n\t\t\tjwk, {\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: jwk.crv,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[signOrVerify]\n\t\t);\n\n\t\treturn cryptoKey;\n\t},\n\n\n\t/**\n\t * FromCozeKeyToPublic takes a Coze Key and returns a public Javascript\n\t * CryptoKey. Only supports ECDSA.  \n\t *\n\t * @param   {CozeKey}   cozeKey      Javascript object Coze key. \n\t * @returns {CryptoKey}              Javascript CryptoKey\n\t * @throws\n\t */\n\tFromCozeKeyToPublic: async function(cozeKey) {\n\t\tlet nck = {\n\t\t\t...cozeKey\n\t\t}; // Copy of original. \n\t\tdelete nck.d; // Delete private components\n\t\treturn CryptoKey.FromCozeKey(nck);\n\t},\n\n\n\t/**\n\t * ToPublic accepts a Javascript CryptoKey and returns a public\n\t * Javascript CryptoKey.  \n\t *\n\t * @param   {CryptoKey} CryptoKey   CryptoKey\n\t * @returns {CryptoKey}             Public Javascript CryptoKey\n\t */\n\tToPublic: async function(CryptoKey) {\n\t\t// Javascript objects are \"pass by reference\" and not pass by\n\t\t// value.  One way to copy is by stringify and parses the object. \n\t\t//\n\t\t// let npk = JSON.stringify(privateKey); npk = JSON.parse(npk); \n\t\t//\n\t\t// Alternatively, the `{...obj}` syntax copies.  \n\t\tlet npk = {\n\t\t\t...CryptoKey\n\t\t};\n\n\t\t// Remove the private component `d` from the key.  \n\t\tdelete npk.d;\n\n\t\t// Only [\"verify\"] is a valid `key_ops` value for a public CryptoKey.\n\t\t// `key_ops` must be an array.\n\t\tnpk.key_ops = [\"verify\"];\n\t\treturn npk;\n\t},\n\n\t/**\n\t * CryptoKeyToCozeKey returns a Coze Key from Javascript's \"CryptoKey\" type.  \n\t * \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey\n\t * \n\t * Coze keys are like JOSE JWK's but has a few significant differences. \n\t * \n\t * - Byte-to-string values in Coze are always Hex and never \"RFC 4648 base64 URL\n\t *    Safe Truncated\".\n\t * - Coze keys also use the field `alg` to denote everything about the key: it's\n\t *    use, hashing algorithm, curve, family, etc...\n\t * - The Thumbprint's hashing algorithms must always be in alignment with the\n\t *    algorithm and is not defined universally across the standard.  \n\t * \n\t * See the Coze docs for mor on these differences.  \n\t * \n\t * This function currently only supports ECDSA (ES256. ES384, ES512) as\n\t * crypto.subtle only supports these ECDSA algorithms.\n\t * \n\t * @param   {CryptoKey}   CryptoKey \n\t * @returns {CozeKey}     Coze key.\n\t * @throws \n\t */\n\tToCozeKey: async function(CryptoKey) {\n\t\t// Why are we exporting to JWK?\n\t\t//\n\t\t// 1. There's no access to the key information without exporting.  (The\n\t\t//    browser hides the information from Javascript.)\n\t\t// 2. The exporting formats are limited.  \n\t\t// 3. We can't export to \"raw\" because \"raw\" appears to only work on public\n\t\t//    keys.  This is a private key. \n\t\tlet exported = await window.crypto.subtle.exportKey(\n\t\t\t\"jwk\",\n\t\t\tCryptoKey\n\t\t);\n\n\t\t// From Cryptokey, `exported` key output should is in the following form.  \n\t\t//\n\t\t// {\n\t\t// \t\"crv\": \"P-256\",\n\t\t// \t\"d\": \"GwJgQIcbB29IfWO46QZwansE5XVVOg_CfafcpGk3K9I\",\n\t\t// \t\"key_ops\": [\n\t\t// \t\t\"sign\",\n\t\t// \t\t\"verify\"\n\t\t// \t],\n\t\t// \t\"kty\": \"EC\",\n\t\t// \t\"x\": \"bMgUwXPLFR5WPERFIdUR8f6J9znFlM4fL-TaYr7YNSo\",\n\t\t// \t\"y\": \"vuU0bE-JafF1zEW_MbL-oaO0eGltDeMHIfc_bxkdCHU\",\n\t\t// \t\"use\": \"sig\"\n\t\t// }\n\t\t//\n\t\t// Some aspects of the exported key are in conflict with JOSE.  The `delete`s\n\t\t// below are for reference of how out of alignment the Javascript\n\t\t// representation is from JOSE.  If for some reason a JOSE representation is\n\t\t// required, the deletes are suggested.  \n\t\t//\n\t\t// `delete exported.key_ops;`\n\t\t//\n\t\t// According to RFC 7517 Section 4.3, \"use\" is mutually exclusive with\n\t\t// key_ops. \n\t\t//\n\t\t// `delete exported[\"ext\"];`\n\t\t// \n\t\t// `ext` is define by the Web Cryptography API and does not appear in the\n\t\t// core JOSE RFC's.  It stands for \"extractable\".  Since the key is already\n\t\t// \"extracted\" we don't care, and we're not going to burden downstream with\n\t\t// it.  However, this may need to be added again later if the key is further\n\t\t// manipulated by SubtleCrypto. \n\t\t//\n\t\t// Coze does not use \"crv\", \"kty\", or \"use\" and instead relies solely on\n\t\t// \"alg\". Since alg is not given, it's assumed from `crv` while `kty`is\n\t\t// ignored. `use` is also currently ignored since Coze does not currently\n\t\t// support encryption. \n\n\t\tvar cz = {}; // A new empty coze key.\n\n\t\tif (exported.kty != \"EC\") {\n\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\n\t\tswitch (exported.crv) {\n\t\t\tcase \"P-256\":\n\t\t\t\tcz.alg = \"ES256\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-384\":\n\t\t\t\tcz.alg = \"ES384\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-521\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\t\tcz.alg = \"ES512\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\t\t// console.log(\"exported: \" + JSON.stringify(exported)); // Debugging\n\n\t\t// Key components for a ECDSA keys. \n\t\t// Convert \"RFC 4648 base64 URL Safe Truncated\" to Hex.  \n\t\t// ECDSA and Ed have x\n\t\tcz.x = BSCNV.B64ToHex(exported.x);\n\n\t\t// Only private ECDSA keys have `d`.\n\t\tif (exported.hasOwnProperty('d')) {\n\t\t\tcz.d = BSCNV.B64ToHex(exported.d);\n\t\t}\n\n\t\t// In case of future support: Ed does not have `y` and only uses `x`.  \n\t\tif (exported.hasOwnProperty('y')) {\n\t\t\tcz.y = BSCNV.B64ToHex(exported.y);\n\t\t}\n\n\t\tcz.tmb = await CozeKey.Thumbprint(cz);\n\n\t\treturn cz;\n\t},\n\n\t/**\n\t * Uses a Javascript `CryptoKey` to sign a array buffer.  Returns array buffer\n\t * bytes.  \n\t *\n\t * The signing algorithm's hashing algorithm is used for the digest of the\n\t * payload.  \n\t * \n\t * Coze uses UTF-8 bytes for strings.  \n\t *\n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n\t * \n\t * @param   {CryptoKey}      cryptoKey          \n\t * @param   {ArrayBuffer}    payloadBuffer     \n\t * @returns {ArrayBuffer}    ArrayBuffer of sig\n\t */\n\tSignBuffer: async function(cryptoKey, arrayBuffer) {\n\t\tlet digest = await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey);\n\n\t\tlet signature = await window.crypto.subtle.sign({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: digest\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tarrayBuffer\n\t\t);\n\n\t\treturn signature; // Array Buffer\n\t},\n\n\t/**\n\t * SignBufferToHex signs a buffer with a CryptoKey and returns Hex.\n\t * \n\t * The input (arrayBuffer) is hashed before it's signed.\n\t * \n\t * @param {CryptoKey}   cryptoKey       Private CryptoKey\n\t * @param {ArrayBuffer} arrayBuffer     ArrayBuffer to sign. \n\t * @returns {string}    Hex             Hex as string.\n\t */\n\tSignBufferToHex: async function(cryptoKey, arrayBuffer) {\n\t\tlet ab = await CryptoKey.SignBuffer(cryptoKey, arrayBuffer);\n\t\tlet sig = await BSCNV.ArrayBufferToHex(ab);\n\n\t\treturn sig;\n\t},\n\n\t/**\n\t * SignString signs a string and returns Hex of\n\t *  the signature.  Coze uses UTF8 bytes for strings.  \n\t * @param {CryptoKey} cryptoKey      CryptoKey. Private key used for signing.\n\t * @param {string}    utf8           String. String to sign. \n\t * @returns {string}  hex.           String. Hex as string.\n\t */\n\tSignString: async function(cryptoKey, utf8) {\n\t\tlet buffer = await BSCNV.SToArrayBuffer(utf8);\n\t\tlet hexSig = await CryptoKey.SignBufferToHex(cryptoKey, buffer)\n\t\treturn hexSig;\n\t},\n\n\t/**\n\t * VerifyABMsgSig verifies an ArrayBuffer msg with an ArrayBuffer sig.\n\t *\n\t * Note: For Coze messages, signature is over the digest of of `head`. If\n\t * verifying Coze messages, the message must be the UTF-8 bytes of the\n\t * message, not the digest, because Javascript hashes msg.  \n\t * \n\t * If Javascript ever allowed private keys, this function should support that\n\t * as well.  Currently private keys don't appear to be compatible.  \n\t *\n\t * @param   {CryptoKey}   publicCryptoKey     CryptoKey. Public CryptoKey. \n\t * @param   {ArrayBuffer} sig                 ArrayBuffer. Signature.  \n\t * @param   {ArrayBuffer} msg                 ArrayBuffer. Message.   \n\t * @returns {boolean}                         Boolean. Verified or not.  \n\t */\n\t VerifyABMsgSig: async function(publicCryptoKey, msg, sig) {\n\t\t//console.log({publicCryptoKey, sig, msg});\n\t\tlet hash = await CryptoKey.GetSignHashAlgoFromCryptoKey(publicCryptoKey);\n\t\tlet verified = await window.crypto.subtle.verify({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: hash\n\t\t\t\t},\n\t\t\t},\n\t\t\tpublicCryptoKey,\n\t\t\tsig,\n\t\t\tmsg);\n\n\t\treturn verified;\n\t},\n\n\t/**\n\t * VerifyMsgHexSig verifies a msg string with a Hex sig.\n\t * \n\t * Private keys are currently incompatible due to Javascript design.  \n\t * \n\t * @param   {CryptoKey}  publicCryptoKey   Public Javascript CryptoKey. \n\t * @param   {string}     hexSig            String. Signature in hex.  \n\t * @param   {string}     msg               String that was signed.  \n\t * @returns {boolean}                      Boolean. If signature is valid.  \n\t */\n\t VerifyMsgHexSig: async function(publicCryptoKey, msg, hexSig) {\n\t\thexSig = await BSCNV.HexToArrayBuffer(hexSig);\n\t\tmsg = await BSCNV.SToArrayBuffer(msg);\n\t\treturn CryptoKey.VerifyABMsgSig(publicCryptoKey, msg, hexSig);\n\t},\n\n\t/**\n\t * GetSignHashAlgoFromCryptoKey gets the signing hashing algorithm from the\n\t * CryptoKey.  \n\t *\n\t * Javascript's CryptoKey explicitly requires a signing hashing algorithm, but\n\t * the CryptoKey itself may not explicitly contain that information. \n\t *\n\t * For example, a ES256 key will have the curve (P-256) and the general key\n\t * type (ECDSA), but the hashing algo is not explicitly stated (SHA-256). \n\t *\n\t * However, for some CryptoKeys, the hashing algorithm is explicitly stated.\n\t * For example, \"RsaHashedKeyGenParams\" has the field \"hash\" which explicitly\n\t * denotes what hashing algorithm was used.  As of 2021/05/26,\n\t * \"EcKeyGenParams\" has no such field, so it must be assumed that certain\n\t * hashing algorithms are paired with certain curves.  \n\t *\n\t * The purpose of this function is to return the correct hashing digest for\n\t * all CryptoKeys regardless of their form.  \n\t * @param   {CryptoKey} CryptoKey          \n\t * @returns {String}    digest       String. Name of digest, i.e. SHA-256.\n\t */\n\tGetSignHashAlgoFromCryptoKey: async function(cryptoKey) {\n\t\tlet cz = await CryptoKey.ToCozeKey(cryptoKey);\n\t\tlet alg = await Enum.HashAlg(cz.alg);\n\t\treturn alg;\n\t},\n\n\n}; // End CryptoKey", "\"use strict\";\n\nimport * as CTK from './cryptokey.js';\nimport * as Coze from './coze.js';\nimport * as Can from './canon.js';\nimport * as BSCNV from './base_convert.js';\nimport * as Enum from './coze_enum.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tNewCozeKey,\n\tToPublicCozeKey,\n\n\tVerifyMsg,\n\n\tCorrect,\n\tValid,\n\n\tThumbprint,\n\n\tRevoke,\n\tIsRevoked,\n\n\tIsTmbOnly,\n\n\tECDSATmbCanon,\n\tEdDSATmbCanon,\n}\n\n\n/**\n * @typedef {import('./coze.js').Hex}  Hex\n * @typedef {import('./coze.js').Alg}  Alg\n * @typedef {import('./coze.js').Use}  Use\n * @typedef {import('./coze.js').Sig}  Sig\n * @typedef {import('./coze.js').Time} Time\n * \n * Coze key\n * @typedef  {Object} CozeKey\n * @property {Alg}    alg - Cryptographic signing or encryption algorithm - e.g. \"ES256\"\n * @property {String} kid - Human readable, non programmatic, key identifier - e.g. \"Test Key\"\n * @property {Time}   iat - Unix time key was created. e.g. 1624472390\n * @property {Hex}    tmb - Key thumbprint e.g. \"0148F4CD9093C9CBE3E8BF78D3E6C9B824F11DD2F29E2B1A630DD1CE1E176CDD\"\n * @property {Hex}    [d] - ECDSA private \"d\" component in Hex.  Required for ECDSA private Coze keys.  e.g. \"30C76C9EC4286DADEB0E1EBFF546A1B4A57DB4571412F953E053FB689D286C3C\"\n * @property {Hex}    [x] - ECDSA public \"x\" component in Hex.  Required for ECDSA public Coze keys.    e.g. \"827ECBA80BE7421DD71A6C2819ABC1D988450EBB802B972AE22292FA0D538B6B\"\n * @property {Hex}    [y] - ECDSA public \"y\" component in Hex.  Required for ECDSA public Coze keys.    e.g. \"8D45880FC2C9FD1DBBF28ED4CB973CD8D1CB4F93F422B1B90AC1DA4ED13CA9EC\"\n * \n * @typedef  {CozeKey} PrivateCozeKey - A Coze key containing any private components.  \n * @typedef  {CozeKey} PublicCozeKey  - A Coze key containing no private components and required public components.  \n */\n\n// Coze key Thumbprint Canons.\nconst ECDSATmbCanon = [\"alg\", \"x\", \"y\"];\nconst EdDSATmbCanon = [\"alg\", \"x\"];\n\n/**\n * NewCozeKey returns a new Coze key. \n * \n * @param   {Alg}     [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n * @returns {CozeKey}             - Coze key in Javascript object format\n */\nasync function NewCozeKey(alg) {\n\tif (isEmpty(alg)) {\n\t\talg = \"ES256\"\n\t}\n\tif (Enum.Genus(alg) == \"ECDSA\") {\n\t\tvar keyPair = await CTK.CryptoKey.New(alg);\n\t} else {\n\t\tthrow new Error(\"CozeKey.NewCozeKey: only ECDSA algs are currently supported.\");\n\t}\n\n\tlet CozeKey = await CTK.CryptoKey.ToCozeKey(keyPair.privateKey)\n\n\tCozeKey.iat = Math.floor(Date.now() / 1000); // To get Unix from js, divide by 1000.  \n\tCozeKey.tmb = await Thumbprint(CozeKey);\n\tCozeKey.kid = \"My Cyphr.me Key.\";\n\n\treturn CozeKey;\n}\n\n\n/**\n * Verify verifies a message using the given Coze key.\n * \n * @param   {CozeKey}  cozeKey   - Alg of the key to generate. (e.g. \"ES256\")\n * @param   {String}   msg       - Message to Verify\n * @param   {Hex}      sig       - Signature of message\n * @returns {Boolean}            - If the message is verified.\n */\nasync function VerifyMsg(cozeKey, msg, sig) {\n\tlet msgBuff = await BSCNV.SToArrayBuffer(msg)\n\tlet sigBuff = await BSCNV.SToArrayBuffer(sig)\n\tlet pubKey = await CTK.CryptoKey.FromCozeKeyToPublic(cozeKey);\n\treturn await CTK.CryptoKey.VerifyABMsgSig(pubKey, msgBuff, sigBuff);\n}\n\n/**\n * Thumbprint generates Coze key thumbprint.  Currently only supports ECDSA and\n * Ed25519. \n *\n * @param   {CozeKey} cozeKey - Javascript object Coze key. \n * @returns {tmb}             - Hex thumbprint string\n * @throws \n */\nasync function Thumbprint(cozeKey) {\n\tif (isEmpty(cozeKey.alg)) {\n\t\tthrow new Error(\"CozeKey.Thumbprint: alg is empty.\");\n\t}\n\n\tif (Enum.Genus(cozeKey.alg) != \"ECDSA\" && cozeKey.alg != \"Ed25519\") {\n\t\tthrow new Error(\"CozeKey.Thumbprint: unsupported alg.\");\n\t}\n\n\tif (isEmpty(cozeKey.x)) {\n\t\tthrow new Error(\"CozeKey.Thumbprint: x is empty.\");\n\t}\n\n\tif (Enum.Genus(cozeKey.alg) == \"ECDSA\" && isEmpty(cozeKey.y)) {\n\t\tthrow new Error(\"CozeKey.Thumbprint: y is empty.\");\n\t}\n\n\tlet can = {};\n\tif (Enum.Genus(cozeKey.alg) == \"ECDSA\") {\n\t\tcan = ECDSATmbCanon;\n\t}\n\tif (Enum.Genus(cozeKey.alg) == \"EdDSA\") {\n\t\tcan = EdDSATmbCanon;\n\t}\n\n\tlet hashAlg = await Enum.HashAlg(cozeKey.alg)\n\treturn Can.CHH(cozeKey, hashAlg, can);\n};\n\n/**\n * Valid validates a private Coze key.  See notes on `Correct`.\n *\n * @param   {CozeKey}    privateCozeKey  Private Coze key. \n * @returns {boolean}                    Valid.   \n */\nasync function Valid(privateCozeKey) {\n\ttry {\n\t\tif (isEmpty(privateCozeKey.d)) {\n\t\t\tthrow \"Private Coze key is missing private component 'd'\";\n\t\t}\n\t\tlet b = await Correct(privateCozeKey); // Throws, so `await` keyword is needed must be on two lines. \n\t\treturn b;\n\t} catch (e) {\n\t\t// ignore.\n\t}\n\treturn false;\n}\n\n/**\n * Correct checks for the correct construction of a Coze key.  Always returns\n * true if no error.\n\n * Correct:\n * 1. Ensures required headers exist.\n * 2. Checks if the length of public components are correct.\n * 3. If the key is private (containing private components) generates and verifies a\n *    signature, thus verifying the private key.\n *\n * Correct may return \"true\" on cryptographically invalid public keys since\n * public keys cannot (necessarily) be validated without verifying a signed\n * message. Use function \"Verify\" for public keys with a signed message.  Use\n * function \"Correct\" to check for the correct construction of a public key.  \n * \n * TODO Check for tmb only keys\n *\n * @param   {CozeKey}    cozeKey  Object. Coze key. \n * @returns {boolean}             Boolean. Always returns true unless error.   \n * @throws                        \n */\nasync function Correct(cozeKey) {\n\tlet required = [\n\t\t'alg',\n\t\t'tmb',\n\t]\n\n\tlet tmbOnly = IsTmbOnly(cozeKey);\n\tif (!tmbOnly) {\n\t\tconsole.debug('not a tmb only key');\n\t\trequired.push([\"iat\", \"x\"]);\n\t}\n\n\tfor (let element of required) {\n\t\tif (!(element in cozeKey)) {\n\t\t\tthrow new Error(\"CozeKey.Correct: No '\" + element + \"' in Coze key\");\n\t\t}\n\t}\n\n\tif (cozeKey.alg == \"Ed25519\") {\n\t\tif (cozeKey.x.length < 64) { // Ed25519's public key is 32 bytes (64 in Hex)\n\t\t\tthrow new Error(\"CozeKey.Correct: x is too short.  Has length: \" + cozeKey.x.length);\n\t\t}\n\t}\n\n\tif (tmbOnly) {\n\t\treturn true;\n\t}\n\n\t// Sanity check - No keys from the future allowed.\n\tif (cozeKey.iat > Math.round((Date.now() / 1000))) {\n\t\tthrow new Error(\"CozeKey.Correct: cannot have iat greater than present time\");\n\t}\n\n\tif (Enum.Genus(cozeKey.alg) == \"ECDSA\") {\n\t\t// Hex is twice the size of bytes.  \n\t\tlet size = (Enum.HashSize(Enum.HashAlg(cozeKey.alg))) * 2;\n\t\tif (cozeKey.x.length < size) {\n\t\t\tthrow new Error(\"CozeKey.Correct: x is too short.  Has length: \" + cozeKey.x.length);\n\t\t}\n\t\tif (cozeKey.y.length < size) { // y is required for ECDSA\n\t\t\tthrow new Error(\"CozeKey.Correct: y is too short.  Has length: \" + cozeKey.y.length);\n\t\t}\n\t}\n\n\t// Recalculate the tmb and compare\n\tlet tmb = await Thumbprint(cozeKey);\n\tif (tmb != cozeKey.tmb) {\n\t\tthrow new Error(\"CozeKey.Correct: tmb does not match: \" + tmb);\n\t}\n\n\t// If private key, validate by signing and verifying.\n\tif (!isEmpty(cozeKey.d)) {\n\t\t// console.log(\"Signing for private key. \");\n\t\tlet mld = \"Test Signing\";\n\t\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(cozeKey);\n\t\tlet mldBuffer = await BSCNV.SToArrayBuffer(mld)\n\t\tlet sig = await CTK.CryptoKey.SignBuffer(cryptoKey, mldBuffer);\n\t\tlet pubKey = await CTK.CryptoKey.FromCozeKeyToPublic(cozeKey);\n\t\tlet result = await CTK.CryptoKey.VerifyABMsgSig(pubKey, mldBuffer, sig);\n\n\t\tif (result !== true) {\n\t\t\tthrow new Error(\"CozeKey.Correct: private key invalid.\");\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * ToPublicCozeKey takes a public or private Coze key and returns a normalized\n * public Coze key. Since this takes a \"public or private\" Coze key, this\n * function can act as \"public key sanitization\".\n *\n * Only supports ECDSA/EdDSA at the moment.  \n * \n * @param   {CozeKey} cozeKey  - Javascript object Coze key (public or private). \n * @returns {PublicCozeKey}    - Coze key that contains no private components.  \n * @throws\n */\nasync function ToPublicCozeKey(cozeKey) {\n\tlet nck = {};\n\tnck.alg = cozeKey.alg;\n\tnck.iat = cozeKey.iat;\n\tif (!isEmpty(cozeKey.kid)) {\n\t\tnck.kid = cozeKey.kid;\n\t}\n\tnck.x = cozeKey.x;\n\n\tswitch (Enum.Genus(nck.alg)) {\n\t\tcase \"ECDSA\":\n\t\t\tnck.y = cozeKey.y;\n\t\t\tbreak;\n\t\tcase \"EdDSA\":\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(\"CozeKey.ToPublicCozeKey: Unsupported key algorithm (alg):\" + nck.alg);\n\t}\n\n\tnck.tmb = await Thumbprint(nck);\n\n\t// Return object in order.  \n\tnck = await Can.Canon(nck);\n\treturn nck;\n}\n\n\n/**\n * Revoke generates a self revoke message.  This includes from previous\n * previously revoked keys.  This function only generates a message and does not\n * manipulate the Coze key's `rvk` value.  Currently, a key's `rvk` must be\n * manually set. \n *\n * @param   {CozeKey}   cozeKey            Private Coze key.\n * @param   {String}    [msg]              Optional, human readable non programmatic reason for revoking the key.\n * @returns {cy}                           Cy returned from signing the message.\n * @throws  error                          if cryptoKeyPrivate is nil or invalid.\n */\nasync function Revoke(cozeKey, msg) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"CozeKey.Revoke: Private key not set.  Cannot sign message\");\n\t}\n\n\tif (isEmpty(cozeKey.tmb)) {\n\t\tcozeKey.tmb = await CZK.Thumbprint(cozeKey);\n\t}\n\n\tvar cy = {};\n\tcy.head = {};\n\tif (!isEmpty(msg)) { // Optional revoke message. \n\t\tcy.head.msg = msg;\n\t}\n\tcy.head.rvk = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\tcy.head.typ = \"cyphr.me/key/revoke\";\n\n\t// SignCy does not allow revoked keys to sign messages.  Temporarily remove\n\t// key.revoke and then set back afterward.\n\tlet prevRvk = cozeKey.rvk;\n\tdelete cozeKey.rvk;\n\tcy = await Coze.SignCy(cy, cozeKey);\n\tif (prevRvk !== undefined) {\n\t\tcozeKey.rvk = prevRvk;\n\t}\n\n\treturn cy\n};\n\n/**\n * IsRevoked returns true if a key is marked as revoked. `rvk` should be an\n * integer Unix timestamp, however this function also checks for the string\n * \"true\" as well as the bool `true`.\n *\n * Messages self-revoking keys must have `rvk` with an integer value greater\n * than 0.  \n *\n * @param   {CozeKey}   cozeKey      Private Coze key.          \n * @param   {String}    [msg]        Optional reason for revoking the key.    \n * @returns {boolean}                Revoked or not. \n */\nfunction IsRevoked(cozeKey) {\n\tif (isEmpty(cozeKey.rvk)) {\n\t\treturn false;\n\t}\n\n\tif (parseInt(cozeKey.rvk) > 0 || cozeKey.rvk === true || cozeKey.rvk.toLowerCase() === \"true\") {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Checks if a Coze Key Object is a tmb only key. Logic assumes the following:\n * If a CozeKey has at least 2 fields, AND 'alg' is populated, AND it contains\n * 'tmb', AND either 'x' OR 'iat' is empty, then the Coze Key is considered to\n * be a thumbprint only key.\n * @param   {CozeKey}  ck   Object. CozeKey.\n * @returns {Boolean}       Bool.   True if the CozeKey is a thumbprint only key.\n */\nfunction IsTmbOnly(ck) {\n\tif (isEmpty(ck) || typeof ck !== \"object\") {\n\t\tthrow new Error(\"must pass a valid Coze Key object\");\n\t}\n\tif (Object.keys(ck).length >= 2 && !isEmpty(ck.alg) && !isEmpty(ck.tmb) && (isEmpty(ck.x) || isEmpty(ck.iat))) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "\"use strict\";\n\nimport * as Can from './canon.js'; // import as \"Can\" since func \"Canon\" will conflict in `coze.join.js`. \nimport * as Enum from './coze_enum.js';\nimport * as CZK from './coze_key.js';\nimport * as CTK from './cryptokey.js';\nimport * as BSCNV from './base_convert.js';\n\nexport {\n\tSign,\n\tSignCy,\n\n\tVerify,\n\tVerifyCy,\n\tVerifyCyArray,\n\n\tGetCyParts,\n\n\tHeadCanon,\n\tMsgCanon,\n\n\t// Helpers\n\tisEmpty,\n\tisBool,\n}\n\n// HeadCanon is the minimum required fields for a valid signed cy.head.\n// MsgCanon is the canon for the \"msg\" cy.  \nconst HeadCanon = [\"alg\", \"iat\", \"tmb\", \"typ\"];\nconst MsgCanon = [\"alg\", \"iat\", \"msg\", \"tmb\", \"typ\"];\n\n/**\n@typedef {import('./coze_key.js').CozeKey} CozeKey\n@typedef {import('./coze_enum.js').Alg}    Alg\n\nBasic Coze Types\n@typedef  {String} Hex   - Coze Hex. Hex is upper case and always left padded. \n@typedef  {Hex}    Sig   - The signature.   \n@typedef  {number} Time  - The Unix time.\n\nhead is the minimum `cy.head` object.  `cy.head` or just `head` may have\nmore fields, but a signed coze should minimally have these.  \n@typedef  {Object} head  \n@property {Alg}    alg  - Cryptographic signing or encryption algorithm - e.g. \"ES256\".\n@property {Time}   iat  - Unix time message was signed or encrypted. e.g. 1624472390.\n@property {Hex}    tmb  - Signing thumbprint digest e.g. 0148F4CD9093C9CBE3E8BF78D3E6C9B824F11DD2F29E2B1A630DD1CE1E176CDD.\n@property {String} typ  - Coze object type.  e.g. \"cyphr.me/msg/create\".\n\ncy is a signed or encrypted coze object.  See docs for more about `cy`.\n@typedef  {Object}  cy    \n@property {head}    head   - The `head`.  See head.  \n@property {Sig}     sig    - The Hex signature.  \n@property {Hex}     [cad]  - The canon digest, which is the digest of the canon fields of head.  `cad` may be implicit and not appear in a `cy`.  e.g. ADE8A110C0DC90CAA509CC20213DDF75D6FD5C9920079C79AB6FB15240FFE0A9\n@property {Array}   [can]  - The canon fields of head.  `can` may be implicit and not appear in a `cy`. e.g.  [\"alg\", \"iat\", \"msg\", \"tmb\", \"typ\"]\n@property {CozeKey} [key]  - Public Coze Key used in signing the `cy`.   `key` may be implicit, by `cy.head.tmb`, and not appear in a `cy`.\n*/\n\n/**\n * Sign signs a given `head` with a given private Coze key and returns Hex sig.\n * `head` will be updated with correct values for:\n * 1. `alg` based on key.\n * 2. `iat` to now.\n * 3. `tmb` recalculated from key.\n * @param   {head}    head       `head` object/string.\n * @param   {CozeKey} cozeKey    Private coze key.        \n * @param   {Array}   [canon]    Canon. [Optional]      \n * @returns {Hex}                Hex `sig`.  Empty on invalid. \n * @throws  error                invalid key/parse error.  \n */\nasync function Sign(head, cozeKey, canon) {\n\thead = await sanitize(head, cozeKey, canon);\n\treturn sign(head, cozeKey);\n}\n\n/**\n * SignCy signs `cy.head` with a given private Coze key and returns a new `cy`\n * with `sig` and canonicalized `head` populated.  \n *\n * Why does sSignCy() exist when Sign() already exists?  SignCy returns a\n * canonicalized `cy` while Sign() only returns a signature.  If that's not\n * needed, use `Sign()`: `cy.sig = Sign(cy.head, cozeKey);`\n *\n * @param   {Cy}        cy         Object cy or string cy\n * @param   {CozeKey}   cozeKey    A private coze key.        \n * @param   {Array}     [canon]    Array for canonical keys. [Optional]      \n * @returns {cy}                   Cy.  Empty on invalid. \n * @throws  error                  invalid key/parse error.  \n */\nasync function SignCy(cy, cozeKey, canon) {\n\t// Written like this, instead of calling just Sign(), because although JS\n\t// objects are pass by reference, the order of keys does not change without\n\t// resetting object (For example, `function reset(obj){obj={};}` does not\n\t// reset `obj` because JS is \"pass by sharing\" and not true pass by reference\n\t// for objects.)\n\tlet outCy = {};\n\toutCy.head = await sanitize(cy.head, cozeKey, canon);\n\toutCy.sig = await sign(outCy.head, cozeKey);\n\treturn outCy;\n}\n\n/**\n * sanitize canonicalized head and sets:\n * 1. `alg` based on key.\n * 2. `iat` to now.\n * 3. `tmb` recalculated from key.\n * @param   {head|string}   head       `head` object/string.\n * @param   {CozeKey}       cozeKey    Private coze key.        \n * @param   {Array}         [canon]    Canon. [Optional]      \n * @returns {Hex}                      Hex `sig`.  Empty on invalid. \n * @throws  error                      invalid key/parse error.  \n */\nasync function sanitize(head, cozeKey, canon) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"Coze: Key not set. \");\n\t}\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"Coze: Cannot sign with revoked key.\");\n\t}\n\thead.alg = cozeKey.alg;\n\thead.tmb = await CZK.Thumbprint(cozeKey);\n\thead.iat = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\treturn Can.Canon(head, canon); // Guarantees order.\n}\n\n/**\n * sign signs a given `obj` with a given private Coze key and returns Hex sig.\n * @param   {Object}   obj       `head` object/string.\n * @param   {CozeKey}  cozeKey    Private coze key.          \n * @returns {Hex}                 Hex `sig`.  Empty on invalid. \n * @throws  error                 invalid key/parse error.  \n */\nasync function sign(obj, cozeKey) {\n\treturn CTK.CryptoKey.SignBufferToHex(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozeKey),\n\t\tawait BSCNV.SToArrayBuffer(JSON.stringify(obj))\n\t);\n}\n\n\n/**\n * Verify verifies a `head` with `sig` and returns a boolean.\n *\n * @param  {head}     head       head\n * @param  {CozeKey}  cozekey    CozeKey to use to validate the coze message. \n * @param  {Sig}      sig        Hex sig.   \n * @return {boolean}             invalid key/parse error. \n * @throws error\n */\nasync function Verify(head, cozekey, sig) {\n\treturn CTK.CryptoKey.VerifyABMsgSig(\n\t\tawait CTK.CryptoKey.FromCozeKeyToPublic(cozekey),\n\t\tawait BSCNV.SToArrayBuffer(await Can.Canons(head)),\n\t\tawait BSCNV.HexToArrayBuffer(sig)\n\t);\n};\n\n/**\n * VerifyCy returns a boolean.  Parameter `cy` must have `cy.head` and\n * optionally `cy.sig` and `cy.key`.\n *\n * If parameters `pubkey` or `sig` are set they will respectively overwrite\n * `cy.key` and `cy.sig`.\n * @param  {cy}       cy           `cy` with optional `key` and/or `sig` set.  \n * @param  {CozeKey}  [cozekey]    CozeKey to use to validate the coze message. \n * @param  {Sig}      [sig]        String.  Hex sig.   \n * @return {boolean}               Valid or not\n * @throws error\n */\nasync function VerifyCy(cy, pubkey, sig) {\n\tlet p = await GetCyParts(cy, pubkey, sig);\n\n\tif (p.head.tmb !== p.key.tmb) {\n\t\tthrow new Error(\"Coze.VerifyCy: head.tmb does not match key.tmb.\");\n\t}\n\n\treturn CTK.CryptoKey.VerifyABMsgSig(\n\t\tawait CTK.CryptoKey.FromCozeKeyToPublic(p.key),\n\t\tawait BSCNV.SToArrayBuffer(await Can.Canons(p.head, p.can)),\n\t\tawait BSCNV.HexToArrayBuffer(p.sig));\n};\n\n/**\n * @typedef  {object}  VerifiedArray\n * @property {boolean} VerifiedAll   - Indicates if whole array was verified.  False if anything was not verified or on error.\n * @property {number}  VerifiedCount - Number of objects verified.  \n * @property {number}  FailedCount   - Number of objects that failed verification.  \n * @property {cy[]}    FailedObjs    - Objects that failed verification.\n */\n\n/**\n * VerifyCyArray verifies an array of `cy`s and returns a single \"VerifiedArray\" object.\n *\n * @param  {cy[]}           cy       - Javascript object.  Coze Javascript Object or string.   \n * @param  {CozeKey}        [pubkey] - Javascript object.  CozeKey.   \n * @return {VerifiedArray}\n * @throws error\n */\nasync function VerifyCyArray(cy, CozeKeyPublic) {\n\tif (!Array.isArray(cy)) {\n\t\treturn VerifyCy(cy, CozeKeyPublic)\n\t}\n\n\tvar verifiedObj = {\n\t\tVerifiedAll: false,\n\t\tVerifiedCount: 0,\n\t\tFailedCount: 0,\n\t\tFailedObjs: [],\n\t};\n\n\tlet copy = [...cy]; // Array copy so original isn't modified. \n\n\tfor (let i = 0; i < copy.length; i++) {\n\t\tlet c = copy[i];\n\t\tif (!isEmpty(c.cy)) { // Is message \"cy\" encapsulated?\n\t\t\tc = c.cy;\n\t\t}\n\n\t\tlet valid = await VerifyCy(c, CozeKeyPublic);\n\t\tif (valid) {\n\t\t\tverifiedObj.VerifiedCount++;\n\t\t} else {\n\t\t\tverifiedObj.FailedCount++;\n\t\t\tverifiedObj.FailedObjs.push(copy);\n\t\t}\n\t}\n\n\tif (verifiedObj.FailedCount == 0) {\n\t\tverifiedObj.VerifiedAll = true;\n\t}\n\n\treturn verifiedObj;\n};\n\n/**\n * signObj canonicalizes, signs the object, and returns a Hex signature.It may\n * produce invalid Coze that's cryptographically valid.  Performs canon,\n * signing, and returns the Hex of the signature.  The hashing algorithm is\n * defined by the CozeKey.\n *\n * Formerly CHSH, (Canonical Hash Sign Hex).\n *\n * Don't use this function unless you know what you are doing. \n *\n * @param   {Object|string}  obj       Object to be canonicalized and signed.\n * @param   {CozeKey}        cozeKey   CozeKey object used for signing *and hashing* the Array Buffer. \n * @param   {Array}          [canon]   Array for canonical keys. [Optional]\n * @returns {Hex}                      Hex of the digest.\n * @throws  {SyntaxError}              JSON parse exception.\n */\nasync function signObj(obj, cozeKey, canon) {\n\tif (typeof obj == \"string\") {\n\t\tobj = JSON.parse(obj); // May throw error\n\t}\n\treturn CTK.CryptoKey.SignBufferToHex(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozeKey),\n\t\tawait BSCNV.SToArrayBuffer(await Can.Canons(obj, canon))\n\t);\n};\n\n\n\n/**\n * CyParts \n * \n * @typedef  {Object}  CyParts\n * @property {head}    head - Coze `head` with `alg`, `iat`, and `tmb` set. \n * @property {CozeKey} key  - CozeKey.\n * @property {sig}     sig  - Hex sig.  \n * @property {Array}   can  - Array Canon.  e.g. [\"alg\",\"x\"]\n * @property {Hex}     cad  - \"Canon digest\" \n * @property {Hex}     cyd  - \"Cy digest\" \n */\n\n/**\n * GetCyParts accepts a `cy`, calculates `cad`, `can`, `cyd` and `tmb`, and\n * returns a CyParts object.\n *\n * The input `cy` must always have the field `head` set.\n * \n * `cy` may or may not be encapsulated in a `cy` key.  If the field `cy` does\n * not appear in the first level of input `cy` object it is assume that\n * parameter `cy` is a cy object.\n * \n * The input must also have `cy.key` or parameter \"pubkey\" and `cy.sig` or\n * parameter \"sig\".  If both the parameter and the respective cy component is\n * populated (`cy.key` and `pubkey` or `cy.sig` and `sig`) the parameters\n * (pubkey, sig) will overwrite cy components (`cy.key`, `cy.sig`).  If neither\n * are given an error is thrown. \n *\n * @param  {(cy|string)} cy        Object or string. May be cy or cy.head.   \n * @param  {CozeKey}     [pubkey]  CozeKey that was used to sign the coze message.  \n * @param  {sig}         [sig]     Hex sig.\n * @throws {Error}                 JSON parse exception or other Error.  \n * @return {CyParts}               {head, key, iat, can, cad, cyd, tmb, sig}\n * \n */\nasync function GetCyParts(cy, pubkey, sig) {\n\t// console.log(cy, pubkey, sig); // debugging\n\tif (Array.isArray(cy)) { // Don't attempt for arrays.\n\t\tthrow new Error(\"Coze.GetCyParts: Cy cannot be array.\");\n\t}\n\tlet c = {};\n\tif (typeof cy == \"string\") {\n\t\tc = JSON.parse(cy); // May throw error\n\t} else {\n\t\tc = {\n\t\t\t...cy\n\t\t}; // Copy of original.\n\t}\n\n\t// Is `cy` encapsulated?  If so, unencapsulate.\n\tif (!isEmpty(c.cy)) {\n\t\tc = c.cy;\n\t}\n\n\t/** @type {CyParts} cyp */\n\tvar cyp = {};\n\tcyp.head = c.head;\n\tif (isEmpty(cyp.head)) {\n\t\tthrow new Error(\"Coze.GetCyParts: A head is not set.\");\n\t}\n\n\t// if set, pubkey overwrites key. \n\tif (!isEmpty(pubkey)) {\n\t\tcyp.key = await CZK.ToPublicCozeKey(pubkey); // sanitizes and recalcs tmb\n\t} else {\n\t\tcyp.key = await CZK.ToPublicCozeKey(c.key); // sanitizes and recalcs tmb\n\t}\n\tif (isEmpty(cyp.key)) {\n\t\tthrow new Error(\"Coze.GetCyParts: A public key is not set.\");\n\t}\n\tif (cyp.head.tmb !== cyp.key.tmb) {\n\t\tthrow new Error(\"Coze.GetCyParts: `head.tmb` does not match `key.tmb`.\");\n\t}\n\n\tif (!isEmpty(sig)) {\n\t\tcyp.sig = sig;\n\t}else{\n\t\tcyp.sig = c.sig;\n\t}\n\tif (isEmpty(cyp.sig)) {\n\t\tthrow new Error(\"Coze.GetCyParts: A sig is not set.\");\n\t}\n\n\t// If can is empty, recalculate `can` based on current head. \n\tif (isEmpty(c.can)) {\n\t\tcyp.can = await Can.GenCanon(cyp.head);\n\t} else {\n\t\tcyp.can = c.can;\n\t}\n\n\t// Calculate cad\n\tcyp.cad = await BSCNV.ArrayBufferToHex(await Can.CH(c.head, Enum.HashAlg(c.head.alg), c.can));\n\n\t// Calculate cyd\n\tlet cydIn = '{\"cad\":\"' + cyp.cad + '\",\"sig\":\"' + cyp.sig + '\"}';\n\tlet cydab = await crypto.subtle.digest(Enum.HashAlg(cyp.head.alg), await BSCNV.SToArrayBuffer(cydIn));\n\tcyp.cyd = await BSCNV.ArrayBufferToHex(cydab);\n\n\treturn cyp;\n}\n\n\n\n///////////////////////////////////\n// Helpers\n///////////////////////////////////\n\n/**\n * isEmpty is a helper function to determine if thing is empty. \n * \n * Objects are empty if they have no keys. (Returns len === 0 of object keys.)\n *\n * Functions are considered always not empty. \n * \n * NaN returns true.  (NaN === NaN is always false, as NaN is never equal to\n * anything. NaN is the only JavaScript value unequal to itself.)\n *\n * Don't use on HTMl elements. For HTML elements, use the !== equality check\n * (element !== null).\n *\n * Cannot use CryptoKey with this function since (len === 0) always. \n *\n * @param   {any}     thing    Thing you wish was empty.  \n * @returns {boolean}          Boolean.  \n */\nfunction isEmpty(thing) {\n\tif (typeof thing === 'function') {\n\t\treturn false;\n\t}\n\n\tif (thing === Object(thing)) {\n\t\tif (Object.keys(thing).length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!isBool(thing)) {\n\t\treturn true;\n\t}\n\treturn false\n};\n\n\n/**\n * Helper function to determine boolean.  \n *\n * Javascript, instead of considering everything false except a few key words,\n * decided everything is true instead of a few key words.  Why?  Because\n * Javascript.  This function inverts that assumption, so that everything can be\n * considered false unless true. \n *\n * @param   {any}      bool   Thing that you wish was a boolean.  \n * @returns {boolean}         An actual boolean.  \n */\nfunction isBool(bool) {\n\tif (\n\t\tbool === false ||\n\t\tbool === \"false\" ||\n\t\tbool === undefined ||\n\t\tbool === \"undefined\" ||\n\t\tbool === \"\" ||\n\t\tbool === 0 ||\n\t\tbool === \"0\" ||\n\t\tbool === null ||\n\t\tbool === \"null\" ||\n\t\tbool === \"NaN\" ||\n\t\tNumber.isNaN(bool) ||\n\t\tbool === Object(bool) // isObject\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as BSCNV from './base_convert.js';\nimport {isEmpty} from './coze.js';\n\nexport {\n\tCanon,\n\tCanons,\n\tGenCanon,\n\tCH,\n\tCHH,\n}\n\n/**\n* @typedef  {Array|Object} Canon - An array or object representing a canon.  If object, only the first level keys are used as canon.  \n*/\n\n/**\n * Canon canonicalizes the first level of \"object\" into the form of \"can\". If\n * \"can\" is empty, the canon is generated from \"object\"'s first level fields.\n *\n * If input \"can\" is an object the first level object keys will be used as the\n * canon.\n * \n * @param   {Object}         object    Object to be canonicalized.   \n * @param   {Array|Object}   [can]     Array|Object. Array|Object canon. \n * @returns {Object}                   Object. Canonicalized object.\n */\nasync function Canon(object, can) {\n\tlet c = [];\n\tif (typeof can === 'object') {\n\t\tc = Object.keys(can);\n\t}\n\n\t// Is canon empty?  Use current object keys. \n\tif (!can || can.length === 0) {\n\t\tc = Object.keys(object);\n\t} else {\n\t\tc = can;\n\t}\n\n\tc.sort(); // Sorts in place.  \n\n\tlet obj = {};\n\tfor (const e of c) {\n\t\tobj[e] = object[e];\n\t}\n\n\treturn obj\n};\n\n/**\n * Canons canonicalizes obj and returns a JSON string. \n *\n * @param   {Object}   obj         Object being canonicalized.\n * @param   {Array}    [canon]     Array.  Optional canon.[Optional]\n * @returns {string}               String.\n */\n async function Canons(obj, can) {\n\treturn JSON.stringify(await Canon(obj, can));\n};\n\n\n/**\n * GenCanon returns the sorted array canon from the first level object keys.  \n * \n * @param   {Object} obj           Object to create the canon from.   \n * @returns {Array}                Array. Canon of object.\n */\nfunction GenCanon(obj) {\n\tlet can = Object.keys(obj);\n\tcan.sort(); // Sorts in place\n\treturn can;\n}\n\n\n/**\n * CH, CanonicalHash, returns an array buffer of a digest.  See docs on Canons.\n *\n * @param   {Object|String} obj                Object. being canonicalized.\n * @param   {string}        [digest=SHA-256]   String. Must be SubtleCrypto.digest() compatible.  (i.e. 'SHA-256') [Optional]\n * @param   {array}         [canon]            Array. for canonical keys. [Optional]\n * @returns {ArrayBuffer}                      ArrayBuffer. of the digest.  \n */\nasync function CH(obj, digest, can) {\n\tif (typeof obj == \"string\") {\n\t\tobj = JSON.parse(obj);\n\t}\n\n\tlet string = await Canons(obj, can);\n\tif (isEmpty(digest)) {\n\t\tdigest = 'SHA-256';\n\t}\n\tlet ab = await BSCNV.SToArrayBuffer(string)\n\tab = await crypto.subtle.digest(digest, ab);\n\treturn ab;\n}\n\n/**\n * CHH, CanonicalHashHex, returns the hex of the digest.  See docs on Canonical.\n *\n * @param {Object|String} obj           Object being canonicalized.\n * @param {String}        [digest]      Subtle crypto compatible digest that's being used.  (i.e. 'SHA-256') [Optional]\n * @param {Array}         [canon]       Array for canonical keys. [Optional]\n * @param {String}                      Hex (string) of the digest.  \n */\nasync function CHH(obj, digest, can) {\n\tlet ab = await CH(obj, digest, can);\n\tlet hex = await BSCNV.ArrayBufferToHex(ab);\n\n\treturn hex;\n}\n"],
  "mappings": "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",
  "names": []
}
