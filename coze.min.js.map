{
  "version": 3,
  "sources": ["alg.js", "cryptokey.js", "key.js", "coze.js", "canon.js"],
  "sourcesContent": ["\"use strict\";\n\n// For more documentation and notes, see the main Coze README.\n\nexport {\n\tParams,\n\tCurve,\n\tFamily,\n\tGenus,\n\tHashAlg,\n\tHashSize,\n\tSigSize,\n\tXSize,\n\tDSize,\n\tUse,\n}\n\n/**\n * @typedef {import('./typedefs.js').Alg}     Alg\n * @typedef {import('./typedefs.js').Params}  Params\n * @typedef {import('./typedefs.js').Params}  Genus\n * @typedef {import('./typedefs.js').Family}  Family\n * @typedef {import('./typedefs.js').Hash}    Hash\n * @typedef {import('./typedefs.js').Curve}   Curve\n * @typedef {import('./typedefs.js').Use}     Use\n */\n\n/**\n * Param reports all relevant values for a given `alg`.\n * Returns Params object with populated values for relevant fields.\n * All functions definied in this file will fail/error when given an\n * unsupported algorithm.\n * \n * Go Coze returns 0 on errors, should cozejs do the same?\n * \n * @param   {Alg}      alg\n * @returns {Params}\n * @throws  {Error}\n */\nfunction Params(alg) {\n\t/** @type {Params} */\n\tlet p = {\n\t\tName: alg,\n\t\tB64: {},\n\t};\n\tp.Genus = Genus(alg);\n\tp.Family = Family(alg);\n\tp.Hash = HashAlg(alg);\n\tp.HashSize = HashSize(alg);\n\tp.B64.HashSize = Math.ceil(4 * p.HashSize / 3);\n\tp.Use = Use(alg);\n\n\t// SigAlg parameters\n\ttry {\n\t\tp.SigSize = SigSize(alg);\n\t\tp.XSize = XSize(alg);\n\t\tp.DSize = DSize(alg);\n\t\tp.Curve = Curve(alg);\n\n\t\tp.B64.SigSize = Math.ceil(4 * p.SigSize / 3);\n\t\tp.B64.XSize = Math.ceil(4 * p.XSize / 3);\n\t\tp.B64.DSize = Math.ceil(4 * p.DSize / 3);\n\t} catch (e) {\n\t\t// ignore error\n\t}\n\n\treturn p;\n}\n\n/**\n * Genus returns the genus for an alg (ECDSA, EdDSA, SHA-2, SHA-3).\n * See notes on the Go implementation of Coze for more on genus.\n *\n * @param   {Alg} alg\n * @returns {Genus}\n * @throws  {Error}\n */\nfunction Genus(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\t\treturn \"ECDSA\";\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"EdDSA\";\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA-512\":\n\t\t\treturn \"SHA2\";\n\t\tcase \"SHA3-224\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHA3-384\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE128\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn \"SHA3\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Genus: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Family returns the family for an alg (EC and SHA).\n * See notes on the Go implementation of Coze for more on family.\n *\n * @param   {Alg}     alg\n * @returns {Family}\n * @throws  {Error}\n */\nfunction Family(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\tcase \"ES256\":\n\t\tcase \"ES384\":\n\t\tcase \"ES512\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"EC\";\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA-512\":\n\t\tcase \"SHA3-224\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHA3-384\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE128\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn \"SHA\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Family:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Hash returns the hashing algorithm for the given algorithm.  A hash alg can\n * return itself.\n * See notes on the Go implementation of Coze for more.\n *\n * @param   {Alg}   alg \n * @returns {Hash}\n * @throws  {Error}\n */\nfunction HashAlg(alg) {\n\tswitch (alg) {\n\t\tcase \"SHA-224\":\n\t\tcase \"ES224\":\n\t\t\treturn \"SHA-224\";\n\t\tcase \"SHA-256\":\n\t\tcase \"ES256\":\n\t\t\treturn \"SHA-256\";\n\t\tcase \"SHA-384\":\n\t\tcase \"ES384\":\n\t\t\treturn \"SHA-384\";\n\t\tcase \"SHA-512\":\n\t\tcase \"ES512\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn \"SHA-512\";\n\t\tcase \"SHAKE128\":\n\t\t\treturn \"SHAKE128\";\n\t\tcase \"SHAKE256\":\n\t\tcase \"Ed448\":\n\t\t\treturn \"SHAKE256\";\n\t\tcase \"SHA3-224\":\n\t\t\treturn \"SHA3-224\";\n\t\tcase \"SHA3-256\":\n\t\t\treturn \"SHA3-256\";\n\t\tcase \"SHA3-384\":\n\t\t\treturn \"SHA3-384\";\n\t\tcase \"SHA3-512\":\n\t\t\treturn \"SHA3-512\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashAlg:  unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * HashSize returns the hashing algorithm size for the given algorithm in bytes\n * E.g. 32.\n * \n * SHAKE128 has 128 bits of pre-collision resistance and a capacity of 256,\n * although it has arbitrary output size. SHAKE256 has 256 bits of pre-collision\n * resistance and a capacity of 512, although it has arbitrary output size.\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction HashSize(alg) {\n\tswitch (HashAlg(alg)) {\n\t\tcase \"SHA-224\":\n\t\tcase \"SHA3-224\":\n\t\t\treturn 28;\n\t\tcase \"SHA-256\":\n\t\tcase \"SHA3-256\":\n\t\tcase \"SHAKE128\":\n\t\t\treturn 32;\n\t\tcase \"SHA-384\":\n\t\tcase \"SHA3-384\":\n\t\t\treturn 48;\n\t\tcase \"SHA-512\":\n\t\tcase \"SHA3-512\":\n\t\tcase \"SHAKE256\":\n\t\t\treturn 64;\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.HashSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * SigSize returns the signature size for the given algorithm in bytes.\n * \n * Curve P-521 uses 521 bits.  This is then padded up the the nearest byte (528)\n * for R and S. 132 = (528*2)/8\n * \n * See notes on the Go implementation of Coze for more\n * \n * @param   {Alg}      alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction SigSize(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn 56\n\t\tcase \"ES256\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn 64\n\t\tcase \"ES384\":\n\t\t\treturn 96\n\t\tcase \"Ed448\":\n\t\t\treturn 114\n\t\tcase \"ES512\":\n\t\t\treturn 132\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.SigSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * XSize returns the signature size for the given signature algorithm in bytes.\n * E.g. 64.\n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528) for R and S. (528*2)/8 = 132.\n *\n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction XSize(alg) {\n\tswitch (alg) {\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn 32\n\t\tcase \"ES224\":\n\t\t\treturn 56\n\t\tcase \"Ed448\":\n\t\t\treturn 57\n\t\tcase \"ES256\":\n\t\t\treturn 64\n\t\tcase \"ES384\":\n\t\t\treturn 96\n\t\tcase \"ES512\":\n\t\t\treturn 132 // X and Y are 66 bytes (Rounded up for P521)\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.XSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * DSize returns the signature size for the given signature algorithm in bytes.\n * E.g. 64.\n * \n * ES512 uses Curve P-521 that's 521 bits is padded up the the nearest byte\n * (528). (528)/8 = 66.\n *\n * See notes on the Go implementation of Coze for more\n * \n * @param   {Alg}     alg\n * @returns {Number}\n * @throws  {Error}\n */\nfunction DSize(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn 28\n\t\tcase \"ES256\":\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn 32\n\t\tcase \"ES384\":\n\t\t\treturn 48\n\t\tcase \"Ed448\":\n\t\t\treturn 57\n\t\tcase \"ES512\":\n\t\t\treturn 66\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.DSize: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Curve returns the curve algorithm for the given signature algorithm.\n * E.g. \"P-256\".\n * \n * See notes on the Go implementation of Coze for more.\n *\n * @param   {Alg}    alg \n * @returns {Curve}\n * @throws  {Error}\n */\nfunction Curve(alg) {\n\tswitch (alg) {\n\t\tcase \"ES224\":\n\t\t\treturn \"P-224\";\n\t\tcase \"ES256\":\n\t\t\treturn \"P-256\";\n\t\tcase \"ES384\":\n\t\t\treturn \"P-384\";\n\t\tcase \"ES512\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash.\n\t\t\treturn \"P-521\";\n\t\tcase \"Ed25519\":\n\t\tcase \"Ed25519ph\":\n\t\t\treturn \"Curve25519\";\n\t\tcase \"Ed448\":\n\t\t\treturn \"Curve448\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Curve: unsupported algorithm: \" + alg);\n\t}\n}\n\n/**\n * Use returns the use for the given algorithm.  Only \"sig\", \"enc\", and \"dig\"\n * are currently valid.\n * Encryption (\"enc\") is currently not supported in Coze.\n * \n * See notes on the Go implementation of Coze for more.\n * \n * @param   {Alg}     alg \n * @returns {Use}\n * @throws  {Error}\n */\nfunction Use(alg) {\n\tswitch (Genus(alg)) {\n\t\tcase \"EdDSA\":\n\t\tcase \"ECDSA\":\n\t\t\treturn \"sig\";\n\t\tcase \"SHA2\":\n\t\tcase \"SHA3\":\n\t\t\treturn \"dig\";\n\t\tdefault:\n\t\t\tthrow new Error(\"alg.Use: unsupported algorithm: \" + alg);\n\t}\n}", "\"use strict\";\n\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport * as CZK from './key.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tCryptoKey,\n};\n\n/**\n * @typedef {import('./typedefs.js').B64}      B64\n * @typedef {import('./typedefs.js').Alg}      Alg\n * @typedef {import('./typedefs.js').Sig}      Sig\n * @typedef {import('./typedefs.js').Key}      Key\n * @typedef {import('./typedefs.js').Curve}    Crv\n * @typedef {import('./typedefs.js').Message}  Msg\n */\n\nvar CryptoKey = {\n\n\t/**\n\t * New returns a ECDSA CryptoKeyPair. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/CryptoKeyPair\n\t * \n\t * @param  {Alg}           [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n\t * @return {CryptoKeyPair}\n\t * @throws \n\t */\n\tNew: async function (alg) {\n\t\tif (isEmpty(alg)) {\n\t\t\talg = \"ES256\"\n\t\t}\n\t\t// Javascript only supports ECDSA, and doesn't support ES192 or ES224.  See\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/EcdsaParams\n\t\tif (Alg.Genus(alg) !== \"ECDSA\" || alg == \"ES224\" || alg == \"ES192\") {\n\t\t\tthrow new Error(\"CryptoKey.New: Unsupported key algorithm:\" + alg);\n\t\t}\n\t\treturn await window.crypto.subtle.generateKey({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: Alg.Curve(alg)\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[\"sign\", \"verify\"]\n\t\t);\n\t},\n\n\t/**\n\t * FromCozeKey takes a Coze Key and returns a Javascript CryptoKey.  Only\n\t * supports ECDSA since Crypto.subtle only supports ECDSA. \n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * \n\t * @param   {Key}         cozeKey          Coze key.\n\t * @param   {Boolean}    [public=false]    Return only a public key.\n\t * @returns {CryptoKey}\n\t * @throws\n\t */\n\tFromCozeKey: async function (cozeKey, onlyPublic) {\n\t\tif (Alg.Genus(cozeKey.alg) != \"ECDSA\") {\n\t\t\tthrow new Error(\"CryptoKey.FromCozeKey: unsupported CryptoKey algorithm: \" + cozeKey.alg);\n\t\t}\n\n\t\t// Create a new JWK that can be used to create and \"import\" a CryptoKey\n\t\tvar jwk = {};\n\t\tjwk.use = \"sig\";\n\t\tjwk.crv = Alg.Curve(cozeKey.alg);\n\t\tjwk.kty = \"EC\";\n\n\t\tlet half = Alg.XSize(cozeKey.alg) / 2;\n\t\tlet xyab = await Coze.B64utToUint8Array(cozeKey.x);\n\t\tjwk.x = await Coze.ArrayBufferTo64ut(xyab.slice(0, half));\n\t\tjwk.y = await Coze.ArrayBufferTo64ut(xyab.slice(half));\n\n\t\t// Public CryptoKey \"crypto.subtle.importKey\" needs key use to be \"verify\"\n\t\t// even though this doesn't exist in JWK RFC or IANA registry. (2021/05/12)\n\t\t// Gawd help us.  Private CryptoKey needs key `use` to be \"sign\".\n\t\tif (isEmpty(cozeKey.d) || onlyPublic) {\n\t\t\tvar signOrVerify = \"verify\";\n\t\t} else {\n\t\t\tsignOrVerify = \"sign\";\n\t\t\tjwk.d = cozeKey.d;\n\t\t}\n\n\t\treturn await crypto.subtle.importKey(\n\t\t\t\"jwk\",\n\t\t\tjwk, {\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\tnamedCurve: jwk.crv,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t[signOrVerify]\n\t\t);\n\t},\n\n\t/**\n\t * ToPublic accepts a Javascript CryptoKey and modifies the key to remove\n\t * any private components.\n\t *\n\t * @param   {CryptoKey} cryptoKey\n\t * @returns {void}\n\t */\n\tToPublic: async function (cryptoKey) {\n\t\tdelete cryptoKey.d; // Remove private `d` from the key.\n\t\t// Only [\"verify\"] is a valid `key_ops` value for a public CryptoKey.\n\t\t// `key_ops` must be an array.\n\t\tcryptoKey.key_ops = [\"verify\"];\n\t},\n\n\t/**\n\t * CryptoKeyToCozeKey returns a Coze Key from Javascript's \"CryptoKey\" type.\n\t * (https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) Coze keys are\n\t * similiar to JOSE JWK's but has a few significant differences.\n\t * See the Coze docs for more on these differences.\n\t * \n\t * - Coze Byte-to-string values are always b64ut, \"RFC 4648 base64 URI Safe\n\t * Truncated\".\n\t * - Coze keys also use the field `alg` to denote everything about the key:\n\t * it's use, hashing algorithm, curve, family, signature size, private\n\t * component size, public component size, etc...\n\t * - A Coze key's Thumbprint's hashing algorithm must always be in alignment\n\t * with the alg.  This is unlike JOSE which appears to use SHA-256 even for\n\t * keys that don't use that algorithm.\n\t * \n\t * This function currently only supports ECDSA (ES256. ES384, ES512) as\n\t * crypto.subtle only supports these ECDSA algorithms. From Cryptokey,\n\t * `exported` key output should is in the following form:\n\t * \n\t * {\n\t * \"crv\": \"P-256\",\n\t * \"d\": \"GwJgQIcbB29IfWO46QZwansE5XVVOg_CfafcpGk3K9I\",\n\t * \"key_ops\": [\n\t * \"sign\",\n\t * \"verify\"\n\t * ],\n\t * \"kty\": \"EC\",\n\t * \"x\": \"bMgUwXPLFR5WPERFIdUR8f6J9znFlM4fL-TaYr7YNSo\",\n\t * \"y\": \"vuU0bE-JafF1zEW_MbL-oaO0eGltDeMHIfc_bxkdCHU\",\n\t * \"use\": \"sig\"\n\t * }\n\t * \n\t * Some aspects of the Javascript exported key are in conflict with JOSE. The\n\t * `delete`s below are for reference of how out of alignment the Javascript\n\t * representation is from JOSE.  If for some reason a JOSE representation is\n\t * required, the deletes are suggested.\n\t * \n\t * `delete exported.key_ops;`\n\t * \n\t * According to RFC 7517 Section 4.3, \"use\" is mutually exclusive with\n\t * key_ops.\n\t * \n\t * `delete exported[\"ext\"];`\n\t * \n\t * `ext` is define by the Web Cryptography API and does not appear in the\n\t * core JOSE RFC's.  It stands for \"extractable\".  Since the key is already\n\t * \"extracted\" we don't care, and we're not going to burden downstream with\n\t * it.  However, this may need to be added again later if the key is further\n\t * manipulated by SubtleCrypto. \n\t * \n\t * Coze does not use \"crv\", \"kty\", or \"use\" and instead relies solely on\n\t * \"alg\". Since alg is not given, it's assumed from `crv` while `kty`is\n\t * ignored.\n\t * \n\t * Why are we exporting to JWK?\n\t * 1. There's no access to the key fields without exporting. (The\n\t * browser hides the information from Javascript.)\n\t * 2. The exporting formats are limited.  \n\t * 3. Can't export to \"raw\" because \"raw\" appears to only work on public\n\t * keys.  This may be a private key.\n\t * \n\t * @param   {CryptoKey}   cryptoKey \n\t * @returns {Key}\n\t * @throws  {Error}\n\t */\n\tToCozeKey: async function (cryptoKey) {\n\t\tlet exported = await window.crypto.subtle.exportKey(\n\t\t\t\"jwk\",\n\t\t\tcryptoKey\n\t\t);\n\n\t\tvar czk = {};\n\t\tczk.alg = await CryptoKey.algFromCrv(exported.crv);\n\t\t// Concatenate x and y, but concatenation is done at the byte level, so:\n\t\t// unencode, concatenated, and encoded. \n\t\tlet xui8 = Coze.B64utToUint8Array(exported.x);\n\t\tlet yui8 = Coze.B64utToUint8Array(exported.y);\n\t\tvar xyui8 = new Uint8Array([\n\t\t\t...xui8,\n\t\t\t...yui8,\n\t\t]);\n\t\tczk.x = Coze.ArrayBufferTo64ut(xyui8.buffer);\n\n\t\t// Only private ECDSA keys have `d`.\n\t\tif (exported.hasOwnProperty('d')) {\n\t\t\tczk.d = exported.d;\n\t\t}\n\n\t\tczk.tmb = await CZK.Thumbprint(czk);\n\t\t// console.log(\"exported: \" + JSON.stringify(exported), \"Coze Key: \" + JSON.stringify(czk)); // Debugging\n\t\treturn czk;\n\t},\n\n\t/**\n\t * Uses a Javascript `CryptoKey` to sign a array buffer.  Returns array buffer\n\t * bytes of the signature.\n\t *\n\t * The signing algorithm's hashing algorithm is used for the digest of the\n\t * payload.  \n\t * \n\t * Coze uses UTF-8 bytes for strings.  \n\t *\n\t * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#JSON_Web_Key\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\n\t * \n\t * @param   {CryptoKey}      cryptoKey\n\t * @param   {ArrayBuffer}    payloadBuffer\n\t * @returns {ArrayBuffer}\n\t */\n\tSignBuffer: async function (cryptoKey, arrayBuffer) {\n\t\treturn await window.crypto.subtle.sign({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tarrayBuffer\n\t\t);\n\t},\n\n\t/**\n\t * SignBufferB64 signs a buffer with a CryptoKey and returns base64ut.\n\t * The input is hashed before it's signed.\n\t *\n\t * @param   {CryptoKey}   cryptoKey       Private CryptoKey\n\t * @param   {ArrayBuffer} arrayBuffer     ArrayBuffer to sign.\n\t * @returns {B64}\n\t */\n\tSignBufferB64: async function (cryptoKey, arrayBuffer) {\n\t\treturn await Coze.ArrayBufferTo64ut(await CryptoKey.SignBuffer(cryptoKey, arrayBuffer));\n\t},\n\n\t/**\n\t * SignString signs a string and returns base64ut encoding of the signature.\n\t * Coze uses UTF-8 bytes for strings.\n\t * \n\t * @param   {CryptoKey} cryptoKey      Private key used for signing.\n\t * @param   {String}    utf8           String to sign.\n\t * @returns {B64}\n\t */\n\tSignString: async function (cryptoKey, utf8) {\n\t\treturn await CryptoKey.SignBufferB64(cryptoKey, await Coze.SToArrayBuffer(utf8));\n\t},\n\n\t/**\n\t * VerifyArrayBuffer verifies an ArrayBuffer msg with an ArrayBuffer sig and\n\t * Javascript CryptoKey.\n\t * Returns whether or not message is verified by the given key and signature.\n\t * \n\t * @param   {CryptoKey}   cryptoKey           Javascript CryptoKey.\n\t * @param   {ArrayBuffer} sig                 Signature.\n\t * @param   {ArrayBuffer} msg                 Message.\n\t * @returns {Boolean}\n\t */\n\tVerifyArrayBuffer: async function (cryptoKey, msg, sig) {\n\t\t// Guarantee key is not private to appease Javascript:\n\t\tawait CryptoKey.ToPublic(cryptoKey);\n\t\treturn await window.crypto.subtle.verify({\n\t\t\t\tname: \"ECDSA\",\n\t\t\t\thash: {\n\t\t\t\t\tname: await CryptoKey.GetSignHashAlgoFromCryptoKey(cryptoKey)\n\t\t\t\t},\n\t\t\t},\n\t\t\tcryptoKey,\n\t\t\tsig,\n\t\t\tmsg);\n\t},\n\n\t/**\n\t * VerifyMsg uses a public key to verify a string msg with a b64ut sig.\n\t * Returns whether or not the signature is valid.\n\t * \n\t * @param   {CryptoKey}  cryptoKey         Javascript CryptoKey.\n\t * @param   {Msg}        msg               String that was signed.\n\t * @param   {Sig}        sig               B64 signature.\n\t * @returns {Boolean}\n\t */\n\tVerifyMsg: async function (cryptoKey, msg, sig) {\n\t\treturn CryptoKey.VerifyArrayBuffer(cryptoKey, await Coze.SToArrayBuffer(msg), await Coze.B64uToArrayBuffer(sig));\n\t},\n\n\t/**\n\t * GetSignHashAlgoFromCryptoKey gets the signing hashing algorithm from the\n\t * CryptoKey.\n\t * Returns the name of the hashing algorithm. E.g. \"SHA-256\".\n\t *\n\t * Javascript's CryptoKey explicitly requires a signing hashing algorithm, but\n\t * the CryptoKey itself may not explicitly contain that information. For\n\t * example, a ES256 key will have the curve (P-256) and the general key type\n\t * (ECDSA), but the hashing algo is not explicitly stated (SHA-256), nor is\n\t * the algorithm explicitly stated (ES256).\n\t *\n\t * However, for some CryptoKeys, the hashing algorithm is explicitly stated.\n\t * For example, \"RsaHashedKeyGenParams\" has the field \"hash\" which explicitly\n\t * denotes what hashing algorithm was used.  As of 2021/05/26,\n\t * \"EcKeyGenParams\" has no such field, so it must be assumed that certain\n\t * hashing algorithms are paired with certain curves.\n\t *\n\t * The purpose of this function is to return the correct hashing digest for\n\t * all CryptoKeys regardless of their form.\n\t * \n\t * @param   {CryptoKey} CryptoKey  CryptoKey Javascript object.\n\t * @returns {Alg}\n\t */\n\tGetSignHashAlgoFromCryptoKey: async function (cryptoKey) {\n\t\treturn Alg.HashAlg(await CryptoKey.algFromCrv(cryptoKey.algorithm.namedCurve));\n\t},\n\n\t/**\n\t * algFromCrv returns a SEAlg from the given curve.\n\t * Fails when the curve is not supported or recognized.\n\t * \n\t * @param   {Crv}     src    Curve type. E.g. \"P-256\".\n\t * @returns {Alg}\n\t * @throws  {Error}\n\t */\n\talgFromCrv: async function (crv) {\n\t\tswitch (crv) {\n\t\t\tcase \"P-224\":\n\t\t\t\tvar alg = \"ES224\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-256\":\n\t\t\t\talg = \"ES256\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-384\":\n\t\t\t\talg = \"ES384\";\n\t\t\t\tbreak;\n\t\t\tcase \"P-521\": // P-521 is not ES512/SHA-512.  The curve != the alg/hash. \n\t\t\t\talg = \"ES512\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"CryptoKey.ToCozeKey: Unsupported key algorithm.\");\n\t\t}\n\t\treturn alg;\n\t}\n}; // End CryptoKey", "\"use strict\";\n\nimport * as CTK from './cryptokey.js';\nimport * as Can from './canon.js';\nimport * as Coze from './coze.js';\nimport * as Alg from './alg.js';\nimport {\n\tisEmpty\n} from './coze.js';\n\nexport {\n\tNewKey,\n\tCorrect,\n\tValid,\n\tThumbprint,\n\tRevoke,\n\tIsRevoked,\n\n\t// RecalcX,\n\n\tTmbCanon,\n}\n\n/**\n * @typedef {import('./typedefs.js').B64}  B64\n * @typedef {import('./typedefs.js').Alg}  Alg\n * @typedef {import('./typedefs.js').Use}  Use\n * @typedef {import('./typedefs.js').Sig}  Sig\n * @typedef {import('./typedefs.js').Time} Time\n * @typedef {import('./typedefs.js').Key}  Key\n */\n\n// Coze key Thumbprint Canons.\nconst TmbCanon = [\"alg\", \"x\"];\n\n/**\n * NewKey returns a new Coze key.\n * If no alg is given, the returned key will be an 'ES256' key.\n * \n * @param   {Alg}     [alg=ES256] - Alg of the key to generate. (e.g. \"ES256\")\n * @returns {Key}\n */\nasync function NewKey(alg) {\n\tif (isEmpty(alg)) {\n\t\talg = \"ES256\"\n\t}\n\tif (Alg.Genus(alg) == \"ECDSA\") {\n\t\tvar keyPair = await CTK.CryptoKey.New(alg);\n\t} else {\n\t\tthrow new Error(\"Coze.NewKey: only ECDSA algs are currently supported.\");\n\t}\n\n\tlet k = await CTK.CryptoKey.ToCozeKey(keyPair.privateKey);\n\tk.iat = Math.floor(Date.now() / 1000); // To get Unix from js, divide by 1000.\n\tk.tmb = await Thumbprint(k);\n\tk.kid = \"My Cyphr.me Key.\";\n\n\treturn k;\n}\n\n/**\n * Thumbprint generates and returns a B64 Coze key thumbprint.\n * Fails on empty 'alg' or 'x'.\n *\n * @param   {Key} cozeKey\n * @returns {B64}\n * @throws  {Error}\n */\nasync function Thumbprint(cozeKey) {\n\tif (isEmpty(cozeKey.alg) || isEmpty(cozeKey.x)) {\n\t\tthrow new Error(\"Coze.Thumbprint: alg or x is empty.\");\n\t}\n\treturn Can.CanonicalHash64(cozeKey, await Alg.HashAlg(cozeKey.alg), TmbCanon);\n};\n\n/**\n * Valid validates a private Coze key.  See notes on `Correct`.\n * If the key is invalid, Valid may log an error.\n * Returns whether or not the given key is valid.\n *\n * @param   {Key}      privateCozeKey  Private Coze key.\n * @returns {Boolean}\n */\nasync function Valid(privateCozeKey) {\n\tif (isEmpty(privateCozeKey.d)) {\n\t\tconsole.error(\"Coze key missing `d`\");\n\t\treturn false;\n\t}\n\ttry {\n\t\tlet msg = `7AtyaCHO2BAG06z0W1tOQlZFWbhxGgqej4k9-HWP3DE-zshRbrE-69DIfgY704_FDYez7h_rEI1WQVKhv5Hd5Q`;\n\t\tlet sig = await Coze.Sign(msg, privateCozeKey);\n\t\treturn Coze.Verify(msg, privateCozeKey, sig);\n\t} catch (e) {\n\t\t// Don't throw error, but still log it for debugging.  \n\t\tconsole.log(\"Valid:\" + e);\n\t\treturn false;\n\t}\n}\n\n/**\n * Correct checks for the correct construction of a Coze key, but may return\n * true on cryptographically invalid public keys.  Key must have `alg` and at\n * least one of `tmb`, `x`, and `d`. Using input information, if it is possible\n * to definitively know the given key is incorrect, Correct returns false, but\n * if it's plausible it's correct, Correct returns true. Correct answers the\n * question: \"Is the given Coze key reasonable using the information provided?\".\n * Correct is useful for sanity checking public keys without signed messages,\n * sanity checking `tmb` only keys, and validating private keys. Use function\n * \"Verify\" instead for verifying public keys when a signed message is\n * available. Correct is considered an advanced function. Please understand it\n * thoroughly before use.\n * \n * Correct:\n * \n * 1. Checks the length of `x` and/or `tmb` against `alg`.\n * 2. If `x` and `tmb` are present, verifies correct `tmb`.\n * 3. If `d` is present, verifies correct `tmb` and `x` if present, and verifies\n * the key by verifying a generated signature.\n * \n * @param   {Key}     ck\n * @returns {Boolean}\n */\nasync function Correct(ck) {\n\tif (typeof ck !== \"object\") {\n\t\tconsole.error(\"Correct: CozeKey must be passed in as an object.\");\n\t\treturn false;\n\t}\n\n\tif (isEmpty(ck.alg)) {\n\t\tconsole.error(\"Correct: Alg must be set\");\n\t\treturn false;\n\t}\n\n\tlet p = Alg.Params(ck.alg);\n\n\tlet isTmbEmpty = isEmpty(ck.tmb);\n\tlet isXEmpty = isEmpty(ck.x);\n\tlet isDEmpty = isEmpty(ck.d);\n\n\tif (isTmbEmpty && isXEmpty && isDEmpty) {\n\t\tconsole.error(\"Correct: At least one of [x, tmb, d] must be set\");\n\t\treturn false;\n\t}\n\n\t// tmb only key\n\tif (isXEmpty && isDEmpty) {\n\t\tif (isTmbEmpty || ck.tmb.length !== p.B64.HashSize) {\n\t\t\tconsole.error(\"Correct: Incorrect `tmb` size: \", ck.tmb.length);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// d is not set\n\tif (!isXEmpty && ck.x.length !== p.B64.XSize) {\n\t\tconsole.error(\"Correct: Incorrect x size: \", ck.x.length);\n\t\treturn false;\n\t}\n\n\t// We currently do not support recalculating `x`, as subtle does not provide\n\t// the necessary API for computing the points from the private component.\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle\n\t//\n\t// See RecalcX docs below\n\t//\n\t// If d and (x and/or tmb) is given, recompute from d and compare:\n\t// let x = RecalcX(ck);\n\n\t// If tmb is set, recompute and compare.\n\tif (!isTmbEmpty && !isXEmpty) {\n\t\tlet t = await Thumbprint(ck);\n\t\tif (ck.tmb !== t) {\n\t\t\tconsole.error(\"Correct: Incorrect given `tmb`: \", ck.tmb);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// // Sanity check - No keys from the future allowed.\n\t// if (ck.iat > Math.round((Date.now() / 1000))) {\n\t// \tconsole.error(\"Correct: cannot have iat greater than present time\");\n\t// }\n\n\n\t// If private key, validate by signing and verifying.\n\t// `x` must also be populated, for cryptokey, since we do not have RecalcX().\n\tif (!isDEmpty && !isXEmpty) {\n\t\tlet cryptoKey = await CTK.CryptoKey.FromCozeKey(ck);\n\t\tlet mldBuffer = await Coze.SToArrayBuffer(\"Test Signing\")\n\t\tlet sig = await CTK.CryptoKey.SignBuffer(cryptoKey, mldBuffer);\n\t\tlet pubKey = await CTK.CryptoKey.FromCozeKey(ck, true);\n\t\tlet result = await CTK.CryptoKey.VerifyArrayBuffer(pubKey, mldBuffer, sig);\n\n\t\tif (!result) {\n\t\t\tconsole.error(\"Correct: private key invalid.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n\n// TODO Support RecalcX if crypto.subtle provides necessary API for computing\n// https://stackoverflow.com/questions/72151096/how-to-derive-public-key-from-private-key-using-webcryptoapi/72153942#72153942\n//\n// scalar/jacobian/affinity from private component.\n// Alternatively, use noble.\n// function RecalcX(ck) {\n// \tlet x;\n// \tswitch (ck.alg) {\n// \t\tcase \"ES256\":\n// \t\tcase \"ES384\":\n// \t\tcase \"ES512\":\n// \t\t\tbreak;\n// \t\tdefault:\n// \t\t\tx = null;\n// \t}\n\n// \treturn x;\n// }\n\n\n/**\n * Revoke generates a self revoke message and sets the input key as revoked.\n * Returns the signed Coze.\n * Fails if cryptoKeyPrivate is nil or invalid.\n * \n * @param   {Key}       cozeKey  Private Coze key.\n * @param   {String}    [msg]    Optional, human readable non programmatic reason for revoking the key.\n * @returns {Coze}\n * @throws  {Error}\n */\nasync function Revoke(cozeKey, msg) {\n\tif (isEmpty(cozeKey)) {\n\t\tthrow new Error(\"CozeKey.Revoke: Private key not set.  Cannot sign message\");\n\t}\n\n\tvar coze = {};\n\tcoze.pay = {};\n\tif (!isEmpty(msg)) { // Optional revoke message. \n\t\tcoze.pay.msg = msg;\n\t}\n\tcoze.pay.rvk = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\t// SignCoze does not allow revoked keys to sign messages.  Temporarily remove\n\t// key.revoke and then set back afterward, otherwise set key with new revoke. \n\tlet prevRvk = cozeKey.rvk;\n\tdelete cozeKey.rvk;\n\tcoze = await Coze.SignCoze(coze, cozeKey);\n\tif (prevRvk !== undefined) {\n\t\tcozeKey.rvk = prevRvk;\n\t} else {\n\t\tcozeKey.rvk = coze.pay.rvk;\n\t}\n\n\treturn coze\n};\n\n/**\n * IsRevoked returns true if a key or a coze is marked as revoked. `rvk` should\n * be an integer Unix timestamp, however this function also checks for the\n * string \"true\" as well as the bool `true`.\n *\n * Messages self-revoking keys must have `rvk` with an integer value greater\n * than 0.  \n *\n * @param   {Key|Coze}       cozeKey  Coze key or coze object.\n * @param   {String}         [msg]    Optional reason for revoking the key.\n * @returns {Boolean}\n */\nfunction IsRevoked(cozeKey) {\n\tif (isEmpty(cozeKey.rvk) || !(parseInt(cozeKey.rvk) > 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport * as Can from './canon.js'; // import as \"Can\" since func \"Canon\" will conflict in `coze.join.js`.\nimport * as Enum from './alg.js';\nimport * as CZK from './key.js';\nimport * as CTK from './cryptokey.js';\n\nexport {\n\tPayCanon,\n\tSign,\n\tSignCoze,\n\tSignCozeRaw,\n\tVerify,\n\tVerifyCoze,\n\tVerifyCozeArray,\n\tMeta,\n\n\t// Base conversion\n\tSToArrayBuffer,\n\tB64uToArrayBuffer,\n\tB64utToUint8Array,\n\tArrayBufferTo64ut,\n\n\t// Helpers\n\tisEmpty,\n\tisBool,\n}\n\n/**\n * @typedef {import('./typedefs.js').Key}            Key\n * @typedef {import('./typedefs.js').Alg}            Alg\n * @typedef {import('./typedefs.js').Canon}          Canon\n * @typedef {import('./typedefs.js').Message}        Message\n * @typedef {import('./typedefs.js').Coze}           Coze\n * @typedef {import('./typedefs.js').Sig}            Sig\n * @typedef {import('./typedefs.js').Meta}           Meta\n * @typedef {import('./typedefs.js').VerifiedArray}  VerifiedArray\n */\n\n// PayCanon is the standard coze.pay fields.\nconst PayCanon = [\"alg\", \"iat\", \"tmb\", \"typ\"];\n\n/**\n * Sign signs message with private Coze key and returns b64ut sig.\n * Returns empty on invalid.\n * \n * @param   {Message}       message    Message string.\n * @param   {Key}           cozeKey    Private coze key.\n * @returns {Sig}\n * @throws  {Error}\n */\nasync function Sign(message, cozeKey) {\n\treturn CTK.CryptoKey.SignBufferB64(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozeKey),\n\t\tawait SToArrayBuffer(message)\n\t);\n}\n\n/**\n * SignCoze signs in place coze.pay with a private Coze key. Returns the same,\n * but updated, coze.  Errors on mismatch `alg` or `tmb`.  If empty, `alg` and\n * `tmb` are populated. `iat` set to current time.\n *\n * SignCoze, SignCozeRaw, VerifyCoze, and VerifyCozeArray assumes that object\n * has no duplicate fields since this is disallowed in Javascript.\n * \n * Returns the same coze that was given.\n * \n * Fails on invalid key, parse error, mismatch fields.\n * \n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}\n * @throws  {Error}\n */\nasync function SignCoze(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"Coze: Cannot sign with revoked key.\");\n\t}\n\tif (isEmpty(coze.pay.alg)) {\n\t\tcoze.pay.alg = cozeKey.alg;\n\t}\n\tif (isEmpty(coze.pay.tmb)) {\n\t\tcoze.pay.tmb = await CZK.Thumbprint(cozeKey);\n\t}\n\tif (coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"SignCoze: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"SignCoze: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\n\tcoze.pay.iat = Math.round((Date.now() / 1000)); // Javascript's Date converted to Unix time.\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\n\tcoze.sig = await Sign(await JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n\n/**\n * SignCozeRaw signs in place coze.pay with a private Coze key, but unlike\n * SignCoze, does not set `alg`, `tmb` or `iat`. Returns the same, but updated,\n * coze. Errors on mismatch `alg` or `tmb`.\n *\n * @param   {Coze}      coze       Object coze.\n * @param   {Key}       cozeKey    A private coze key.\n * @param   {Canon}     [canon]    Array for canonical keys.\n * @returns {Coze}\n * @throws  {Error}\n */\nasync function SignCozeRaw(coze, cozeKey, canon) {\n\tif (CZK.IsRevoked(cozeKey)) {\n\t\tthrow new Error(\"SignCozeRaw: Cannot sign with revoked key.\");\n\t}\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"SignCozeRaw: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\n\tif (!isEmpty(canon)) {\n\t\tcoze.pay = await Can.Canonical(coze.pay, canon);\n\t}\n\tcoze.sig = await Sign(await JSON.stringify(coze.pay), cozeKey);\n\treturn coze;\n}\n\n/**\n * Verify verifies a `pay` with `sig` and returns whether or not the message is\n * verified. Verify does no Coze checks.  If checks are needed, use\n * VerifyCoze();\n *\n * @param  {Message}   message    Message string.\n * @param  {Key}       cozekey    Coze key for validation.\n * @param  {Sig}       sig        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function Verify(message, cozekey, sig) {\n\treturn CTK.CryptoKey.VerifyMsg(\n\t\tawait CTK.CryptoKey.FromCozeKey(cozekey, true),\n\t\tmessage,\n\t\tsig,\n\t);\n};\n\n/**\n * VerifyCoze returns a whether or not the Coze is valid. coze.sig must be set.\n * If set, pay.alg and pay.tmb must match with cozeKey.\n * \n * @param  {Coze}     coze         Coze with signed pay.\n * @param  {Key}      [cozeKey]    Public Coze key for verification.\n * @param  {Sig}      [sig]        Signature.\n * @return {Boolean}\n * @throws {Error}\n */\nasync function VerifyCoze(coze, cozeKey) {\n\tif (!isEmpty(coze.pay.alg) && coze.pay.alg !== cozeKey.alg) {\n\t\tthrow new Error(\"Coze: Coze key alg mismatch with coze.pay.alg.\");\n\t}\n\tif (!isEmpty(coze.pay.tmb) && coze.pay.tmb !== cozeKey.tmb) {\n\t\tthrow new Error(\"Coze: Coze key tmb mismatch with coze.pay.tmb.\");\n\t}\n\treturn Verify(JSON.stringify(coze.pay), cozeKey, coze.sig);\n}\n\n/**\n * VerifyCozeArray verifies an array of `coze`s and returns a single\n * \"VerifiedArray\" object.\n *\n * @param  {coze[]}           coze       - Array of Coze objects.\n * @param  {Key}              cozeKey    - Javascript object.  Coze Key.\n * @return {VerifiedArray}\n * @throws {Error}\n */\nasync function VerifyCozeArray(coze, cozeKey) {\n\tif (!Array.isArray(coze)) {\n\t\treturn VerifyCoze(coze, cozeKey)\n\t}\n\n\t/** @type {VerifiedArray} */\n\tvar verifiedObj = {\n\t\tVerifiedAll: false,\n\t\tVerifiedCount: 0,\n\t\tFailedCount: 0,\n\t\tFailedCoze: [],\n\t};\n\n\tlet copy = [...coze]; // Copy so original isn't modified.\n\tfor (let c of copy) {\n\t\tif (!isEmpty(c.coze)) { // \"coze\" encapsulated?\n\t\t\tc = c.coze;\n\t\t}\n\n\t\tlet valid = await VerifyCoze(c, cozeKey);\n\t\tif (valid) {\n\t\t\tverifiedObj.VerifiedCount++;\n\t\t} else {\n\t\t\tverifiedObj.FailedCount++;\n\t\t\tverifiedObj.FailedCoze.push(c);\n\t\t}\n\t}\n\n\tif (verifiedObj.FailedCount == 0) {\n\t\tverifiedObj.VerifiedAll = true;\n\t}\n\n\treturn verifiedObj;\n};\n\n\n/**\n * Meta recalculates and sets [can, cad, czd] for given `coze`. Coze.Pay, and\n * Coze.Sig must be set, and either Coze.Pay.Alg or parameter alg must be set.\n * Meta does no cryptographic verification.\n * Fails on JSON parse exception.\n * Returns a Meta Coze (sets fields [can, cad, czd]).\n *\n * @param  {Coze}      coze     coze.\n * @param  {Alg}       [alg]    coze.pay.alg takes precedence.\n * @return {Meta}\n * @throws {Error}\n */\nasync function Meta(coze, alg) {\n\tif (!isEmpty(coze.pay.alg)) {\n\t\talg = Enum.HashAlg(coze.pay.alg);\n\t} else {\n\t\talg = Enum.HashAlg(alg);\n\t}\n\n\tcoze.can = await Can.Canon(coze.pay);\n\tcoze.cad = await Can.CanonicalHash64(coze.pay, alg);\n\tconsole.debug({\n\t\t...coze\n\t})\n\tcoze.czd = await Can.CanonicalHash64({\n\t\t\"cad\": coze.cad,\n\t\t\"sig\": coze.sig\n\t}, alg);\n\tconsole.debug({\n\t\t...coze\n\t})\n\treturn coze;\n}\n\n\n///////////////////////////////////\n// Base Conversion\n///////////////////////////////////\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @param  {String}        string\n * @return {ArrayBuffer}\n */\nasync function SToArrayBuffer(string) {\n\tvar enc = new TextEncoder(); // Suppose to be always in UTF-8\n\treturn enc.encode(string).buffer;\n}\n\n/**\n * B64uToArrayBuffer takes a b64u (truncated or not truncated) string and\n * decodes it to an ArrayBuffer.\n * \n * @param   {B64}          string \n * @returns {ArrayBuffer}\n */\nfunction B64uToArrayBuffer(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0)).buffer;\n};\n\n/**\n * B64utToUint8Array takes a b64ut string and decodes it back into a string.\n * \n * @param   {B64}          string \n * @returns {Uint8Array}\n */\nfunction B64utToUint8Array(string) {\n\t// atob doesn't care about the padding character '='\n\treturn Uint8Array.from(atob(string.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));\n};\n\n\n/**\n * ArrayBufferTo64ut returns a b64 string from an Array buffer.\n * \n * @param   {ArrayBuffer} buffer  Arbitrary bytes. UTF-16 is Javascript native.\n * @returns {B64}\n */\nfunction ArrayBufferTo64ut(buffer) {\n\tvar string = String.fromCharCode.apply(null, new Uint8Array(buffer));\n\treturn btoa(string).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\n\n///////////////////////////////////\n// Helpers - Taken from Cyphr.me\n///////////////////////////////////\n\n/**\n * isEmpty is a helper function to determine if thing is empty. \n * \n * Objects are empty if they have no keys. (Returns len === 0 of object keys.)\n *\n * Functions are considered always not empty. \n * \n * NaN returns true.  (NaN === NaN is always false, as NaN is never equal to\n * anything. NaN is the only JavaScript value unequal to itself.)\n *\n * Don't use on HTMl elements. For HTML elements, use the !== equality check\n * (element !== null).\n *\n * Cannot use CryptoKey with this function since (len === 0) always. \n *\n * @param   {any}     thing    Thing you wish was empty.\n * @returns {Boolean}\n */\nfunction isEmpty(thing) {\n\tif (typeof thing === 'function') {\n\t\treturn false;\n\t}\n\n\tif (thing === Object(thing)) {\n\t\tif (Object.keys(thing).length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!isBool(thing)) {\n\t\treturn true;\n\t}\n\treturn false\n};\n\n\n/**\n * Helper function to determine boolean.  \n *\n * Javascript, instead of considering everything false except a few key words,\n * decided everything is true instead of a few key words.  Why?  Because\n * Javascript.  This function inverts that assumption, so that everything can be\n * considered false unless true. \n *\n * @param   {any}      bool   Thing that you wish was a boolean.  \n * @returns {Boolean}\n */\nfunction isBool(bool) {\n\tif (\n\t\tbool === false ||\n\t\tbool === \"false\" ||\n\t\tbool === undefined ||\n\t\tbool === \"undefined\" ||\n\t\tbool === \"\" ||\n\t\tbool === 0 ||\n\t\tbool === \"0\" ||\n\t\tbool === null ||\n\t\tbool === \"null\" ||\n\t\tbool === \"NaN\" ||\n\t\tNumber.isNaN(bool) ||\n\t\tbool === Object(bool) // isObject\n\t) {\n\t\treturn false;\n\t}\n\treturn true;\n};", "\"use strict\";\n\nimport {\n\tisEmpty,\n\tSToArrayBuffer,\n\tArrayBufferTo64ut\n} from './coze.js';\n\nexport {\n\tCanon,\n\tCanonical,\n\tCanonicalS,\n\tCanonicalHash,\n\tCanonicalHash64,\n}\n\n/**\n * @typedef {import('./typedefs.js').Digest}  Digest\n * @typedef {import('./typedefs.js').Hash}    Hash\n * @typedef {import('./typedefs.js').Canon}   Canon\n */\n\n/**\n * Canon returns the canon from first level object keys.\n * \n * @param   {Object}          obj      Object to create the canon from.\n * @returns {Array<String>}\n */\nfunction Canon(obj) {\n\treturn Object.keys(obj);\n}\n\n/**\n * Canon canonicalizes the first level of \"object\" into the form of \"can\".\n * \n * @param   {Object}  object    Object to be canonicalized.\n * @param   {Canon}   [can]     Array|Object canon.\n * @returns {Object}            Canonicalized object.\n * @throws  {Error}             Fails on invalid canon.\n */\nasync function Canonical(object, can) {\n\tif (isEmpty(can)) {\n\t\treturn object;\n\t}\n\n\tlet obj = {};\n\tfor (const e of can) {\n\t\tobj[e] = object[e];\n\t}\n\treturn obj;\n}\n\n/**\n * Returns whether or not the Canon has duplicate fields.\n *\n * @param   {Canon}    can     Array|Object canon.\n * @returns {Boolean}\n */\nfunction HasDuplicates(can) {\n\tlet result = [];\n\tfor (let v of can) {\n\t\tif (result.includes(v)) {\n\t\t\treturn true;\n\t\t}\n\t\tresult.push(v);\n\t}\n\treturn false;\n}\n\n/**\n * Canonical canonicalizes obj and returns a JSON string.\n *\n * @param   {Object}   obj         Object being canonicalized.\n * @param   {Canon}    [canon]     Optional canon.\n * @returns {String}\n */\nasync function CanonicalS(obj, can) {\n\treturn JSON.stringify(await Canonical(obj, can));\n}\n\n/**\n * CanonicalHash put input into canonical form and returns the array buffer of\n * the digest.\n * Fails if hash is not given.\n *\n * @param   {Object}        input     Object being canonicalized.\n * @param   {Hash}          hash      Must be SubtleCrypto.digest() compatible (i.e. 'SHA-256').\n * @param   {Canon}         [canon]   Array for canonical keys.\n * @returns {ArrayBuffer}\n * @throws  {Error}\n */\nasync function CanonicalHash(input, hash, can) {\n\tif (isEmpty(hash)) {\n\t\tthrow new Error(\"Hash is not given\");\n\t}\n\treturn await crypto.subtle.digest(hash, await SToArrayBuffer(await CanonicalS(input, can)));\n}\n\n/**\n * CanonicalHash64 returns the b64ut digest. See docs on Canonical.\n *\n * @param   {Object|String}  obj         Object being canonicalized.\n * @param   {Hash}           [hash]      Subtle crypto compatible digest that's being used (i.e. 'SHA-256').\n * @param   {Canon}          [canon]     Array for canonical keys.\n * @returns {Digest}\n */\nasync function CanonicalHash64(obj, hash, can) {\n\treturn await ArrayBufferTo64ut(await CanonicalHash(obj, hash, can));\n}"],
  "mappings": "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",
  "names": []
}
